"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["common"],{

/***/ 3023:
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessKey: function() { return /* binding */ AccessKey; },\n/* harmony export */   AdminNotice: function() { return /* binding */ AdminNotice; },\n/* harmony export */   AndroidAppVersion: function() { return /* binding */ AndroidAppVersion; },\n/* harmony export */   AndroidBuildNumber: function() { return /* binding */ AndroidBuildNumber; },\n/* harmony export */   AndroidDeviceModel: function() { return /* binding */ AndroidDeviceModel; },\n/* harmony export */   AppVersion: function() { return /* binding */ AppVersion; },\n/* harmony export */   BaseEntity: function() { return /* binding */ BaseEntity; },\n/* harmony export */   BlacklistedUserAgent: function() { return /* binding */ BlacklistedUserAgent; },\n/* harmony export */   ChromeVersion: function() { return /* binding */ ChromeVersion; },\n/* harmony export */   Configuration: function() { return /* binding */ Configuration; },\n/* harmony export */   DeviceModel: function() { return /* binding */ DeviceModel; },\n/* harmony export */   GenerationHistory: function() { return /* binding */ GenerationHistory; },\n/* harmony export */   IOSVersion: function() { return /* binding */ IOSVersion; },\n/* harmony export */   InstagramDeviceModel: function() { return /* binding */ InstagramDeviceModel; },\n/* harmony export */   InstagramVersion: function() { return /* binding */ InstagramVersion; },\n/* harmony export */   ResolutionDpi: function() { return /* binding */ ResolutionDpi; },\n/* harmony export */   User: function() { return /* binding */ User; },\n/* harmony export */   UserGeneration: function() { return /* binding */ UserGeneration; },\n/* harmony export */   isSupabaseAvailable: function() { return /* binding */ isSupabaseAvailable; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ 1685);\n\nconst supabaseUrl = \"https://pozoauxismiqgytbsjic.supabase.co\" || 0;\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBvem9hdXhpc21pcWd5dGJzamljIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ4MTkyNjksImV4cCI6MjA3MDM5NTI2OX0.RiZZ0Phft_U3XShCvWwKpeFQtwve3ZfCaX9WETPfBGU\" || 0;\n// Only create client if both URL and key are available\nconst supabase = supabaseUrl && supabaseAnonKey ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        autoRefreshToken: true,\n        persistSession: true,\n        detectSessionInUrl: true\n    }\n}) : null;\nconst isSupabaseAvailable = ()=>{\n    return supabase !== null && supabaseUrl && supabaseAnonKey;\n};\n// Database entity classes\nclass BaseEntity {\n    static async list() {\n        let orderBy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"id\";\n        if (!isSupabaseAvailable()) {\n            console.warn(\"Supabase not available for \".concat(this.tableName));\n            return [];\n        }\n        console.log(\"Fetching data from \".concat(this.tableName, \"...\"));\n        const { data, error } = await supabase.from(this.tableName).select(\"*\").order(orderBy.startsWith(\"-\") ? orderBy.slice(1) : orderBy, {\n            ascending: !orderBy.startsWith(\"-\")\n        });\n        console.log(\"\".concat(this.tableName, \" data:\"), data);\n        console.log(\"\".concat(this.tableName, \" error:\"), error);\n        if (error) {\n            console.error(\"Error fetching \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return data || [];\n    }\n    static async create(data) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Creating \".concat(this.tableName, \":\"), data);\n        const { data: result, error } = await supabase.from(this.tableName).insert(data).select().single();\n        console.log(\"\".concat(this.tableName, \" create result:\"), result);\n        console.log(\"\".concat(this.tableName, \" create error:\"), error);\n        if (error) {\n            console.error(\"Error creating \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return result;\n    }\n    static async update(id, data) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Updating \".concat(this.tableName, \" \").concat(id, \":\"), data);\n        const { data: result, error } = await supabase.from(this.tableName).update(data).eq(\"id\", id).select().single();\n        console.log(\"\".concat(this.tableName, \" update result:\"), result);\n        console.log(\"\".concat(this.tableName, \" update error:\"), error);\n        if (error) {\n            console.error(\"Error updating \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return result;\n    }\n    static async delete(id) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Deleting \".concat(this.tableName, \" \").concat(id));\n        const { error } = await supabase.from(this.tableName).delete().eq(\"id\", id);\n        console.log(\"\".concat(this.tableName, \" delete error:\"), error);\n        if (error) {\n            console.error(\"Error deleting \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return true;\n    }\n    static async filter(filters) {\n        let orderBy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"id\";\n        if (!isSupabaseAvailable()) {\n            console.warn(\"Supabase not available for \".concat(this.tableName));\n            return [];\n        }\n        console.log(\"Filtering \".concat(this.tableName, \":\"), filters);\n        let query = supabase.from(this.tableName).select(\"*\");\n        Object.entries(filters).forEach((param)=>{\n            let [key, value] = param;\n            query = query.eq(key, value);\n        });\n        const { data, error } = await query.order(orderBy.startsWith(\"-\") ? orderBy.slice(1) : orderBy, {\n            ascending: !orderBy.startsWith(\"-\")\n        });\n        console.log(\"\".concat(this.tableName, \" filter result:\"), data);\n        console.log(\"\".concat(this.tableName, \" filter error:\"), error);\n        if (error) {\n            console.error(\"Error filtering \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return data || [];\n    }\n}\nBaseEntity.tableName = \"\";\nclass DeviceModel extends BaseEntity {\n    static async list() {\n        let orderBy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"-created_date\";\n        return super.list(orderBy);\n    }\n    static async filter(filters) {\n        let orderBy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"-created_date\";\n        return super.filter(filters, orderBy);\n    }\n}\nDeviceModel.tableName = \"device_models\";\nclass IOSVersion extends BaseEntity {\n}\nIOSVersion.tableName = \"ios_versions\";\nclass AppVersion extends BaseEntity {\n}\nAppVersion.tableName = \"app_versions\";\nclass Configuration extends BaseEntity {\n}\nConfiguration.tableName = \"configurations\";\nclass GenerationHistory extends BaseEntity {\n}\nGenerationHistory.tableName = \"generation_history\";\nclass BlacklistedUserAgent extends BaseEntity {\n}\nBlacklistedUserAgent.tableName = \"blacklisted_user_agents\";\nclass AndroidDeviceModel extends BaseEntity {\n}\nAndroidDeviceModel.tableName = \"android_device_models\";\nclass AndroidBuildNumber extends BaseEntity {\n}\nAndroidBuildNumber.tableName = \"android_build_numbers\";\nclass AndroidAppVersion extends BaseEntity {\n}\nAndroidAppVersion.tableName = \"android_app_versions\";\n// Instagram-specific database entity classes\nclass InstagramDeviceModel extends BaseEntity {\n}\nInstagramDeviceModel.tableName = \"instagram_device_models\";\nclass InstagramVersion extends BaseEntity {\n}\nInstagramVersion.tableName = \"instagram_versions\";\nclass ChromeVersion extends BaseEntity {\n}\nChromeVersion.tableName = \"chrome_versions\";\nclass ResolutionDpi extends BaseEntity {\n}\nResolutionDpi.tableName = \"resolution_dpis\";\nclass User extends BaseEntity {\n    static async me() {\n        // Check if we're on the client side\n        if (false) {}\n        // Check localStorage\n        const storedUser = localStorage.getItem(\"current_user\");\n        if (storedUser) {\n            try {\n                return JSON.parse(storedUser);\n            } catch (e) {\n                localStorage.removeItem(\"current_user\");\n            }\n        }\n        throw new Error(\"Not authenticated\");\n    }\n    static async loginWithEmail(email) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        try {\n            console.log(\"Attempting admin login with email:\", email);\n            // First check if user exists\n            const { data: existingUser, error: selectError } = await supabase.from(\"users\").select(\"*\").eq(\"email\", email).single();\n            console.log(\"Existing user:\", existingUser);\n            console.log(\"Select error:\", selectError);\n            if (existingUser) {\n                // User exists, store in localStorage (only on client side)\n                if (true) {\n                    localStorage.setItem(\"current_user\", JSON.stringify(existingUser));\n                }\n                return existingUser;\n            }\n            // User doesn't exist, create new admin user\n            if (selectError && selectError.code === \"PGRST116\") {\n                const newUserData = {\n                    email: email,\n                    is_approved: true\n                };\n                console.log(\"Creating new admin user:\", newUserData);\n                const { data: newUser, error: insertError } = await supabase.from(\"users\").insert(newUserData).select().single();\n                console.log(\"New admin user created:\", newUser);\n                console.log(\"Insert error:\", insertError);\n                if (insertError) {\n                    console.error(\"Insert error:\", insertError);\n                    throw new Error(\"Failed to create user: \".concat(insertError.message));\n                }\n                // Store new user in localStorage (only on client side)\n                if (true) {\n                    localStorage.setItem(\"current_user\", JSON.stringify(newUser));\n                }\n                return newUser;\n            }\n            throw selectError;\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    }\n    static async login() {\n        if (false) {}\n        const email = prompt(\"Enter your email for testing:\");\n        if (email && email.trim()) {\n            try {\n                const user = await this.loginWithEmail(email.trim());\n                alert(\"Login successful! Welcome \".concat(user.email));\n                window.location.reload();\n            } catch (error) {\n                console.error(\"Login failed:\", error);\n                alert(\"Login failed: \" + error.message);\n            }\n        }\n    }\n    static async logout() {\n        if (true) {\n            localStorage.removeItem(\"current_user\");\n            window.location.reload();\n        }\n    }\n    // Check if user is logged in\n    static async getCurrentUser() {\n        if (false) {}\n        const storedUser = localStorage.getItem(\"current_user\");\n        if (storedUser) {\n            try {\n                return JSON.parse(storedUser);\n            } catch (e) {\n                localStorage.removeItem(\"current_user\");\n            }\n        }\n        return null;\n    }\n}\nUser.tableName = \"users\";\n// Helper function to get a random element from an array\nfunction getRandomElement(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n// Example usage of the updated generateUserAgent function\nasync function generateUserAgent() {\n    const deviceScaling = [\n        \"1.00\",\n        \"2.00\",\n        \"3.00\"\n    ];\n    const iosVersionUA = \"15.0\";\n    const iosVersion = {\n        webkit_version: \"605.1.15\",\n        build_number: \"19A5365\",\n        version: \"15.0\"\n    };\n    const appVersion = {\n        version: \"324.0\",\n        build_number: \"123456789\",\n        fbrv: null\n    };\n    const device = {\n        model_name: \"iPhone 12\"\n    };\n    const language = \"en_US\";\n    let userAgent = \"\";\n    if (Math.random() < 0.5) {\n        userAgent = \"Mozilla/5.0 (iPhone; CPU iPhone OS \".concat(iosVersionUA, \" like Mac OS X) AppleWebKit/\").concat(iosVersion.webkit_version, \" (KHTML, like Gecko) Mobile/\").concat(iosVersion.build_number, \" [FBAN/FBIOS;FBAV/\").concat(appVersion.version, \";FBBV/\").concat(appVersion.build_number, \";FBDV/\").concat(device.model_name, \";FBMD/iPhone;FBSN/iOS;FBSV/\").concat(iosVersion.version, \";FBSS/2;FBID/phone;FBLC/\").concat(language, \"]\");\n    } else {\n        const fbss = getRandomElement(deviceScaling.map((s)=>s.replace(\".00\", \"\")));\n        const extra = Math.random() < 0.1 ? \";FBOP/80\" : \"\";\n        // Use FBRV from database or generate random\n        let fbrv = appVersion.fbrv;\n        if (!fbrv) {\n            // Fallback to random generation if no FBRV in database\n            fbrv = Math.floor(Math.random() * 999999) + 700000000;\n        } else {\n            // Handle partial FBRV completion\n            const fbrvStr = fbrv.toString();\n            if (fbrvStr.length < 9) {\n                // Complete partial FBRV with random numbers\n                const remainingDigits = 9 - fbrvStr.length;\n                const randomPart = Math.floor(Math.random() * Math.pow(10, remainingDigits)).toString().padStart(remainingDigits, \"0\");\n                fbrv = fbrvStr + randomPart;\n            }\n        }\n        const fbrv_part = extra ? \"\" : \";FBOP/5;FBRV/\".concat(fbrv);\n        const iabmv = Math.random() < 0.9 ? \";IABMV/1\" : \"\";\n        userAgent = \"Mozilla/5.0 (iPhone; CPU iPhone OS \".concat(iosVersionUA, \" like Mac OS X) \") + \"AppleWebKit/\".concat(iosVersion.webkit_version, \" (KHTML, like Gecko) Mobile/\").concat(iosVersion.build_number, \" \") + \"[FBAN/FBIOS;FBAV/\".concat(appVersion.version, \";FBBV/\").concat(appVersion.build_number, \";FBDV/\").concat(device.model_name, \";FBMD/iPhone;FBSN/iOS;\") + \"FBSV/\".concat(iosVersion.version, \";FBSS/\").concat(fbss, \";FBID/phone;FBLC/\").concat(language).concat(extra).concat(fbrv_part).concat(iabmv, \"]\");\n    }\n    console.log(\"Generated User Agent:\", userAgent);\n    return userAgent;\n}\n// AccessKey entity class for authentication system\nclass AccessKey extends BaseEntity {\n    static async authenticate(accessKey) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Authenticating with key:\", accessKey);\n        const { data: user, error } = await supabase.from(this.tableName).select(\"*\").eq(\"access_key\", accessKey).eq(\"is_active\", true).single();\n        if (error || !user) {\n            console.error(\"Authentication failed:\", error);\n            throw new Error(\"Invalid access key\");\n        }\n        if (user.expires_at && new Date(user.expires_at) < new Date()) {\n            throw new Error(\"Access key has expired\");\n        }\n        // Update last login\n        await this.update(user.id, {\n            last_login: new Date().toISOString()\n        });\n        console.log(\"Authentication successful:\", user);\n        return user;\n    }\n    // Get current authenticated user from localStorage\n    static getCurrentUser() {\n        if (false) {}\n        const storedUser = localStorage.getItem(\"authenticated_user\");\n        if (storedUser) {\n            try {\n                const user = JSON.parse(storedUser);\n                return user;\n            } catch (e) {\n                localStorage.removeItem(\"authenticated_user\");\n            }\n        }\n        return null;\n    }\n    static async validateCurrentUser() {\n        const currentUser = this.getCurrentUser();\n        if (!currentUser) return null;\n        try {\n            // Re-authenticate with database to get fresh data\n            const validatedUser = await this.authenticate(currentUser.access_key);\n            this.setCurrentUser(validatedUser);\n            return validatedUser;\n        } catch (error) {\n            // Key is invalid, deleted, or expired\n            this.logout();\n            return null;\n        }\n    }\n    // Store authenticated user\n    static setCurrentUser(user) {\n        if (true) {\n            localStorage.setItem(\"authenticated_user\", JSON.stringify(user));\n        }\n    }\n    // Logout user\n    static logout() {\n        if (true) {\n            localStorage.removeItem(\"authenticated_user\");\n            window.location.href = \"/login\";\n        }\n    }\n    static isAdmin(user) {\n        const currentUser = user || this.getCurrentUser();\n        return currentUser && currentUser.user_role === \"admin\";\n    }\n    static isUser(user) {\n        const currentUser = user || this.getCurrentUser();\n        return currentUser && currentUser.user_role === \"user\";\n    }\n    static canGenerate(user) {\n        const currentUser = user || this.getCurrentUser();\n        if (!currentUser) return false;\n        // Admin has unlimited generations\n        if (currentUser.user_role === \"admin\") return true;\n        // Check user limits\n        return (currentUser.used_generations || 0) < (currentUser.generation_limit || 0);\n    }\n    static getRemainingGenerations(user) {\n        const currentUser = user || this.getCurrentUser();\n        if (!currentUser) return 0;\n        // Admin has unlimited\n        if (currentUser.user_role === \"admin\") return \"Unlimited\";\n        const remaining = (currentUser.generation_limit || 0) - (currentUser.used_generations || 0);\n        return Math.max(0, remaining);\n    }\n    // Get remaining days for user\n    static getRemainingDays(user) {\n        const currentUser = user || this.getCurrentUser();\n        if (!(currentUser === null || currentUser === void 0 ? void 0 : currentUser.expires_at)) return \"Unlimited\";\n        const expiryDate = new Date(currentUser.expires_at);\n        const today = new Date();\n        const diffTime = expiryDate.getTime() - today.getTime();\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n        if (diffDays <= 0) return \"Expired\";\n        return \"\".concat(diffDays, \" days\");\n    }\n    static async incrementGeneration(accessKey) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        // First get current count, then increment it\n        const { data: currentUser, error: fetchError } = await supabase.from(this.tableName).select(\"used_generations\").eq(\"access_key\", accessKey).single();\n        if (fetchError) {\n            console.error(\"Error fetching current generation count:\", fetchError);\n            throw fetchError;\n        }\n        const newCount = (currentUser.used_generations || 0) + 1;\n        const { data, error } = await supabase.from(this.tableName).update({\n            used_generations: newCount,\n            updated_at: new Date().toISOString()\n        }).eq(\"access_key\", accessKey).select().single();\n        if (error) {\n            console.error(\"Error incrementing generation count:\", error);\n            throw error;\n        }\n        // Update localStorage with new count\n        if (true) {\n            const storedUser = localStorage.getItem(\"authenticated_user\");\n            if (storedUser) {\n                try {\n                    const user = JSON.parse(storedUser);\n                    user.used_generations = data.used_generations;\n                    localStorage.setItem(\"authenticated_user\", JSON.stringify(user));\n                } catch (e) {\n                    console.error(\"Error updating localStorage:\", e);\n                }\n            }\n        }\n        return data;\n    }\n}\nAccessKey.tableName = \"access_keys\";\nclass UserGeneration extends BaseEntity {\n    static async createGeneration(accessKey, userName, generatedData, platform) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        const generationData = {\n            access_key: accessKey,\n            user_name: userName,\n            generated_data: generatedData,\n            platform: platform,\n            created_at: new Date().toISOString()\n        };\n        return await this.create(generationData);\n    }\n    static async getUserHistory(accessKey) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n        if (!isSupabaseAvailable()) {\n            return [];\n        }\n        const { data, error } = await supabase.from(this.tableName).select(\"*\").eq(\"access_key\", accessKey).order(\"created_at\", {\n            ascending: false\n        }).limit(limit);\n        if (error) {\n            console.error(\"Error fetching user history:\", error);\n            return [];\n        }\n        return data || [];\n    }\n}\nUserGeneration.tableName = \"user_generations\";\nclass AdminNotice extends BaseEntity {\n    static async getActiveNotices(targetUser) {\n        if (!isSupabaseAvailable()) {\n            return [];\n        }\n        let query = supabase.from(this.tableName).select(\"*\").eq(\"is_active\", true);\n        // Get notices for specific user or global notices\n        if (targetUser) {\n            query = query.or(\"target_user.eq.\".concat(targetUser, \",target_user.is.null\"));\n        } else {\n            query = query.is(\"target_user\", null);\n        }\n        // Filter out expired notices\n        query = query.or(\"expires_at.is.null,expires_at.gt.\".concat(new Date().toISOString()));\n        const { data, error } = await query.order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching notices:\", error);\n            return [];\n        }\n        return data || [];\n    }\n    static async createNotice(title, message, targetUser, expiresAt) {\n        const noticeData = {\n            title,\n            message,\n            target_user: targetUser || null,\n            expires_at: expiresAt || null,\n            is_active: true,\n            created_at: new Date().toISOString()\n        };\n        return await this.create(noticeData);\n    }\n}\nAdminNotice.tableName = \"admin_notices\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDM0IzQyxZQUFZZ0QsYUFBYTtZQUN6QkcsV0FBVztZQUNYYixZQUFZLElBQUlyQyxPQUFPRSxXQUFXO1FBQ3BDO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQ25HLE1BQU0sQ0FBQ2lKO0lBQzNCO0FBQ0Y7QUExQ2FSLFlBQ0puSixZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9zdXBhYmFzZS50cz9jOTlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIlxuXG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCB8fCBcIlwiXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSB8fCBcIlwiXG5cbi8vIE9ubHkgY3JlYXRlIGNsaWVudCBpZiBib3RoIFVSTCBhbmQga2V5IGFyZSBhdmFpbGFibGVcbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9XG4gIHN1cGFiYXNlVXJsICYmIHN1cGFiYXNlQW5vbktleVxuICAgID8gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgICAgICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICA6IG51bGxcblxuZXhwb3J0IGNvbnN0IGlzU3VwYWJhc2VBdmFpbGFibGUgPSAoKSA9PiB7XG4gIHJldHVybiBzdXBhYmFzZSAhPT0gbnVsbCAmJiBzdXBhYmFzZVVybCAmJiBzdXBhYmFzZUFub25LZXlcbn1cblxuLy8gRGF0YWJhc2UgZW50aXR5IGNsYXNzZXNcbmV4cG9ydCBjbGFzcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiXCJcblxuICBzdGF0aWMgYXN5bmMgbGlzdChvcmRlckJ5ID0gXCJpZFwiKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgU3VwYWJhc2Ugbm90IGF2YWlsYWJsZSBmb3IgJHt0aGlzLnRhYmxlTmFtZX1gKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIGRhdGEgZnJvbSAke3RoaXMudGFibGVOYW1lfS4uLmApXG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSFcbiAgICAgIC5mcm9tKHRoaXMudGFibGVOYW1lKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5vcmRlcihvcmRlckJ5LnN0YXJ0c1dpdGgoXCItXCIpID8gb3JkZXJCeS5zbGljZSgxKSA6IG9yZGVyQnksIHtcbiAgICAgICAgYXNjZW5kaW5nOiAhb3JkZXJCeS5zdGFydHNXaXRoKFwiLVwiKSxcbiAgICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgJHt0aGlzLnRhYmxlTmFtZX0gZGF0YTpgLCBkYXRhKVxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMudGFibGVOYW1lfSBlcnJvcjpgLCBlcnJvcilcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgJHt0aGlzLnRhYmxlTmFtZX06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShkYXRhOiBhbnkpIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwYWJhc2Ugbm90IGF2YWlsYWJsZVwiKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyAke3RoaXMudGFibGVOYW1lfTpgLCBkYXRhKVxuXG4gICAgY29uc3QgeyBkYXRhOiByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSEuZnJvbSh0aGlzLnRhYmxlTmFtZSkuaW5zZXJ0KGRhdGEpLnNlbGVjdCgpLnNpbmdsZSgpXG5cbiAgICBjb25zb2xlLmxvZyhgJHt0aGlzLnRhYmxlTmFtZX0gY3JlYXRlIHJlc3VsdDpgLCByZXN1bHQpXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy50YWJsZU5hbWV9IGNyZWF0ZSBlcnJvcjpgLCBlcnJvcilcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgJHt0aGlzLnRhYmxlTmFtZX06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgdXBkYXRlKGlkOiBzdHJpbmcsIGRhdGE6IGFueSkge1xuICAgIGlmICghaXNTdXBhYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBhYmFzZSBub3QgYXZhaWxhYmxlXCIpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFVwZGF0aW5nICR7dGhpcy50YWJsZU5hbWV9ICR7aWR9OmAsIGRhdGEpXG5cbiAgICBjb25zdCB7IGRhdGE6IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlIS5mcm9tKHRoaXMudGFibGVOYW1lKS51cGRhdGUoZGF0YSkuZXEoXCJpZFwiLCBpZCkuc2VsZWN0KCkuc2luZ2xlKClcblxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMudGFibGVOYW1lfSB1cGRhdGUgcmVzdWx0OmAsIHJlc3VsdClcbiAgICBjb25zb2xlLmxvZyhgJHt0aGlzLnRhYmxlTmFtZX0gdXBkYXRlIGVycm9yOmAsIGVycm9yKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyAke3RoaXMudGFibGVOYW1lfTpgLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBkZWxldGUoaWQ6IHN0cmluZykge1xuICAgIGlmICghaXNTdXBhYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBhYmFzZSBub3QgYXZhaWxhYmxlXCIpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYERlbGV0aW5nICR7dGhpcy50YWJsZU5hbWV9ICR7aWR9YClcblxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlIS5mcm9tKHRoaXMudGFibGVOYW1lKS5kZWxldGUoKS5lcShcImlkXCIsIGlkKVxuXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy50YWJsZU5hbWV9IGRlbGV0ZSBlcnJvcjpgLCBlcnJvcilcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgJHt0aGlzLnRhYmxlTmFtZX06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZpbHRlcihmaWx0ZXJzOiBhbnksIG9yZGVyQnkgPSBcImlkXCIpIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgY29uc29sZS53YXJuKGBTdXBhYmFzZSBub3QgYXZhaWxhYmxlIGZvciAke3RoaXMudGFibGVOYW1lfWApXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgRmlsdGVyaW5nICR7dGhpcy50YWJsZU5hbWV9OmAsIGZpbHRlcnMpXG5cbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZSEuZnJvbSh0aGlzLnRhYmxlTmFtZSkuc2VsZWN0KFwiKlwiKVxuXG4gICAgT2JqZWN0LmVudHJpZXMoZmlsdGVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKGtleSwgdmFsdWUpXG4gICAgfSlcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5Lm9yZGVyKG9yZGVyQnkuc3RhcnRzV2l0aChcIi1cIikgPyBvcmRlckJ5LnNsaWNlKDEpIDogb3JkZXJCeSwge1xuICAgICAgYXNjZW5kaW5nOiAhb3JkZXJCeS5zdGFydHNXaXRoKFwiLVwiKSxcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy50YWJsZU5hbWV9IGZpbHRlciByZXN1bHQ6YCwgZGF0YSlcbiAgICBjb25zb2xlLmxvZyhgJHt0aGlzLnRhYmxlTmFtZX0gZmlsdGVyIGVycm9yOmAsIGVycm9yKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmaWx0ZXJpbmcgJHt0aGlzLnRhYmxlTmFtZX06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXZpY2VNb2RlbCBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJkZXZpY2VfbW9kZWxzXCJcblxuICBzdGF0aWMgYXN5bmMgbGlzdChvcmRlckJ5ID0gXCItY3JlYXRlZF9kYXRlXCIpIHtcbiAgICByZXR1cm4gc3VwZXIubGlzdChvcmRlckJ5KVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZpbHRlcihmaWx0ZXJzOiBhbnksIG9yZGVyQnkgPSBcIi1jcmVhdGVkX2RhdGVcIikge1xuICAgIHJldHVybiBzdXBlci5maWx0ZXIoZmlsdGVycywgb3JkZXJCeSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSU9TVmVyc2lvbiBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJpb3NfdmVyc2lvbnNcIlxufVxuXG5leHBvcnQgY2xhc3MgQXBwVmVyc2lvbiBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJhcHBfdmVyc2lvbnNcIlxufVxuXG5leHBvcnQgY2xhc3MgQ29uZmlndXJhdGlvbiBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJjb25maWd1cmF0aW9uc1wiXG59XG5cbmV4cG9ydCBjbGFzcyBHZW5lcmF0aW9uSGlzdG9yeSBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJnZW5lcmF0aW9uX2hpc3RvcnlcIlxufVxuXG5leHBvcnQgY2xhc3MgQmxhY2tsaXN0ZWRVc2VyQWdlbnQgZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiYmxhY2tsaXN0ZWRfdXNlcl9hZ2VudHNcIlxufVxuXG5leHBvcnQgY2xhc3MgQW5kcm9pZERldmljZU1vZGVsIGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImFuZHJvaWRfZGV2aWNlX21vZGVsc1wiXG59XG5cbmV4cG9ydCBjbGFzcyBBbmRyb2lkQnVpbGROdW1iZXIgZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiYW5kcm9pZF9idWlsZF9udW1iZXJzXCJcbn1cblxuZXhwb3J0IGNsYXNzIEFuZHJvaWRBcHBWZXJzaW9uIGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImFuZHJvaWRfYXBwX3ZlcnNpb25zXCJcbn1cblxuLy8gSW5zdGFncmFtLXNwZWNpZmljIGRhdGFiYXNlIGVudGl0eSBjbGFzc2VzXG5leHBvcnQgY2xhc3MgSW5zdGFncmFtRGV2aWNlTW9kZWwgZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiaW5zdGFncmFtX2RldmljZV9tb2RlbHNcIlxufVxuXG5leHBvcnQgY2xhc3MgSW5zdGFncmFtVmVyc2lvbiBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJpbnN0YWdyYW1fdmVyc2lvbnNcIlxufVxuXG5leHBvcnQgY2xhc3MgQ2hyb21lVmVyc2lvbiBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJjaHJvbWVfdmVyc2lvbnNcIlxufVxuXG5leHBvcnQgY2xhc3MgUmVzb2x1dGlvbkRwaSBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJyZXNvbHV0aW9uX2RwaXNcIlxufVxuXG5leHBvcnQgY2xhc3MgVXNlciBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJ1c2Vyc1wiXG5cbiAgc3RhdGljIGFzeW5jIG1lKCkge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9uIHRoZSBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYXV0aGVudGljYXRlZFwiKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGxvY2FsU3RvcmFnZVxuICAgIGNvbnN0IHN0b3JlZFVzZXIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImN1cnJlbnRfdXNlclwiKVxuICAgIGlmIChzdG9yZWRVc2VyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWRVc2VyKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImN1cnJlbnRfdXNlclwiKVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYXV0aGVudGljYXRlZFwiKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGxvZ2luV2l0aEVtYWlsKGVtYWlsOiBzdHJpbmcpIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwYWJhc2Ugbm90IGF2YWlsYWJsZVwiKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkF0dGVtcHRpbmcgYWRtaW4gbG9naW4gd2l0aCBlbWFpbDpcIiwgZW1haWwpXG5cbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHVzZXIgZXhpc3RzXG4gICAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nVXNlciwgZXJyb3I6IHNlbGVjdEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSFcbiAgICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxuICAgICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgICAuZXEoXCJlbWFpbFwiLCBlbWFpbClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGNvbnNvbGUubG9nKFwiRXhpc3RpbmcgdXNlcjpcIiwgZXhpc3RpbmdVc2VyKVxuICAgICAgY29uc29sZS5sb2coXCJTZWxlY3QgZXJyb3I6XCIsIHNlbGVjdEVycm9yKVxuXG4gICAgICBpZiAoZXhpc3RpbmdVc2VyKSB7XG4gICAgICAgIC8vIFVzZXIgZXhpc3RzLCBzdG9yZSBpbiBsb2NhbFN0b3JhZ2UgKG9ubHkgb24gY2xpZW50IHNpZGUpXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJjdXJyZW50X3VzZXJcIiwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdVc2VyKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhpc3RpbmdVc2VyXG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgZG9lc24ndCBleGlzdCwgY3JlYXRlIG5ldyBhZG1pbiB1c2VyXG4gICAgICBpZiAoc2VsZWN0RXJyb3IgJiYgc2VsZWN0RXJyb3IuY29kZSA9PT0gXCJQR1JTVDExNlwiKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJEYXRhID0ge1xuICAgICAgICAgIGVtYWlsOiBlbWFpbCxcbiAgICAgICAgICBpc19hcHByb3ZlZDogdHJ1ZSwgLy8gQWxsIHVzZXJzIGFyZSBhZG1pbiBhbmQgYXBwcm92ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgbmV3IGFkbWluIHVzZXI6XCIsIG5ld1VzZXJEYXRhKVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YTogbmV3VXNlciwgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSFcbiAgICAgICAgICAuZnJvbShcInVzZXJzXCIpXG4gICAgICAgICAgLmluc2VydChuZXdVc2VyRGF0YSlcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAuc2luZ2xlKClcblxuICAgICAgICBjb25zb2xlLmxvZyhcIk5ldyBhZG1pbiB1c2VyIGNyZWF0ZWQ6XCIsIG5ld1VzZXIpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5zZXJ0IGVycm9yOlwiLCBpbnNlcnRFcnJvcilcblxuICAgICAgICBpZiAoaW5zZXJ0RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW5zZXJ0IGVycm9yOlwiLCBpbnNlcnRFcnJvcilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdXNlcjogJHtpbnNlcnRFcnJvci5tZXNzYWdlfWApXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBuZXcgdXNlciBpbiBsb2NhbFN0b3JhZ2UgKG9ubHkgb24gY2xpZW50IHNpZGUpXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJjdXJyZW50X3VzZXJcIiwgSlNPTi5zdHJpbmdpZnkobmV3VXNlcikpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1VzZXJcbiAgICAgIH1cblxuICAgICAgdGhyb3cgc2VsZWN0RXJyb3JcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkxvZ2luIGVycm9yOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGxvZ2luKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICAgIGNvbnN0IGVtYWlsID0gcHJvbXB0KFwiRW50ZXIgeW91ciBlbWFpbCBmb3IgdGVzdGluZzpcIilcbiAgICBpZiAoZW1haWwgJiYgZW1haWwudHJpbSgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5sb2dpbldpdGhFbWFpbChlbWFpbC50cmltKCkpXG4gICAgICAgIGFsZXJ0KGBMb2dpbiBzdWNjZXNzZnVsISBXZWxjb21lICR7dXNlci5lbWFpbH1gKVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJMb2dpbiBmYWlsZWQ6XCIsIGVycm9yKVxuICAgICAgICBhbGVydChcIkxvZ2luIGZhaWxlZDogXCIgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBsb2dvdXQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiY3VycmVudF91c2VyXCIpXG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiB1c2VyIGlzIGxvZ2dlZCBpblxuICBzdGF0aWMgYXN5bmMgZ2V0Q3VycmVudFVzZXIoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmVkVXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiY3VycmVudF91c2VyXCIpXG4gICAgaWYgKHN0b3JlZFVzZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0b3JlZFVzZXIpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiY3VycmVudF91c2VyXCIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIHJhbmRvbSBlbGVtZW50IGZyb20gYW4gYXJyYXlcbmZ1bmN0aW9uIGdldFJhbmRvbUVsZW1lbnQoYXJyOiBhbnlbXSkge1xuICByZXR1cm4gYXJyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpXVxufVxuXG4vLyBFeGFtcGxlIHVzYWdlIG9mIHRoZSB1cGRhdGVkIGdlbmVyYXRlVXNlckFnZW50IGZ1bmN0aW9uXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVVzZXJBZ2VudCgpIHtcbiAgY29uc3QgZGV2aWNlU2NhbGluZyA9IFtcIjEuMDBcIiwgXCIyLjAwXCIsIFwiMy4wMFwiXVxuICBjb25zdCBpb3NWZXJzaW9uVUEgPSBcIjE1LjBcIlxuICBjb25zdCBpb3NWZXJzaW9uID0ge1xuICAgIHdlYmtpdF92ZXJzaW9uOiBcIjYwNS4xLjE1XCIsXG4gICAgYnVpbGRfbnVtYmVyOiBcIjE5QTUzNjVcIixcbiAgICB2ZXJzaW9uOiBcIjE1LjBcIixcbiAgfVxuICBjb25zdCBhcHBWZXJzaW9uID0ge1xuICAgIHZlcnNpb246IFwiMzI0LjBcIixcbiAgICBidWlsZF9udW1iZXI6IFwiMTIzNDU2Nzg5XCIsXG4gICAgZmJydjogbnVsbCwgLy8gVGhpcyBzaG91bGQgYmUgZmV0Y2hlZCBmcm9tIHRoZSBkYXRhYmFzZVxuICB9XG4gIGNvbnN0IGRldmljZSA9IHtcbiAgICBtb2RlbF9uYW1lOiBcImlQaG9uZSAxMlwiLFxuICB9XG4gIGNvbnN0IGxhbmd1YWdlID0gXCJlbl9VU1wiXG5cbiAgbGV0IHVzZXJBZ2VudCA9IFwiXCJcblxuICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuNSkge1xuICAgIHVzZXJBZ2VudCA9IGBNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TICR7aW9zVmVyc2lvblVBfSBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC8ke2lvc1ZlcnNpb24ud2Via2l0X3ZlcnNpb259IChLSFRNTCwgbGlrZSBHZWNrbykgTW9iaWxlLyR7aW9zVmVyc2lvbi5idWlsZF9udW1iZXJ9IFtGQkFOL0ZCSU9TO0ZCQVYvJHthcHBWZXJzaW9uLnZlcnNpb259O0ZCQlYvJHthcHBWZXJzaW9uLmJ1aWxkX251bWJlcn07RkJEVi8ke2RldmljZS5tb2RlbF9uYW1lfTtGQk1EL2lQaG9uZTtGQlNOL2lPUztGQlNWLyR7aW9zVmVyc2lvbi52ZXJzaW9ufTtGQlNTLzI7RkJJRC9waG9uZTtGQkxDLyR7bGFuZ3VhZ2V9XWBcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmYnNzID0gZ2V0UmFuZG9tRWxlbWVudChkZXZpY2VTY2FsaW5nLm1hcCgocykgPT4gcy5yZXBsYWNlKFwiLjAwXCIsIFwiXCIpKSlcbiAgICBjb25zdCBleHRyYSA9IE1hdGgucmFuZG9tKCkgPCAwLjEgPyBcIjtGQk9QLzgwXCIgOiBcIlwiXG5cbiAgICAvLyBVc2UgRkJSViBmcm9tIGRhdGFiYXNlIG9yIGdlbmVyYXRlIHJhbmRvbVxuICAgIGxldCBmYnJ2ID0gYXBwVmVyc2lvbi5mYnJ2XG4gICAgaWYgKCFmYnJ2KSB7XG4gICAgICAvLyBGYWxsYmFjayB0byByYW5kb20gZ2VuZXJhdGlvbiBpZiBubyBGQlJWIGluIGRhdGFiYXNlXG4gICAgICBmYnJ2ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5OTk5KSArIDcwMDAwMDAwMFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgcGFydGlhbCBGQlJWIGNvbXBsZXRpb25cbiAgICAgIGNvbnN0IGZicnZTdHIgPSBmYnJ2LnRvU3RyaW5nKClcbiAgICAgIGlmIChmYnJ2U3RyLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgLy8gQ29tcGxldGUgcGFydGlhbCBGQlJWIHdpdGggcmFuZG9tIG51bWJlcnNcbiAgICAgICAgY29uc3QgcmVtYWluaW5nRGlnaXRzID0gOSAtIGZicnZTdHIubGVuZ3RoXG4gICAgICAgIGNvbnN0IHJhbmRvbVBhcnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygxMCwgcmVtYWluaW5nRGlnaXRzKSlcbiAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgIC5wYWRTdGFydChyZW1haW5pbmdEaWdpdHMsIFwiMFwiKVxuICAgICAgICBmYnJ2ID0gZmJydlN0ciArIHJhbmRvbVBhcnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmYnJ2X3BhcnQgPSBleHRyYSA/IFwiXCIgOiBgO0ZCT1AvNTtGQlJWLyR7ZmJydn1gXG4gICAgY29uc3QgaWFibXYgPSBNYXRoLnJhbmRvbSgpIDwgMC45ID8gXCI7SUFCTVYvMVwiIDogXCJcIlxuXG4gICAgdXNlckFnZW50ID1cbiAgICAgIGBNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TICR7aW9zVmVyc2lvblVBfSBsaWtlIE1hYyBPUyBYKSBgICtcbiAgICAgIGBBcHBsZVdlYktpdC8ke2lvc1ZlcnNpb24ud2Via2l0X3ZlcnNpb259IChLSFRNTCwgbGlrZSBHZWNrbykgTW9iaWxlLyR7aW9zVmVyc2lvbi5idWlsZF9udW1iZXJ9IGAgK1xuICAgICAgYFtGQkFOL0ZCSU9TO0ZCQVYvJHthcHBWZXJzaW9uLnZlcnNpb259O0ZCQlYvJHthcHBWZXJzaW9uLmJ1aWxkX251bWJlcn07RkJEVi8ke2RldmljZS5tb2RlbF9uYW1lfTtGQk1EL2lQaG9uZTtGQlNOL2lPUztgICtcbiAgICAgIGBGQlNWLyR7aW9zVmVyc2lvbi52ZXJzaW9ufTtGQlNTLyR7ZmJzc307RkJJRC9waG9uZTtGQkxDLyR7bGFuZ3VhZ2V9JHtleHRyYX0ke2ZicnZfcGFydH0ke2lhYm12fV1gXG4gIH1cblxuICBjb25zb2xlLmxvZyhcIkdlbmVyYXRlZCBVc2VyIEFnZW50OlwiLCB1c2VyQWdlbnQpXG4gIHJldHVybiB1c2VyQWdlbnRcbn1cblxuLy8gQWNjZXNzS2V5IGVudGl0eSBjbGFzcyBmb3IgYXV0aGVudGljYXRpb24gc3lzdGVtXG5leHBvcnQgY2xhc3MgQWNjZXNzS2V5IGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImFjY2Vzc19rZXlzXCJcblxuICBzdGF0aWMgYXN5bmMgYXV0aGVudGljYXRlKGFjY2Vzc0tleTogc3RyaW5nKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cGFiYXNlIG5vdCBhdmFpbGFibGVcIilcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIkF1dGhlbnRpY2F0aW5nIHdpdGgga2V5OlwiLCBhY2Nlc3NLZXkpXG5cbiAgICBjb25zdCB7IGRhdGE6IHVzZXIsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSFcbiAgICAgIC5mcm9tKHRoaXMudGFibGVOYW1lKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImFjY2Vzc19rZXlcIiwgYWNjZXNzS2V5KVxuICAgICAgLmVxKFwiaXNfYWN0aXZlXCIsIHRydWUpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChlcnJvciB8fCAhdXNlcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZDpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFjY2VzcyBrZXlcIilcbiAgICB9XG5cbiAgICBpZiAodXNlci5leHBpcmVzX2F0ICYmIG5ldyBEYXRlKHVzZXIuZXhwaXJlc19hdCkgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2Nlc3Mga2V5IGhhcyBleHBpcmVkXCIpXG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGxhc3QgbG9naW5cbiAgICBhd2FpdCB0aGlzLnVwZGF0ZSh1c2VyLmlkLCB7IGxhc3RfbG9naW46IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxuXG4gICAgY29uc29sZS5sb2coXCJBdXRoZW50aWNhdGlvbiBzdWNjZXNzZnVsOlwiLCB1c2VyKVxuICAgIHJldHVybiB1c2VyXG4gIH1cblxuICAvLyBHZXQgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXIgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgc3RhdGljIGdldEN1cnJlbnRVc2VyKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3Qgc3RvcmVkVXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYXV0aGVudGljYXRlZF91c2VyXCIpXG4gICAgaWYgKHN0b3JlZFVzZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBKU09OLnBhcnNlKHN0b3JlZFVzZXIpXG4gICAgICAgIHJldHVybiB1c2VyXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiYXV0aGVudGljYXRlZF91c2VyXCIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgdmFsaWRhdGVDdXJyZW50VXNlcigpIHtcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHRoaXMuZ2V0Q3VycmVudFVzZXIoKVxuICAgIGlmICghY3VycmVudFVzZXIpIHJldHVybiBudWxsXG5cbiAgICB0cnkge1xuICAgICAgLy8gUmUtYXV0aGVudGljYXRlIHdpdGggZGF0YWJhc2UgdG8gZ2V0IGZyZXNoIGRhdGFcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFVzZXIgPSBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0ZShjdXJyZW50VXNlci5hY2Nlc3Nfa2V5KVxuICAgICAgdGhpcy5zZXRDdXJyZW50VXNlcih2YWxpZGF0ZWRVc2VyKVxuICAgICAgcmV0dXJuIHZhbGlkYXRlZFVzZXJcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gS2V5IGlzIGludmFsaWQsIGRlbGV0ZWQsIG9yIGV4cGlyZWRcbiAgICAgIHRoaXMubG9nb3V0KClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gU3RvcmUgYXV0aGVudGljYXRlZCB1c2VyXG4gIHN0YXRpYyBzZXRDdXJyZW50VXNlcih1c2VyOiBhbnkpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJhdXRoZW50aWNhdGVkX3VzZXJcIiwgSlNPTi5zdHJpbmdpZnkodXNlcikpXG4gICAgfVxuICB9XG5cbiAgLy8gTG9nb3V0IHVzZXJcbiAgc3RhdGljIGxvZ291dCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJhdXRoZW50aWNhdGVkX3VzZXJcIilcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCIvbG9naW5cIlxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpc0FkbWluKHVzZXI/OiBhbnkpIHtcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHVzZXIgfHwgdGhpcy5nZXRDdXJyZW50VXNlcigpXG4gICAgcmV0dXJuIGN1cnJlbnRVc2VyICYmIGN1cnJlbnRVc2VyLnVzZXJfcm9sZSA9PT0gXCJhZG1pblwiXG4gIH1cblxuICBzdGF0aWMgaXNVc2VyKHVzZXI/OiBhbnkpIHtcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHVzZXIgfHwgdGhpcy5nZXRDdXJyZW50VXNlcigpXG4gICAgcmV0dXJuIGN1cnJlbnRVc2VyICYmIGN1cnJlbnRVc2VyLnVzZXJfcm9sZSA9PT0gXCJ1c2VyXCJcbiAgfVxuXG4gIHN0YXRpYyBjYW5HZW5lcmF0ZSh1c2VyPzogYW55KSB7XG4gICAgY29uc3QgY3VycmVudFVzZXIgPSB1c2VyIHx8IHRoaXMuZ2V0Q3VycmVudFVzZXIoKVxuICAgIGlmICghY3VycmVudFVzZXIpIHJldHVybiBmYWxzZVxuXG4gICAgLy8gQWRtaW4gaGFzIHVubGltaXRlZCBnZW5lcmF0aW9uc1xuICAgIGlmIChjdXJyZW50VXNlci51c2VyX3JvbGUgPT09IFwiYWRtaW5cIikgcmV0dXJuIHRydWVcblxuICAgIC8vIENoZWNrIHVzZXIgbGltaXRzXG4gICAgcmV0dXJuIChjdXJyZW50VXNlci51c2VkX2dlbmVyYXRpb25zIHx8IDApIDwgKGN1cnJlbnRVc2VyLmdlbmVyYXRpb25fbGltaXQgfHwgMClcbiAgfVxuXG4gIHN0YXRpYyBnZXRSZW1haW5pbmdHZW5lcmF0aW9ucyh1c2VyPzogYW55KSB7XG4gICAgY29uc3QgY3VycmVudFVzZXIgPSB1c2VyIHx8IHRoaXMuZ2V0Q3VycmVudFVzZXIoKVxuICAgIGlmICghY3VycmVudFVzZXIpIHJldHVybiAwXG5cbiAgICAvLyBBZG1pbiBoYXMgdW5saW1pdGVkXG4gICAgaWYgKGN1cnJlbnRVc2VyLnVzZXJfcm9sZSA9PT0gXCJhZG1pblwiKSByZXR1cm4gXCJVbmxpbWl0ZWRcIlxuXG4gICAgY29uc3QgcmVtYWluaW5nID0gKGN1cnJlbnRVc2VyLmdlbmVyYXRpb25fbGltaXQgfHwgMCkgLSAoY3VycmVudFVzZXIudXNlZF9nZW5lcmF0aW9ucyB8fCAwKVxuICAgIHJldHVybiBNYXRoLm1heCgwLCByZW1haW5pbmcpXG4gIH1cblxuICAvLyBHZXQgcmVtYWluaW5nIGRheXMgZm9yIHVzZXJcbiAgc3RhdGljIGdldFJlbWFpbmluZ0RheXModXNlcj86IGFueSkge1xuICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gdXNlciB8fCB0aGlzLmdldEN1cnJlbnRVc2VyKClcbiAgICBpZiAoIWN1cnJlbnRVc2VyPy5leHBpcmVzX2F0KSByZXR1cm4gXCJVbmxpbWl0ZWRcIlxuXG4gICAgY29uc3QgZXhwaXJ5RGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnRVc2VyLmV4cGlyZXNfYXQpXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgZGlmZlRpbWUgPSBleHBpcnlEYXRlLmdldFRpbWUoKSAtIHRvZGF5LmdldFRpbWUoKVxuICAgIGNvbnN0IGRpZmZEYXlzID0gTWF0aC5jZWlsKGRpZmZUaW1lIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKVxuXG4gICAgaWYgKGRpZmZEYXlzIDw9IDApIHJldHVybiBcIkV4cGlyZWRcIlxuICAgIHJldHVybiBgJHtkaWZmRGF5c30gZGF5c2BcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBpbmNyZW1lbnRHZW5lcmF0aW9uKGFjY2Vzc0tleTogc3RyaW5nKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cGFiYXNlIG5vdCBhdmFpbGFibGVcIilcbiAgICB9XG5cbiAgICAvLyBGaXJzdCBnZXQgY3VycmVudCBjb3VudCwgdGhlbiBpbmNyZW1lbnQgaXRcbiAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnRVc2VyLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UhXG4gICAgICAuZnJvbSh0aGlzLnRhYmxlTmFtZSlcbiAgICAgIC5zZWxlY3QoXCJ1c2VkX2dlbmVyYXRpb25zXCIpXG4gICAgICAuZXEoXCJhY2Nlc3Nfa2V5XCIsIGFjY2Vzc0tleSlcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGZldGNoRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBjdXJyZW50IGdlbmVyYXRpb24gY291bnQ6XCIsIGZldGNoRXJyb3IpXG4gICAgICB0aHJvdyBmZXRjaEVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgbmV3Q291bnQgPSAoY3VycmVudFVzZXIudXNlZF9nZW5lcmF0aW9ucyB8fCAwKSArIDFcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlIVxuICAgICAgLmZyb20odGhpcy50YWJsZU5hbWUpXG4gICAgICAudXBkYXRlKHtcbiAgICAgICAgdXNlZF9nZW5lcmF0aW9uczogbmV3Q291bnQsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pXG4gICAgICAuZXEoXCJhY2Nlc3Nfa2V5XCIsIGFjY2Vzc0tleSlcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbmNyZW1lbnRpbmcgZ2VuZXJhdGlvbiBjb3VudDpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBsb2NhbFN0b3JhZ2Ugd2l0aCBuZXcgY291bnRcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYXV0aGVudGljYXRlZF91c2VyXCIpXG4gICAgICBpZiAoc3RvcmVkVXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSBKU09OLnBhcnNlKHN0b3JlZFVzZXIpXG4gICAgICAgICAgdXNlci51c2VkX2dlbmVyYXRpb25zID0gZGF0YS51c2VkX2dlbmVyYXRpb25zXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJhdXRoZW50aWNhdGVkX3VzZXJcIiwgSlNPTi5zdHJpbmdpZnkodXNlcikpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgbG9jYWxTdG9yYWdlOlwiLCBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXNlckdlbmVyYXRpb24gZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwidXNlcl9nZW5lcmF0aW9uc1wiXG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUdlbmVyYXRpb24oYWNjZXNzS2V5OiBzdHJpbmcsIHVzZXJOYW1lOiBzdHJpbmcsIGdlbmVyYXRlZERhdGE6IGFueSwgcGxhdGZvcm06IHN0cmluZykge1xuICAgIGlmICghaXNTdXBhYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBhYmFzZSBub3QgYXZhaWxhYmxlXCIpXG4gICAgfVxuXG4gICAgY29uc3QgZ2VuZXJhdGlvbkRhdGEgPSB7XG4gICAgICBhY2Nlc3Nfa2V5OiBhY2Nlc3NLZXksXG4gICAgICB1c2VyX25hbWU6IHVzZXJOYW1lLFxuICAgICAgZ2VuZXJhdGVkX2RhdGE6IGdlbmVyYXRlZERhdGEsXG4gICAgICBwbGF0Zm9ybTogcGxhdGZvcm0sXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlKGdlbmVyYXRpb25EYXRhKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGdldFVzZXJIaXN0b3J5KGFjY2Vzc0tleTogc3RyaW5nLCBsaW1pdCA9IDUwKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlIVxuICAgICAgLmZyb20odGhpcy50YWJsZU5hbWUpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiYWNjZXNzX2tleVwiLCBhY2Nlc3NLZXkpXG4gICAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgLmxpbWl0KGxpbWl0KVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBoaXN0b3J5OlwiLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFkbWluTm90aWNlIGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImFkbWluX25vdGljZXNcIlxuXG4gIHN0YXRpYyBhc3luYyBnZXRBY3RpdmVOb3RpY2VzKHRhcmdldFVzZXI/OiBzdHJpbmcpIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2UhLmZyb20odGhpcy50YWJsZU5hbWUpLnNlbGVjdChcIipcIikuZXEoXCJpc19hY3RpdmVcIiwgdHJ1ZSlcblxuICAgIC8vIEdldCBub3RpY2VzIGZvciBzcGVjaWZpYyB1c2VyIG9yIGdsb2JhbCBub3RpY2VzXG4gICAgaWYgKHRhcmdldFVzZXIpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkub3IoYHRhcmdldF91c2VyLmVxLiR7dGFyZ2V0VXNlcn0sdGFyZ2V0X3VzZXIuaXMubnVsbGApXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuaXMoXCJ0YXJnZXRfdXNlclwiLCBudWxsKVxuICAgIH1cblxuICAgIC8vIEZpbHRlciBvdXQgZXhwaXJlZCBub3RpY2VzXG4gICAgcXVlcnkgPSBxdWVyeS5vcihgZXhwaXJlc19hdC5pcy5udWxsLGV4cGlyZXNfYXQuZ3QuJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YClcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5Lm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIG5vdGljZXM6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVOb3RpY2UodGl0bGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCB0YXJnZXRVc2VyPzogc3RyaW5nLCBleHBpcmVzQXQ/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBub3RpY2VEYXRhID0ge1xuICAgICAgdGl0bGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgdGFyZ2V0X3VzZXI6IHRhcmdldFVzZXIgfHwgbnVsbCxcbiAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCB8fCBudWxsLFxuICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZShub3RpY2VEYXRhKVxuICB9XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsImF1dGgiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJpc1N1cGFiYXNlQXZhaWxhYmxlIiwiQmFzZUVudGl0eSIsImxpc3QiLCJvcmRlckJ5IiwiY29uc29sZSIsIndhcm4iLCJ0YWJsZU5hbWUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJhc2NlbmRpbmciLCJjcmVhdGUiLCJFcnJvciIsInJlc3VsdCIsImluc2VydCIsInNpbmdsZSIsInVwZGF0ZSIsImlkIiwiZXEiLCJkZWxldGUiLCJmaWx0ZXIiLCJmaWx0ZXJzIiwicXVlcnkiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwiRGV2aWNlTW9kZWwiLCJJT1NWZXJzaW9uIiwiQXBwVmVyc2lvbiIsIkNvbmZpZ3VyYXRpb24iLCJHZW5lcmF0aW9uSGlzdG9yeSIsIkJsYWNrbGlzdGVkVXNlckFnZW50IiwiQW5kcm9pZERldmljZU1vZGVsIiwiQW5kcm9pZEJ1aWxkTnVtYmVyIiwiQW5kcm9pZEFwcFZlcnNpb24iLCJJbnN0YWdyYW1EZXZpY2VNb2RlbCIsIkluc3RhZ3JhbVZlcnNpb24iLCJDaHJvbWVWZXJzaW9uIiwiUmVzb2x1dGlvbkRwaSIsIlVzZXIiLCJtZSIsInN0b3JlZFVzZXIiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZSIsInJlbW92ZUl0ZW0iLCJsb2dpbldpdGhFbWFpbCIsImVtYWlsIiwiZXhpc3RpbmdVc2VyIiwic2VsZWN0RXJyb3IiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiY29kZSIsIm5ld1VzZXJEYXRhIiwiaXNfYXBwcm92ZWQiLCJuZXdVc2VyIiwiaW5zZXJ0RXJyb3IiLCJtZXNzYWdlIiwibG9naW4iLCJwcm9tcHQiLCJ0cmltIiwidXNlciIsImFsZXJ0Iiwid2luZG93IiwibG9jYXRpb24iLCJyZWxvYWQiLCJsb2dvdXQiLCJnZXRDdXJyZW50VXNlciIsImdldFJhbmRvbUVsZW1lbnQiLCJhcnIiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJnZW5lcmF0ZVVzZXJBZ2VudCIsImRldmljZVNjYWxpbmciLCJpb3NWZXJzaW9uVUEiLCJpb3NWZXJzaW9uIiwid2Via2l0X3ZlcnNpb24iLCJidWlsZF9udW1iZXIiLCJ2ZXJzaW9uIiwiYXBwVmVyc2lvbiIsImZicnYiLCJkZXZpY2UiLCJtb2RlbF9uYW1lIiwibGFuZ3VhZ2UiLCJ1c2VyQWdlbnQiLCJmYnNzIiwibWFwIiwicyIsInJlcGxhY2UiLCJleHRyYSIsImZicnZTdHIiLCJ0b1N0cmluZyIsInJlbWFpbmluZ0RpZ2l0cyIsInJhbmRvbVBhcnQiLCJwb3ciLCJwYWRTdGFydCIsImZicnZfcGFydCIsImlhYm12IiwiQWNjZXNzS2V5IiwiYXV0aGVudGljYXRlIiwiYWNjZXNzS2V5IiwiZXhwaXJlc19hdCIsIkRhdGUiLCJsYXN0X2xvZ2luIiwidG9JU09TdHJpbmciLCJ2YWxpZGF0ZUN1cnJlbnRVc2VyIiwiY3VycmVudFVzZXIiLCJ2YWxpZGF0ZWRVc2VyIiwiYWNjZXNzX2tleSIsInNldEN1cnJlbnRVc2VyIiwiaHJlZiIsImlzQWRtaW4iLCJ1c2VyX3JvbGUiLCJpc1VzZXIiLCJjYW5HZW5lcmF0ZSIsInVzZWRfZ2VuZXJhdGlvbnMiLCJnZW5lcmF0aW9uX2xpbWl0IiwiZ2V0UmVtYWluaW5nR2VuZXJhdGlvbnMiLCJyZW1haW5pbmciLCJtYXgiLCJnZXRSZW1haW5pbmdEYXlzIiwiZXhwaXJ5RGF0ZSIsInRvZGF5IiwiZGlmZlRpbWUiLCJnZXRUaW1lIiwiZGlmZkRheXMiLCJjZWlsIiwiaW5jcmVtZW50R2VuZXJhdGlvbiIsImZldGNoRXJyb3IiLCJuZXdDb3VudCIsInVwZGF0ZWRfYXQiLCJVc2VyR2VuZXJhdGlvbiIsImNyZWF0ZUdlbmVyYXRpb24iLCJ1c2VyTmFtZSIsImdlbmVyYXRlZERhdGEiLCJwbGF0Zm9ybSIsImdlbmVyYXRpb25EYXRhIiwidXNlcl9uYW1lIiwiZ2VuZXJhdGVkX2RhdGEiLCJjcmVhdGVkX2F0IiwiZ2V0VXNlckhpc3RvcnkiLCJsaW1pdCIsIkFkbWluTm90aWNlIiwiZ2V0QWN0aXZlTm90aWNlcyIsInRhcmdldFVzZXIiLCJvciIsImlzIiwiY3JlYXRlTm90aWNlIiwidGl0bGUiLCJleHBpcmVzQXQiLCJub3RpY2VEYXRhIiwidGFyZ2V0X3VzZXIiLCJpc19hY3RpdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3023\n"));

/***/ }),

/***/ 3622:
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cn: function() { return /* binding */ cn; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ 8099);\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ 8543);\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYyMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDSjtBQUVqQyxTQUFTRTtJQUFHO1FBQUdDLE9BQUgsdUJBQXVCOztJQUN4QyxPQUFPRix1REFBT0EsQ0FBQ0QsMENBQUlBLENBQUNHO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi91dGlscy50cz9mNzQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR5cGUgQ2xhc3NWYWx1ZSwgY2xzeCB9IGZyb20gXCJjbHN4XCJcbmltcG9ydCB7IHR3TWVyZ2UgfSBmcm9tIFwidGFpbHdpbmQtbWVyZ2VcIlxuXG5leHBvcnQgZnVuY3Rpb24gY24oLi4uaW5wdXRzOiBDbGFzc1ZhbHVlW10pIHtcbiAgcmV0dXJuIHR3TWVyZ2UoY2xzeChpbnB1dHMpKVxufVxuIl0sIm5hbWVzIjpbImNsc3giLCJ0d01lcmdlIiwiY24iLCJpbnB1dHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3622\n"));

/***/ })

}]);