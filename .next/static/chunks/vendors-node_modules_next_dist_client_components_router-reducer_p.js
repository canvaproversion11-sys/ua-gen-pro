"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_next_dist_client_components_router-reducer_p"],{

/***/ 1709:
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js ***!
  \************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    updateCacheNodeOnNavigation: function() {\n        return updateCacheNodeOnNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ 8270);\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ 6880);\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ 2869);\nfunction updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server — for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren[parallelRouteKey];\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.PAGE_SEGMENT_KEY) {\n            // This is a leaf segment — a page, not a shared layout. We always apply\n            // its data.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        } else if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment — a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation — but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else if (oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees.\n                if (prefetchDataChild !== undefined && prefetchDataChild !== null) {\n                    // Recursively update the children.\n                    taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, prefetchDataChild, prefetchHead);\n                } else {\n                    // The server didn't send any prefetch data for this segment. This\n                    // shouldn't happen because the Route Tree and the Seed Data tree\n                    // should always be the same shape, but until we unify those types\n                    // it's still possible. For now we're going to deopt and trigger a\n                    // lazy fetch during render.\n                    taskChild = spawnTaskForMissingData(newRouterStateChild);\n                }\n            } else {\n                // Either there's no existing Cache Node for this segment, or this\n                // segment doesn't exist in the old Router State tree. Switch to the\n                // \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        }\n        if (taskChild !== null) {\n            // Something changed in the child tree. Keep track of the child task.\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            patchedRouterStateChildren[parallelRouteKey] = taskChild.route;\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        lazyDataResolved: false\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(routerState, prefetchData, prefetchHead) {\n    // Create a task that will later be fulfilled by data from the server.\n    const pendingCacheNode = createPendingCacheNode(routerState, prefetchData, prefetchHead);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        children: null\n    };\n}\nfunction spawnTaskForMissingData(routerState) {\n    // Create a task for a new subtree that wasn't prefetched by the server.\n    // This shouldn't really ever happen but it's here just in case the Seed Data\n    // Tree and the Router State Tree disagree unexpectedly.\n    const pendingCacheNode = createPendingCacheNode(routerState, null, null);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((response)=>{\n        const flightData = response[0];\n        for (const flightDataPath of flightData){\n            const segmentPath = flightDataPath.slice(0, -3);\n            const serverRouterState = flightDataPath[flightDataPath.length - 3];\n            const dynamicData = flightDataPath[flightDataPath.length - 2];\n            const dynamicHead = flightDataPath[flightDataPath.length - 1];\n            if (typeof segmentPath === \"string\") {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Null this out to indicate that the task is complete.\n            task.node = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[1];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(routerState, prefetchData, prefetchHead) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : null,\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        lazyDataResolved: false\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety — it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[1];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[2];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Null this out to indicate that the task is complete.\n    task.node = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch  data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === \"pending\";\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: shouldUsePrefetch ? oldCacheNode.loading : null,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        lazyDataResolved: false\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = \"pending\";\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === \"pending\") {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = \"fulfilled\";\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === \"pending\") {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = \"rejected\";\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO1lBQ3JCUyxZQUFZQyxNQUFNLEdBQUdwRDtZQUNyQnVDLE9BQU92QztRQUNYO0lBQ0o7SUFDQThDLFdBQVdELEdBQUcsR0FBR0Y7SUFDakIsT0FBT0c7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPakksUUFBUXdJLE9BQU8sS0FBSyxjQUFlLE9BQU94SSxRQUFRd0ksT0FBTyxLQUFLLFlBQVl4SSxRQUFRd0ksT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPeEksUUFBUXdJLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckszSSxPQUFPQyxjQUFjLENBQUNDLFFBQVF3SSxPQUFPLEVBQUUsY0FBYztRQUFFdkksT0FBTztJQUFLO0lBQ25FSCxPQUFPNEksTUFBTSxDQUFDMUksUUFBUXdJLE9BQU8sRUFBRXhJO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF3SSxPQUFPO0FBQ2xDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHByLW5hdmlnYXRpb25zLmpzPzY4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhYm9ydFRhc2s6IG51bGwsXG4gICAgbGlzdGVuRm9yRHluYW1pY1JlcXVlc3Q6IG51bGwsXG4gICAgdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uOiBudWxsLFxuICAgIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBhYm9ydFRhc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWJvcnRUYXNrO1xuICAgIH0sXG4gICAgbGlzdGVuRm9yRHluYW1pY1JlcXVlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3Q7XG4gICAgfSxcbiAgICB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uO1xuICAgIH0sXG4gICAgdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbjtcbiAgICB9XG59KTtcbmNvbnN0IF9zZWdtZW50ID0gcmVxdWlyZShcIi4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudFwiKTtcbmNvbnN0IF9tYXRjaHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL21hdGNoLXNlZ21lbnRzXCIpO1xuY29uc3QgX2NyZWF0ZXJvdXRlcmNhY2hla2V5ID0gcmVxdWlyZShcIi4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXlcIik7XG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24ob2xkQ2FjaGVOb2RlLCBvbGRSb3V0ZXJTdGF0ZSwgbmV3Um91dGVyU3RhdGUsIHByZWZldGNoRGF0YSwgcHJlZmV0Y2hIZWFkKSB7XG4gICAgLy8gRGlmZiB0aGUgb2xkIGFuZCBuZXcgdHJlZXMgdG8gcmV1c2UgdGhlIHNoYXJlZCBsYXlvdXRzLlxuICAgIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSBvbGRSb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gbmV3Um91dGVyU3RhdGVbMV07XG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGFbMV07XG4gICAgY29uc3Qgb2xkUGFyYWxsZWxSb3V0ZXMgPSBvbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXM7XG4gICAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgc2V0IG9mIHNlZ21lbnQgY2hpbGRyZW4sIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWN0aXZlIGluXG4gICAgLy8gdGhlIG5ldyB0cmVlLlxuICAgIC8vIFRPRE86IFdlIGN1cnJlbnRseSByZXRhaW4gYWxsIHRoZSBpbmFjdGl2ZSBzZWdtZW50cyBpbmRlZmluaXRlbHksIHVudGlsXG4gICAgLy8gdGhlcmUncyBhbiBleHBsaWNpdCByZWZyZXNoLCBvciBhIHBhcmVudCBsYXlvdXQgaXMgbGF6aWx5IHJlZnJlc2hlZC4gV2VcbiAgICAvLyByZWx5IG9uIHRoaXMgZm9yIHBvcHN0YXRlIG5hdmlnYXRpb25zLCB3aGljaCB1cGRhdGUgdGhlIFJvdXRlciBTdGF0ZSBUcmVlXG4gICAgLy8gYnV0IGRvIG5vdCBlYWdlcmx5IHBlcmZvcm0gYSBkYXRhIGZldGNoLCBiZWNhdXNlIHRoZXkgZXhwZWN0IHRoZSBzZWdtZW50XG4gICAgLy8gZGF0YSB0byBhbHJlYWR5IGJlIGluIHRoZSBDYWNoZSBOb2RlIHRyZWUuIEZvciBoaWdobHkgc3RhdGljIHNpdGVzIHRoYXRcbiAgICAvLyBhcmUgbW9zdGx5IHJlYWQtb25seSwgdGhpcyBtYXkgaGFwcGVuIG9ubHkgcmFyZWx5LCBjYXVzaW5nIG1lbW9yeSB0b1xuICAgIC8vIGxlYWsuIFdlIHNob3VsZCBmaWd1cmUgb3V0IGEgYmV0dGVyIG1vZGVsIGZvciB0aGUgbGlmZXRpbWUgb2YgaW5hY3RpdmVcbiAgICAvLyBzZWdtZW50cywgc28gd2UgY2FuIG1haW50YWluIGluc3RhbnQgYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdpdGhvdXRcbiAgICAvLyBsZWFraW5nIG1lbW9yeSBpbmRlZmluaXRlbHkuXG4gICAgY29uc3QgcHJlZmV0Y2hQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpO1xuICAgIC8vIEFzIHdlIGRpZmYgdGhlIHRyZWVzLCB3ZSBtYXkgc29tZXRpbWVzIG1vZGlmeSAoY29weS1vbi13cml0ZSwgbm90IG11dGF0ZSlcbiAgICAvLyB0aGUgUm91dGUgVHJlZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgc2VydmVyIOKAlCBmb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAvLyBvZiBkZWZhdWx0IHBhcmFsbGVsIHJvdXRlcywgd2UgcHJlc2VydmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudC4gVG9cbiAgICAvLyBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgdHJlZSwgd2UgY2xvbmUgdGhlIHJvdXRlciBzdGF0ZSBjaGlsZHJlbiBhbG9uZ1xuICAgIC8vIHRoZSByZXR1cm4gcGF0aC5cbiAgICBsZXQgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSB7fTtcbiAgICBsZXQgdGFza0NoaWxkcmVuID0gbnVsbDtcbiAgICBmb3IobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gbmV3Um91dGVyU3RhdGVDaGlsZHJlbil7XG4gICAgICAgIGNvbnN0IG5ld1JvdXRlclN0YXRlQ2hpbGQgPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBvbGRSb3V0ZXJTdGF0ZUNoaWxkID0gb2xkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgb2xkU2VnbWVudE1hcENoaWxkID0gb2xkUGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgICAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZCA9IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50Q2hpbGQgPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkWzBdO1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShuZXdTZWdtZW50Q2hpbGQpO1xuICAgICAgICBjb25zdCBvbGRTZWdtZW50Q2hpbGQgPSBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgPyBvbGRSb3V0ZXJTdGF0ZUNoaWxkWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvbGRDYWNoZU5vZGVDaGlsZCA9IG9sZFNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkID8gb2xkU2VnbWVudE1hcENoaWxkLmdldChuZXdTZWdtZW50S2V5Q2hpbGQpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdGFza0NoaWxkO1xuICAgICAgICBpZiAobmV3U2VnbWVudENoaWxkID09PSBfc2VnbWVudC5QQUdFX1NFR01FTlRfS0VZKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbGVhZiBzZWdtZW50IOKAlCBhIHBhZ2UsIG5vdCBhIHNoYXJlZCBsYXlvdXQuIFdlIGFsd2F5cyBhcHBseVxuICAgICAgICAgICAgLy8gaXRzIGRhdGEuXG4gICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blBlbmRpbmdUYXNrKG5ld1JvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmV3U2VnbWVudENoaWxkID09PSBfc2VnbWVudC5ERUZBVUxUX1NFR01FTlRfS0VZKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFub3RoZXIga2luZCBvZiBsZWFmIHNlZ21lbnQg4oCUIGEgZGVmYXVsdCByb3V0ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHJvdXRlcyBoYXZlIHNwZWNpYWwgYmVoYXZpb3IuIFdoZW4gdGhlcmUncyBubyBtYXRjaGluZyBzZWdtZW50XG4gICAgICAgICAgICAvLyBmb3IgYSBwYXJhbGxlbCByb3V0ZSwgTmV4dC5qcyBwcmVzZXJ2ZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudFxuICAgICAgICAgICAgLy8gZHVyaW5nIGEgY2xpZW50IG5hdmlnYXRpb24g4oCUIGJ1dCBub3QgZm9yIGluaXRpYWwgcmVuZGVyLiBUaGUgc2VydmVyXG4gICAgICAgICAgICAvLyBsZWF2ZXMgaXQgdG8gdGhlIGNsaWVudCB0byBhY2NvdW50IGZvciB0aGlzLiBTbyB3ZSBuZWVkIHRvIGhhbmRsZVxuICAgICAgICAgICAgLy8gaXQgaGVyZS5cbiAgICAgICAgICAgIGlmIChvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSB0aGUgZXhpc3RpbmcgUm91dGVyIFN0YXRlIGZvciB0aGlzIHNlZ21lbnQuIFdlIHNwYXduIGEgXCJ0YXNrXCJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgcm91dGVyIHN0YXRlOyB1bmxpa2UgbW9zdCwgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZnVsZmlsbGVkIGFuZCB3b24ndCBiZSBhZmZlY3RlZCBieSB0aGUgZHluYW1pYyByZXNwb25zZS5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blJldXNlZFRhc2sob2xkUm91dGVyU3RhdGVDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gY3VycmVudGx5IGFjdGl2ZSBzZWdtZW50LiBTd2l0Y2ggdG8gdGhlIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blBlbmRpbmdUYXNrKG5ld1JvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2xkU2VnbWVudENoaWxkICE9PSB1bmRlZmluZWQgJiYgKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkobmV3U2VnbWVudENoaWxkLCBvbGRTZWdtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAob2xkQ2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJiBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNlZ21lbnQgZXhpc3RzIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHRyZWVzLlxuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkICYmIHByZWZldGNoRGF0YUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgICAgIHRhc2tDaGlsZCA9IHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihvbGRDYWNoZU5vZGVDaGlsZCwgb2xkUm91dGVyU3RhdGVDaGlsZCwgbmV3Um91dGVyU3RhdGVDaGlsZCwgcHJlZmV0Y2hEYXRhQ2hpbGQsIHByZWZldGNoSGVhZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlcnZlciBkaWRuJ3Qgc2VuZCBhbnkgcHJlZmV0Y2ggZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUaGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGUgUm91dGUgVHJlZSBhbmQgdGhlIFNlZWQgRGF0YSB0cmVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHdheXMgYmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCB1bnRpbCB3ZSB1bmlmeSB0aG9zZSB0eXBlc1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHN0aWxsIHBvc3NpYmxlLiBGb3Igbm93IHdlJ3JlIGdvaW5nIHRvIGRlb3B0IGFuZCB0cmlnZ2VyIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blRhc2tGb3JNaXNzaW5nRGF0YShuZXdSb3V0ZXJTdGF0ZUNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB0aGVyZSdzIG5vIGV4aXN0aW5nIENhY2hlIE5vZGUgZm9yIHRoaXMgc2VnbWVudCwgb3IgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgb2xkIFJvdXRlciBTdGF0ZSB0cmVlLiBTd2l0Y2ggdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICAgICAgICAgIHRhc2tDaGlsZCA9IHNwYXduUGVuZGluZ1Rhc2sobmV3Um91dGVyU3RhdGVDaGlsZCwgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCwgcHJlZmV0Y2hIZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgdHJlZS4gU3dpdGNoIHRvIHRoZSBcImNyZWF0ZVwiIHBhdGguXG4gICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blBlbmRpbmdUYXNrKG5ld1JvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhc2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGNoYW5nZWQgaW4gdGhlIGNoaWxkIHRyZWUuIEtlZXAgdHJhY2sgb2YgdGhlIGNoaWxkIHRhc2suXG4gICAgICAgICAgICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFza0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza0NoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCB0YXNrQ2hpbGQpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB0YXNrQ2hpbGQubm9kZTtcbiAgICAgICAgICAgIGlmIChuZXdDYWNoZU5vZGVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KG5ld1NlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIHByZWZldGNoUGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY2hpbGQgdHJlZSdzIHJvdXRlIHN0YXRlIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcHJlZmV0Y2hlZFxuICAgICAgICAgICAgLy8gcm91dGUgc2VudCBieSB0aGUgc2VydmVyLiBXZSBuZWVkIHRvIGNsb25lIGl0IGFzIHdlIHRyYXZlcnNlIGJhY2sgdXBcbiAgICAgICAgICAgIC8vIHRoZSB0cmVlLlxuICAgICAgICAgICAgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSB0YXNrQ2hpbGQucm91dGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgY2hpbGQgZGlkbid0IGNoYW5nZS4gV2UgY2FuIHVzZSB0aGUgcHJlZmV0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IG5ld1JvdXRlclN0YXRlQ2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBObyBuZXcgdGFza3Mgd2VyZSBzcGF3bmVkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBvbGRDYWNoZU5vZGUucnNjLFxuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGFyZW4ndCB1cGRhdGluZyB0aGUgcHJlZmV0Y2hSc2MgZmllbGQsIHNpbmNlIHRoaXMgbm9kZVxuICAgICAgICAvLyBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIGN1cnJlbnQgdHJlZSwgYmVjYXVzZSBpdCB3b3VsZCBiZSB3ZWlyZCBmb3JcbiAgICAgICAgLy8gcHJlZmV0Y2ggZGF0YSB0byBiZSBuZXdlciB0aGFuIHRoZSBmaW5hbCBkYXRhLiBJdCBwcm9iYWJseSB3b24ndCBldmVyIGJlXG4gICAgICAgIC8vIG9ic2VydmFibGUgYW55d2F5LCBidXQgaXQgY291bGQgaGFwcGVuIGlmIHRoZSBzZWdtZW50IGlzIHVubW91bnRlZCB0aGVuXG4gICAgICAgIC8vIG1vdW50ZWQgYWdhaW4sIGJlY2F1c2UgTGF5b3V0Um91dGVyIHdpbGwgbW9tZW50YXJpbHkgc3dpdGNoIHRvIHJlbmRlcmluZ1xuICAgICAgICAvLyBwcmVmZXRjaFJzYywgdmlhIHVzZURlZmVycmVkVmFsdWUuXG4gICAgICAgIHByZWZldGNoUnNjOiBvbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICAgIGhlYWQ6IG9sZENhY2hlTm9kZS5oZWFkLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICAgIGxvYWRpbmc6IG9sZENhY2hlTm9kZS5sb2FkaW5nLFxuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIGNsb25lZCBleGNlcHQgZm9yIHRoZSBjaGlsZHJlbiwgd2hpY2ggd2UgY29tcHV0ZWQgYWJvdmUuXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBwcmVmZXRjaFBhcmFsbGVsUm91dGVzLFxuICAgICAgICBsYXp5RGF0YVJlc29sdmVkOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgY2xvbmVkIGNvcHkgb2YgdGhlIHJvdXRlciBzdGF0ZSB3aXRoIHVwZGF0ZWQgY2hpbGRyZW4uXG4gICAgICAgIHJvdXRlOiBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKG5ld1JvdXRlclN0YXRlLCBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbiksXG4gICAgICAgIG5vZGU6IG5ld0NhY2hlTm9kZSxcbiAgICAgICAgY2hpbGRyZW46IHRhc2tDaGlsZHJlblxuICAgIH07XG59XG5mdW5jdGlvbiBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKGJhc2VSb3V0ZXJTdGF0ZSwgbmV3Q2hpbGRyZW4pIHtcbiAgICBjb25zdCBjbG9uZSA9IFtcbiAgICAgICAgYmFzZVJvdXRlclN0YXRlWzBdLFxuICAgICAgICBuZXdDaGlsZHJlblxuICAgIF07XG4gICAgLy8gQmFzZWQgb24gZXF1aXZhbGVudCBsb2dpYyBpbiBhcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSwgYnV0IHNob3VsZFxuICAgIC8vIGNvbmZpcm0gd2hldGhlciB3ZSBuZWVkIHRvIGNvcHkgYWxsIG9mIHRoZXNlIGZpZWxkcy4gTm90IHN1cmUgdGhlIHNlcnZlclxuICAgIC8vIGV2ZXIgc2VuZHMsIGUuZy4gdGhlIHJlZmV0Y2ggbWFya2VyLlxuICAgIGlmICgyIGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgICAgICBjbG9uZVsyXSA9IGJhc2VSb3V0ZXJTdGF0ZVsyXTtcbiAgICB9XG4gICAgaWYgKDMgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgICAgIGNsb25lWzNdID0gYmFzZVJvdXRlclN0YXRlWzNdO1xuICAgIH1cbiAgICBpZiAoNCBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICAgICAgY2xvbmVbNF0gPSBiYXNlUm91dGVyU3RhdGVbNF07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIHNwYXduUGVuZGluZ1Rhc2socm91dGVyU3RhdGUsIHByZWZldGNoRGF0YSwgcHJlZmV0Y2hIZWFkKSB7XG4gICAgLy8gQ3JlYXRlIGEgdGFzayB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgIGNvbnN0IHBlbmRpbmdDYWNoZU5vZGUgPSBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHByZWZldGNoSGVhZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm91dGU6IHJvdXRlclN0YXRlLFxuICAgICAgICBub2RlOiBwZW5kaW5nQ2FjaGVOb2RlLFxuICAgICAgICBjaGlsZHJlbjogbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBzcGF3blJldXNlZFRhc2socmV1c2VkUm91dGVyU3RhdGUpIHtcbiAgICAvLyBDcmVhdGUgYSB0YXNrIHRoYXQgcmV1c2VzIGFuIGV4aXN0aW5nIHNlZ21lbnQsIGUuZy4gd2hlbiByZXVzaW5nXG4gICAgLy8gdGhlIGN1cnJlbnQgYWN0aXZlIHNlZ21lbnQgaW4gcGxhY2Ugb2YgYSBkZWZhdWx0IHJvdXRlLlxuICAgIHJldHVybiB7XG4gICAgICAgIHJvdXRlOiByZXVzZWRSb3V0ZXJTdGF0ZSxcbiAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3Bhd25UYXNrRm9yTWlzc2luZ0RhdGEocm91dGVyU3RhdGUpIHtcbiAgICAvLyBDcmVhdGUgYSB0YXNrIGZvciBhIG5ldyBzdWJ0cmVlIHRoYXQgd2Fzbid0IHByZWZldGNoZWQgYnkgdGhlIHNlcnZlci5cbiAgICAvLyBUaGlzIHNob3VsZG4ndCByZWFsbHkgZXZlciBoYXBwZW4gYnV0IGl0J3MgaGVyZSBqdXN0IGluIGNhc2UgdGhlIFNlZWQgRGF0YVxuICAgIC8vIFRyZWUgYW5kIHRoZSBSb3V0ZXIgU3RhdGUgVHJlZSBkaXNhZ3JlZSB1bmV4cGVjdGVkbHkuXG4gICAgY29uc3QgcGVuZGluZ0NhY2hlTm9kZSA9IGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUocm91dGVyU3RhdGUsIG51bGwsIG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcbiAgICAgICAgbm9kZTogcGVuZGluZ0NhY2hlTm9kZSxcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QodGFzaywgcmVzcG9uc2VQcm9taXNlKSB7XG4gICAgcmVzcG9uc2VQcm9taXNlLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICBjb25zdCBmbGlnaHREYXRhID0gcmVzcG9uc2VbMF07XG4gICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclJvdXRlclN0YXRlID0gZmxpZ2h0RGF0YVBhdGhbZmxpZ2h0RGF0YVBhdGgubGVuZ3RoIC0gM107XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRGF0YSA9IGZsaWdodERhdGFQYXRoW2ZsaWdodERhdGFQYXRoLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0hlYWQgPSBmbGlnaHREYXRhUGF0aFtmbGlnaHREYXRhUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudFBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2sodGFzaywgc2VnbWVudFBhdGgsIHNlcnZlclJvdXRlclN0YXRlLCBkeW5hbWljRGF0YSwgZHluYW1pY0hlYWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIGV4aGF1c3RlZCBhbGwgdGhlIGRhdGEgd2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55IHJlbWFpbmluZyBwZW5kaW5nIHRhc2tzIGluIHRoZSB0cmVlLCBhYm9ydCB0aGVtIG5vdy5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbnkgbWlzc2luZyBkYXRhLCBpdCB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoLlxuICAgICAgICBhYm9ydFRhc2sodGFzaywgbnVsbCk7XG4gICAgfSwgKGVycm9yKT0+e1xuICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBkdXJpbmcgcmVuZGVyXG4gICAgICAgIGFib3J0VGFzayh0YXNrLCBlcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKHJvb3RUYXNrLCBzZWdtZW50UGF0aCwgc2VydmVyUm91dGVyU3RhdGUsIGR5bmFtaWNEYXRhLCBkeW5hbWljSGVhZCkge1xuICAgIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlIG5lZWRcbiAgICAvLyB0byBmaW5kIHRoZSBwYXJ0IG9mIHRoZSB0YXNrIHRyZWUgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgcmVzcG9uc2UsIGFuZFxuICAgIC8vIGZ1bGZpbGwgaXQgdXNpbmcgdGhlIGR5bmFtaWMgZGF0YS5cbiAgICAvL1xuICAgIC8vIHNlZ21lbnRQYXRoIHJlcHJlc2VudHMgdGhlIHBhcmVudCBwYXRoIG9mIHN1YnRyZWUuIEl0J3MgYSByZXBlYXRpbmcgcGF0dGVyblxuICAgIC8vIG9mIHBhcmFsbGVsIHJvdXRlIGtleSBhbmQgc2VnbWVudDpcbiAgICAvL1xuICAgIC8vICAgW3N0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCBzdHJpbmcsIFNlZ21lbnQsIC4uLl1cbiAgICAvL1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGF0aCBhbmQgZmluaXNoIGFueSB0YXNrcyB0aGF0IG1hdGNoIHRoaXMgcGF5bG9hZC5cbiAgICBsZXQgdGFzayA9IHJvb3RUYXNrO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzZWdtZW50UGF0aC5sZW5ndGg7IGkgKz0gMil7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXkgPSBzZWdtZW50UGF0aFtpXTtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRQYXRoW2kgKyAxXTtcbiAgICAgICAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHRhc2tDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tTZWdtZW50ID0gdGFza0NoaWxkLnJvdXRlWzBdO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShzZWdtZW50LCB0YXNrU2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYSBtYXRjaCBmb3IgdGhpcyB0YXNrLiBLZWVwIHRyYXZlcnNpbmcgZG93biB0aGUgdGFzayB0cmVlLlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gdGFza0NoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZGlkbid0IGZpbmQgYSBjaGlsZCB0YXNrIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIGRhdGEuIEV4aXQuIFdlIHdvbid0XG4gICAgICAgIC8vIGFib3J0IHRoZSB0YXNrLCB0aG91Z2gsIGJlY2F1c2UgYSBkaWZmZXJlbnQgRmxpZ2h0RGF0YVBhdGggbWF5IGJlIGFibGUgdG9cbiAgICAgICAgLy8gZnVsZmlsbCBpdCAoc2VlIGxvb3AgaW4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QpLiBXZSBvbmx5IGFib3J0IHRhc2tzXG4gICAgICAgIC8vIG9uY2Ugd2UndmUgcnVuIG91dCBvZiBkYXRhLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCh0YXNrLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCh0YXNrLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKSB7XG4gICAgLy8gZHluYW1pY0RhdGEgbWF5IHJlcHJlc2VudCBhIGxhcmdlciBzdWJ0cmVlIHRoYW4gdGhlIHRhc2suIEJlZm9yZSB3ZSBjYW5cbiAgICAvLyBmaW5pc2ggdGhlIHRhc2ssIHdlIG5lZWQgdG8gbGluZSB0aGVtIHVwLlxuICAgIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW47XG4gICAgY29uc3QgdGFza05vZGUgPSB0YXNrLm5vZGU7XG4gICAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBsZWFmIG5vZGUgb2YgdGhlIHBlbmRpbmcgdGFzay4gVGhlIHNlcnZlciBkYXRhIHRyZWVcbiAgICAgICAgLy8gbGluZXMgdXAgdGhlIHBlbmRpbmcgQ2FjaGUgTm9kZSB0cmVlLiBXZSBjYW4gbm93IHN3aXRjaCB0byB0aGVcbiAgICAgICAgLy8gbm9ybWFsIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKHRhc2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlKHRhc2tOb2RlLCB0YXNrLnJvdXRlLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKTtcbiAgICAgICAgICAgIC8vIE51bGwgdGhpcyBvdXQgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdGFzayBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgIHRhc2subm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGUgc2VydmVyIHJldHVybmVkIG1vcmUgZGF0YSB0aGFuIHdlIG5lZWQgdG8gZmluaXNoIHRoZSB0YXNrLiBTa2lwIG92ZXJcbiAgICAvLyB0aGUgZXh0cmEgc2VnbWVudHMgdW50aWwgd2UgcmVhY2ggdGhlIGxlYWYgdGFzayBub2RlLlxuICAgIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gc2VydmVyUm91dGVyU3RhdGVbMV07XG4gICAgY29uc3QgZHluYW1pY0RhdGFDaGlsZHJlbiA9IGR5bmFtaWNEYXRhWzFdO1xuICAgIGZvcihjb25zdCBwYXJhbGxlbFJvdXRlS2V5IGluIHNlcnZlclJvdXRlclN0YXRlKXtcbiAgICAgICAgY29uc3Qgc2VydmVyUm91dGVyU3RhdGVDaGlsZCA9IHNlcnZlckNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBkeW5hbWljRGF0YUNoaWxkID0gZHluYW1pY0RhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgaWYgKHRhc2tDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrU2VnbWVudCA9IHRhc2tDaGlsZC5yb3V0ZVswXTtcbiAgICAgICAgICAgIGlmICgoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkWzBdLCB0YXNrU2VnbWVudCkgJiYgZHluYW1pY0RhdGFDaGlsZCAhPT0gbnVsbCAmJiBkeW5hbWljRGF0YUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoIGZvciB0aGlzIHRhc2suIEtlZXAgdHJhdmVyc2luZyBkb3duIHRoZSB0YXNrIHRyZWUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCh0YXNrQ2hpbGQsIHNlcnZlclJvdXRlclN0YXRlQ2hpbGQsIGR5bmFtaWNEYXRhQ2hpbGQsIGR5bmFtaWNIZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIFdlIGRpZG4ndCBmaW5kIGEgY2hpbGQgdGFzayB0aGF0IG1hdGNoZXMgdGhlIHNlcnZlciBkYXRhLiBXZSB3b24ndCBhYm9ydFxuICAgIC8vIHRoZSB0YXNrLCB0aG91Z2gsIGJlY2F1c2UgYSBkaWZmZXJlbnQgRmxpZ2h0RGF0YVBhdGggbWF5IGJlIGFibGUgdG9cbiAgICAvLyBmdWxmaWxsIGl0IChzZWUgbG9vcCBpbiBsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCkuIFdlIG9ubHkgYWJvcnQgdGFza3NcbiAgICAvLyBvbmNlIHdlJ3ZlIHJ1biBvdXQgb2YgZGF0YS5cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHByZWZldGNoSGVhZCkge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZHJlbiA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsxXSA6IG51bGw7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pe1xuICAgICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkID0gcm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQgPSBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbCA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXTtcbiAgICAgICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gKDAsIF9jcmVhdGVyb3V0ZXJjYWNoZWtleS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkoc2VnbWVudENoaWxkKTtcbiAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkID09PSB1bmRlZmluZWQgPyBudWxsIDogcHJlZmV0Y2hEYXRhQ2hpbGQsIHByZWZldGNoSGVhZCk7XG4gICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKTtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZCk7XG4gICAgfVxuICAgIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgICAvLyBvbiBjb3JyZXNwb25kaW5nIGxvZ2ljIGluIGZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzXG4gICAgY29uc3QgaXNMZWFmU2VnbWVudCA9IHBhcmFsbGVsUm91dGVzLnNpemUgPT09IDA7XG4gICAgY29uc3QgbWF5YmVQcmVmZXRjaFJzYyA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsyXSA6IG51bGw7XG4gICAgY29uc3QgbWF5YmVQcmVmZXRjaExvYWRpbmcgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbM10gOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogcGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgIHByZWZldGNoUnNjOiBtYXliZVByZWZldGNoUnNjICE9PSB1bmRlZmluZWQgPyBtYXliZVByZWZldGNoUnNjIDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBpc0xlYWZTZWdtZW50ID8gcHJlZmV0Y2hIZWFkIDogbnVsbCxcbiAgICAgICAgbG9hZGluZzogbWF5YmVQcmVmZXRjaExvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hMb2FkaW5nIDogbnVsbCxcbiAgICAgICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgcHJvbWlzZS4gVGhpcyB3aWxsIGJlIGZ1bGZpbGxlZCBvbmNlIHRoZSBkeW5hbWljXG4gICAgICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgcnNjOiBjcmVhdGVEZWZlcnJlZFJzYygpLFxuICAgICAgICBoZWFkOiBpc0xlYWZTZWdtZW50ID8gY3JlYXRlRGVmZXJyZWRSc2MoKSA6IG51bGwsXG4gICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoY2FjaGVOb2RlLCB0YXNrU3RhdGUsIHNlcnZlclN0YXRlLCBkeW5hbWljRGF0YSwgZHluYW1pY0hlYWQpIHtcbiAgICAvLyBXcml0ZXMgYSBkeW5hbWljIHJlc3BvbnNlIGludG8gYW4gZXhpc3RpbmcgQ2FjaGUgTm9kZSB0cmVlLiBUaGlzIGRvZXMgX25vdF9cbiAgICAvLyBjcmVhdGUgYSBuZXcgdHJlZSwgaXQgdXBkYXRlcyB0aGUgZXhpc3RpbmcgdHJlZSBpbi1wbGFjZS4gU28gaXQgbXVzdCBmb2xsb3dcbiAgICAvLyB0aGUgU3VzcGVuc2UgcnVsZXMgb2YgY2FjaGUgc2FmZXR5IOKAlCBpdCBjYW4gcmVzb2x2ZSBwZW5kaW5nIHByb21pc2VzLCBidXRcbiAgICAvLyBpdCBjYW5ub3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGRhdGEuIEl0IGNhbiBhZGQgc2VnbWVudHMgdG8gdGhlIHRyZWUgKGJlY2F1c2VcbiAgICAvLyBhIG1pc3Npbmcgc2VnbWVudCB3aWxsIGNhdXNlIHRoZSBsYXlvdXQgcm91dGVyIHRvIHN1c3BlbmQpLlxuICAgIC8vIGJ1dCBpdCBjYW5ub3QgZGVsZXRlIHRoZW0uXG4gICAgLy9cbiAgICAvLyBXZSBtdXN0IHJlc29sdmUgZXZlcnkgcHJvbWlzZSBpbiB0aGUgdHJlZSwgb3IgZWxzZSBpdCB3aWxsIHN1c3BlbmRcbiAgICAvLyBpbmRlZmluaXRlbHkuIElmIHdlIGRpZCBub3QgcmVjZWl2ZSBkYXRhIGZvciBhIHNlZ21lbnQsIHdlIHdpbGwgcmVzb2x2ZSBpdHNcbiAgICAvLyBkYXRhIHByb21pc2UgdG8gYG51bGxgIHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgY29uc3QgdGFza1N0YXRlQ2hpbGRyZW4gPSB0YXNrU3RhdGVbMV07XG4gICAgY29uc3Qgc2VydmVyU3RhdGVDaGlsZHJlbiA9IHNlcnZlclN0YXRlWzFdO1xuICAgIGNvbnN0IGRhdGFDaGlsZHJlbiA9IGR5bmFtaWNEYXRhWzFdO1xuICAgIC8vIFRoZSByb3V0ZXIgc3RhdGUgdGhhdCB3ZSB0cmF2ZXJzZSB0aGUgdHJlZSB3aXRoICh0YXNrU3RhdGUpIGlzIHRoZSBzYW1lIG9uZVxuICAgIC8vIHRoYXQgd2UgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHBlbmRpbmcgQ2FjaGUgTm9kZSB0cmVlLiBUaGF0IHdheSB3ZSdyZSBzdXJlXG4gICAgLy8gdG8gcmVzb2x2ZSBhbGwgdGhlIHBlbmRpbmcgcHJvbWlzZXMuXG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBjYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXM7XG4gICAgZm9yKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHRhc2tTdGF0ZUNoaWxkcmVuKXtcbiAgICAgICAgY29uc3QgdGFza1N0YXRlQ2hpbGQgPSB0YXNrU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgc2VydmVyU3RhdGVDaGlsZCA9IHNlcnZlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IGRhdGFDaGlsZCA9IGRhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgc2VnbWVudE1hcENoaWxkID0gcGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgICAgICBjb25zdCB0YXNrU2VnbWVudENoaWxkID0gdGFza1N0YXRlQ2hpbGRbMF07XG4gICAgICAgIGNvbnN0IHRhc2tTZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KSh0YXNrU2VnbWVudENoaWxkKTtcbiAgICAgICAgY29uc3QgY2FjaGVOb2RlQ2hpbGQgPSBzZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHNlZ21lbnRNYXBDaGlsZC5nZXQodGFza1NlZ21lbnRLZXlDaGlsZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc2VydmVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkICYmICgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHRhc2tTZWdtZW50Q2hpbGQsIHNlcnZlclN0YXRlQ2hpbGRbMF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFDaGlsZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBoYXBweSBwYXRoLiBSZWN1cnNpdmVseSB1cGRhdGUgYWxsIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUGVuZGluZ0NhY2hlTm9kZShjYWNoZU5vZGVDaGlsZCwgdGFza1N0YXRlQ2hpbGQsIHNlcnZlclN0YXRlQ2hpbGQsIGRhdGFDaGlsZCwgZHluYW1pY0hlYWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgbmV2ZXIgcmV0dXJuZWQgZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUcmlnZ2VyIGEgbGF6eVxuICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaCBkdXJpbmcgcmVuZGVyLiBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGUgUm91dGUgVHJlZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIFNlZWQgRGF0YSB0cmVlIHNlbnQgYnkgdGhlIHNlcnZlciBzaG91bGQgYWx3YXlzIGJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIHNoYXBlIHdoZW4gcGFydCBvZiB0aGUgc2FtZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrU3RhdGVDaGlsZCwgY2FjaGVOb2RlQ2hpbGQsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlcnZlciBuZXZlciByZXR1cm5lZCBkYXRhIGZvciB0aGlzIHNlZ21lbnQuIFRyaWdnZXIgYSBsYXp5XG4gICAgICAgICAgICAgICAgLy8gZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgICAgICAgICAgICBhYm9ydFBlbmRpbmdDYWNoZU5vZGUodGFza1N0YXRlQ2hpbGQsIGNhY2hlTm9kZUNoaWxkLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciByZXNwb25zZSBtYXRjaGVzIHdoYXQgd2FzIGV4cGVjdGVkIHRvIHJlY2VpdmUsIGJ1dCB0aGVyZSdzXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIENhY2hlIE5vZGUgaW4gdGhlIHRhc2sgdHJlZS4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGVcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBjcmVhdGVkIGEgbm9kZSBmb3IgZXZlcnlcbiAgICAgICAgLy8gc2VnbWVudCBpbiB0aGUgdHJlZSB0aGF0J3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGFzay5cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgdGhlIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdG8gZnVsZmlsbCB0aGUgZGVmZXJyZWQgUlNDIHByb21pc2VcbiAgICAvLyBvbiB0aGUgQ2FjaGUgTm9kZS5cbiAgICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjO1xuICAgIGNvbnN0IGR5bmFtaWNTZWdtZW50RGF0YSA9IGR5bmFtaWNEYXRhWzJdO1xuICAgIGlmIChyc2MgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxhenkgY2FjaGUgbm9kZS4gV2UgY2FuIG92ZXJ3cml0ZSBpdC4gVGhpcyBpcyBvbmx5IHNhZmVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBrbm93IHRoYXQgdGhlIExheW91dFJvdXRlciBzdXNwZW5kcyBpZiBgcnNjYCBpcyBgbnVsbGAuXG4gICAgICAgIGNhY2hlTm9kZS5yc2MgPSBkeW5hbWljU2VnbWVudERhdGE7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRlZmVycmVkIFJTQyBwcm9taXNlLiBXZSBjYW4gZnVsZmlsbCBpdCB3aXRoIHRoZSBkYXRhIHdlIGp1c3RcbiAgICAgICAgLy8gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLiBJZiBpdCB3YXMgYWxyZWFkeSByZXNvbHZlZCBieSBhIGRpZmZlcmVudFxuICAgICAgICAvLyBuYXZpZ2F0aW9uLCB0aGVuIHRoaXMgZG9lcyBub3RoaW5nIGJlY2F1c2Ugd2UgY2FuJ3Qgb3ZlcndyaXRlIGRhdGEuXG4gICAgICAgIHJzYy5yZXNvbHZlKGR5bmFtaWNTZWdtZW50RGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhIGRlZmVycmVkIFJTQyBwcm9taXNlLCBub3IgaXMgaXQgZW1wdHksIHNvIGl0IG11c3QgaGF2ZVxuICAgIC8vIGJlZW4gcG9wdWxhdGVkIGJ5IGEgZGlmZmVyZW50IG5hdmlnYXRpb24uIFdlIG11c3Qgbm90IG92ZXJ3cml0ZSBpdC5cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudC4gSWYgc28sIGl0IHdpbGwgaGF2ZSBhIGBoZWFkYCBwcm9wZXJ0eSB3aXRoXG4gICAgLy8gYSBwZW5kaW5nIHByb21pc2UgdGhhdCBuZWVkcyB0byBiZSByZXNvbHZlZCB3aXRoIHRoZSBkeW5hbWljIGhlYWQgZnJvbVxuICAgIC8vIHRoZSBzZXJ2ZXIuXG4gICAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkO1xuICAgIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgICAgIGhlYWQucmVzb2x2ZShkeW5hbWljSGVhZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIGVycm9yKSB7XG4gICAgY29uc3QgY2FjaGVOb2RlID0gdGFzay5ub2RlO1xuICAgIGlmIChjYWNoZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpbmRpY2F0ZXMgdGhlIHRhc2sgaXMgYWxyZWFkeSBjb21wbGV0ZS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXNrQ2hpbGRyZW4gPSB0YXNrLmNoaWxkcmVuO1xuICAgIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgLy8gUmVhY2hlZCB0aGUgbGVhZiB0YXNrIG5vZGUuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSBwZW5kaW5nIGNhY2hlXG4gICAgICAgIC8vIG5vZGUgdHJlZS5cbiAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2sucm91dGUsIGNhY2hlTm9kZSwgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXRlIHRhc2sgbm9kZS4gS2VlcCB0cmF2ZXJzaW5nIHVudGlsIHdlIHJlYWNoIGFcbiAgICAgICAgLy8gdGFzayBub2RlIHdpdGggbm8gY2hpbGRyZW4uIFRoYXQgd2lsbCBiZSB0aGUgcm9vdCBvZiB0aGUgY2FjaGUgbm9kZSB0cmVlXG4gICAgICAgIC8vIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICAgIGZvciAoY29uc3QgdGFza0NoaWxkIG9mIHRhc2tDaGlsZHJlbi52YWx1ZXMoKSl7XG4gICAgICAgICAgICBhYm9ydFRhc2sodGFza0NoaWxkLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTnVsbCB0aGlzIG91dCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YXNrIGlzIGNvbXBsZXRlLlxuICAgIHRhc2subm9kZSA9IG51bGw7XG59XG5mdW5jdGlvbiBhYm9ydFBlbmRpbmdDYWNoZU5vZGUocm91dGVyU3RhdGUsIGNhY2hlTm9kZSwgZXJyb3IpIHtcbiAgICAvLyBGb3IgZXZlcnkgcGVuZGluZyBzZWdtZW50IGluIHRoZSB0cmVlLCByZXNvbHZlIGl0cyBgcnNjYCBwcm9taXNlIHRvIGBudWxsYFxuICAgIC8vIHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgLy9cbiAgICAvLyBPciwgaWYgYW4gZXJyb3Igb2JqZWN0IGlzIHByb3ZpZGVkLCBpdCB3aWxsIGVycm9yIGluc3RlYWQuXG4gICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdO1xuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gY2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzO1xuICAgIGZvcihsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKXtcbiAgICAgICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRNYXBDaGlsZCA9IHBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgaWYgKHNlZ21lbnRNYXBDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdO1xuICAgICAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShzZWdtZW50Q2hpbGQpO1xuICAgICAgICBjb25zdCBjYWNoZU5vZGVDaGlsZCA9IHNlZ21lbnRNYXBDaGlsZC5nZXQoc2VnbWVudEtleUNoaWxkKTtcbiAgICAgICAgaWYgKGNhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZShyb3V0ZXJTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB3ZSdyZSB0cmF2ZXJzaW5nIHRoZSBzYW1lIHRyZWUgdGhhdCB3YXNcbiAgICAgICAgLy8gdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNhY2hlIG5vZGVzIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjO1xuICAgIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgICAgICAgIHJzYy5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgZHVyaW5nIHJlbmRlcmluZy5cbiAgICAgICAgICAgIHJzYy5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQuIElmIHNvLCBpdCB3aWxsIGhhdmUgYSBgaGVhZGAgcHJvcGVydHkgd2l0aFxuICAgIC8vIGEgcGVuZGluZyBwcm9taXNlIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQuIElmIGFuIGVycm9yIHdhcyBwcm92aWRlZCwgd2VcbiAgICAvLyB3aWxsIG5vdCByZXNvbHZlIGl0IHdpdGggYW4gZXJyb3IsIHNpbmNlIHRoaXMgaXMgcmVuZGVyZWQgYXQgdGhlIHJvb3Qgb2ZcbiAgICAvLyB0aGUgYXBwLiBXZSB3YW50IHRoZSBzZWdtZW50IHRvIGVycm9yLCBub3QgdGhlIGVudGlyZSBhcHAuXG4gICAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkO1xuICAgIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgICAgIGhlYWQucmVzb2x2ZShudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24ob2xkQ2FjaGVOb2RlLCByb3V0ZXJTdGF0ZSkge1xuICAgIC8vIEEgcG9wc3RhdGUgbmF2aWdhdGlvbiByZWFkcyBkYXRhIGZyb20gdGhlIGxvY2FsIGNhY2hlLiBJdCBkb2VzIG5vdCBpc3N1ZVxuICAgIC8vIG5ldyBuZXR3b3JrIHJlcXVlc3RzICh1bmxlc3MgdGhlIGNhY2hlIGVudHJpZXMgaGF2ZSBiZWVuIGV2aWN0ZWQpLiBTbywgd2VcbiAgICAvLyB1cGRhdGUgdGhlIGNhY2hlIHRvIGRyb3AgdGhlIHByZWZldGNoICBkYXRhIGZvciBhbnkgc2VnbWVudCB3aG9zZSBkeW5hbWljXG4gICAgLy8gZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpcyBwcmV2ZW50cyBhbiB1bm5lY2Vzc2FyeSBmbGFzaCBiYWNrIHRvIFBQUlxuICAgIC8vIHN0YXRlIGR1cmluZyBhIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uLlxuICAgIC8vXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBjbG9uZXMgdGhlIGVudGlyZSBjYWNoZSBub2RlIHRyZWUgYW5kIHNldHMgdGhlIGBwcmVmZXRjaFJzY2BcbiAgICAvLyBmaWVsZCB0byBgbnVsbGAgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkLiBXZSBjYW4ndCBtdXRhdGUgdGhlIG5vZGVcbiAgICAvLyBpbiBwbGFjZSBiZWNhdXNlIHRoaXMgaXMgYSBjb25jdXJyZW50IGRhdGEgc3RydWN0dXJlLlxuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBvbGRQYXJhbGxlbFJvdXRlcyA9IG9sZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcztcbiAgICBjb25zdCBuZXdQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpO1xuICAgIGZvcihsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKXtcbiAgICAgICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnRDaGlsZCk7XG4gICAgICAgIGNvbnN0IG9sZFNlZ21lbnRNYXBDaGlsZCA9IG9sZFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgaWYgKG9sZFNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRDYWNoZU5vZGVDaGlsZCA9IG9sZFNlZ21lbnRNYXBDaGlsZC5nZXQoc2VnbWVudEtleUNoaWxkKTtcbiAgICAgICAgICAgIGlmIChvbGRDYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24ob2xkQ2FjaGVOb2RlQ2hpbGQsIHJvdXRlclN0YXRlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KHNlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG5ld1BhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBuZXdTZWdtZW50TWFwQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE9ubHkgc2hvdyBwcmVmZXRjaGVkIGRhdGEgaWYgdGhlIGR5bmFtaWMgZGF0YSBpcyBzdGlsbCBwZW5kaW5nLlxuICAgIC8vXG4gICAgLy8gVGVobmljYWxseSwgd2hhdCB3ZSdyZSBhY3R1YWxseSBjaGVja2luZyBpcyB3aGV0aGVyIHRoZSBkeW5hbWljIG5ldHdvcmtcbiAgICAvLyByZXNwb25zZSB3YXMgcmVjZWl2ZWQuIEJ1dCBzaW5jZSBpdCdzIGEgc3RyZWFtaW5nIHJlc3BvbnNlLCB0aGlzIGRvZXMgbm90XG4gICAgLy8gbWVhbiB0aGF0IGFsbCB0aGUgZHluYW1pYyBkYXRhIGhhcyBmdWxseSBzdHJlYW1lZCBpbi4gSXQganVzdCBtZWFucyB0aGF0XG4gICAgLy8gX3NvbWVfIG9mIHRoZSBkeW5hbWljIGRhdGEgd2FzIHJlY2VpdmVkLiBCdXQgYXMgYSBoZXVyaXN0aWMsIHdlIGFzc3VtZSB0aGF0XG4gICAgLy8gdGhlIHJlc3QgZHluYW1pYyBkYXRhIHdpbGwgc3RyZWFtIGluIHF1aWNrbHksIHNvIGl0J3Mgc3RpbGwgYmV0dGVyIHRvIHNraXBcbiAgICAvLyB0aGUgcHJlZmV0Y2ggc3RhdGUuXG4gICAgY29uc3QgcnNjID0gb2xkQ2FjaGVOb2RlLnJzYztcbiAgICBjb25zdCBzaG91bGRVc2VQcmVmZXRjaCA9IGlzRGVmZXJyZWRSc2MocnNjKSAmJiByc2Muc3RhdHVzID09PSBcInBlbmRpbmdcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjLFxuICAgICAgICBoZWFkOiBvbGRDYWNoZU5vZGUuaGVhZCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogc2hvdWxkVXNlUHJlZmV0Y2ggPyBvbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MgOiBudWxsLFxuICAgICAgICBsb2FkaW5nOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5sb2FkaW5nIDogbnVsbCxcbiAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBjbG9uZWQgY2hpbGRyZW4gd2UgY29tcHV0ZWQgYWJvdmVcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ld1BhcmFsbGVsUm91dGVzLFxuICAgICAgICBsYXp5RGF0YVJlc29sdmVkOiBmYWxzZVxuICAgIH07XG59XG5jb25zdCBERUZFUlJFRCA9IFN5bWJvbCgpO1xuLy8gVGhpcyB0eXBlIGV4aXN0cyB0byBkaXN0aW5ndWlzaCBhIERlZmVycmVkUnNjIGZyb20gYSBGbGlnaHQgcHJvbWlzZS4gSXQncyBhXG4vLyBjb21wcm9taXNlIHRvIGF2b2lkIGFkZGluZyBhbiBleHRyYSBmaWVsZCBvbiBldmVyeSBDYWNoZSBOb2RlLCB3aGljaCB3b3VsZCBiZVxuLy8gYXdrd2FyZCBiZWNhdXNlIHRoZSBwcmUtUFBSIHBhcnRzIG9mIGNvZGViYXNlIHdvdWxkIG5lZWQgdG8gYWNjb3VudCBmb3IgaXQsXG4vLyB0b28uIFdlIGNhbiByZW1vdmUgaXQgb25jZSB0eXBlIENhY2hlIE5vZGUgdHlwZSBpcyBtb3JlIHNldHRsZWQuXG5mdW5jdGlvbiBpc0RlZmVycmVkUnNjKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRhZyA9PT0gREVGRVJSRUQ7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZFJzYygpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHBlbmRpbmdSc2MgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopPT57XG4gICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgIHJlamVjdCA9IHJlajtcbiAgICB9KTtcbiAgICBwZW5kaW5nUnNjLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHBlbmRpbmdSc2MucmVzb2x2ZSA9ICh2YWx1ZSk9PntcbiAgICAgICAgaWYgKHBlbmRpbmdSc2Muc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZnVsZmlsbGVkUnNjID0gcGVuZGluZ1JzYztcbiAgICAgICAgICAgIGZ1bGZpbGxlZFJzYy5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgZnVsZmlsbGVkUnNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcGVuZGluZ1JzYy5yZWplY3QgPSAoZXJyb3IpPT57XG4gICAgICAgIGlmIChwZW5kaW5nUnNjLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdGVkUnNjID0gcGVuZGluZ1JzYztcbiAgICAgICAgICAgIHJlamVjdGVkUnNjLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgIHJlamVjdGVkUnNjLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcGVuZGluZ1JzYy50YWcgPSBERUZFUlJFRDtcbiAgICByZXR1cm4gcGVuZGluZ1JzYztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHByLW5hdmlnYXRpb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImFib3J0VGFzayIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwidXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3NlZ21lbnQiLCJyZXF1aXJlIiwiX21hdGNoc2VnbWVudHMiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJvbGRDYWNoZU5vZGUiLCJvbGRSb3V0ZXJTdGF0ZSIsIm5ld1JvdXRlclN0YXRlIiwicHJlZmV0Y2hEYXRhIiwicHJlZmV0Y2hIZWFkIiwib2xkUm91dGVyU3RhdGVDaGlsZHJlbiIsIm5ld1JvdXRlclN0YXRlQ2hpbGRyZW4iLCJwcmVmZXRjaERhdGFDaGlsZHJlbiIsIm9sZFBhcmFsbGVsUm91dGVzIiwicGFyYWxsZWxSb3V0ZXMiLCJwcmVmZXRjaFBhcmFsbGVsUm91dGVzIiwiTWFwIiwicGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4iLCJ0YXNrQ2hpbGRyZW4iLCJwYXJhbGxlbFJvdXRlS2V5IiwibmV3Um91dGVyU3RhdGVDaGlsZCIsIm9sZFJvdXRlclN0YXRlQ2hpbGQiLCJvbGRTZWdtZW50TWFwQ2hpbGQiLCJwcmVmZXRjaERhdGFDaGlsZCIsIm5ld1NlZ21lbnRDaGlsZCIsIm5ld1NlZ21lbnRLZXlDaGlsZCIsImNyZWF0ZVJvdXRlckNhY2hlS2V5Iiwib2xkU2VnbWVudENoaWxkIiwidW5kZWZpbmVkIiwib2xkQ2FjaGVOb2RlQ2hpbGQiLCJ0YXNrQ2hpbGQiLCJQQUdFX1NFR01FTlRfS0VZIiwic3Bhd25QZW5kaW5nVGFzayIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJzcGF3blJldXNlZFRhc2siLCJtYXRjaFNlZ21lbnQiLCJzcGF3blRhc2tGb3JNaXNzaW5nRGF0YSIsInNldCIsIm5ld0NhY2hlTm9kZUNoaWxkIiwibm9kZSIsIm5ld1NlZ21lbnRNYXBDaGlsZCIsInJvdXRlIiwibmV3Q2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJsb2FkaW5nIiwibGF6eURhdGFSZXNvbHZlZCIsInBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4iLCJjaGlsZHJlbiIsImJhc2VSb3V0ZXJTdGF0ZSIsIm5ld0NoaWxkcmVuIiwiY2xvbmUiLCJyb3V0ZXJTdGF0ZSIsInBlbmRpbmdDYWNoZU5vZGUiLCJjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlIiwicmV1c2VkUm91dGVyU3RhdGUiLCJ0YXNrIiwicmVzcG9uc2VQcm9taXNlIiwidGhlbiIsInJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsImZsaWdodERhdGFQYXRoIiwic2VnbWVudFBhdGgiLCJzbGljZSIsInNlcnZlclJvdXRlclN0YXRlIiwibGVuZ3RoIiwiZHluYW1pY0RhdGEiLCJkeW5hbWljSGVhZCIsIndyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2siLCJlcnJvciIsInJvb3RUYXNrIiwiaSIsInNlZ21lbnQiLCJ0YXNrU2VnbWVudCIsImZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCIsInRhc2tOb2RlIiwiZmluaXNoUGVuZGluZ0NhY2hlTm9kZSIsInNlcnZlckNoaWxkcmVuIiwiZHluYW1pY0RhdGFDaGlsZHJlbiIsInNlcnZlclJvdXRlclN0YXRlQ2hpbGQiLCJkeW5hbWljRGF0YUNoaWxkIiwicm91dGVyU3RhdGVDaGlsZHJlbiIsInJvdXRlclN0YXRlQ2hpbGQiLCJzZWdtZW50Q2hpbGQiLCJzZWdtZW50S2V5Q2hpbGQiLCJpc0xlYWZTZWdtZW50Iiwic2l6ZSIsIm1heWJlUHJlZmV0Y2hSc2MiLCJtYXliZVByZWZldGNoTG9hZGluZyIsImNyZWF0ZURlZmVycmVkUnNjIiwiY2FjaGVOb2RlIiwidGFza1N0YXRlIiwic2VydmVyU3RhdGUiLCJ0YXNrU3RhdGVDaGlsZHJlbiIsInNlcnZlclN0YXRlQ2hpbGRyZW4iLCJkYXRhQ2hpbGRyZW4iLCJ0YXNrU3RhdGVDaGlsZCIsInNlcnZlclN0YXRlQ2hpbGQiLCJkYXRhQ2hpbGQiLCJzZWdtZW50TWFwQ2hpbGQiLCJ0YXNrU2VnbWVudENoaWxkIiwidGFza1NlZ21lbnRLZXlDaGlsZCIsImNhY2hlTm9kZUNoaWxkIiwiYWJvcnRQZW5kaW5nQ2FjaGVOb2RlIiwiZHluYW1pY1NlZ21lbnREYXRhIiwiaXNEZWZlcnJlZFJzYyIsInJlc29sdmUiLCJ2YWx1ZXMiLCJyZWplY3QiLCJuZXdQYXJhbGxlbFJvdXRlcyIsInNob3VsZFVzZVByZWZldGNoIiwic3RhdHVzIiwiREVGRVJSRUQiLCJTeW1ib2wiLCJ0YWciLCJwZW5kaW5nUnNjIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsImZ1bGZpbGxlZFJzYyIsInJlamVjdGVkUnNjIiwicmVhc29uIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1709\n"));

/***/ }),

/***/ 2997:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchCacheEntryForInitialLoad: function() {\n        return createPrefetchCacheEntryForInitialLoad;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ 6808);\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ 6969);\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ 5910);\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ 4749);\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKey(url, nextUrl) {\n    const pathnameFromUrl = (0, _createhreffromurl.createHrefFromUrl)(url, false);\n    // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header\n    if (nextUrl) {\n        return nextUrl + \"%\" + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, buildId, prefetchCache, kind } = param;\n    let existingCacheEntry = undefined;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl);\n    const interceptionData = prefetchCache.get(interceptionCacheKey);\n    if (interceptionData) {\n        existingCacheEntry = interceptionData;\n    } else {\n        // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry\n        const prefetchCacheKey = createPrefetchCacheKey(url);\n        const prefetchData = prefetchCache.get(prefetchCacheKey);\n        if (prefetchData) {\n            existingCacheEntry = prefetchData;\n        }\n    }\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            return createLazyPrefetchEntry({\n                tree,\n                url,\n                buildId,\n                nextUrl,\n                prefetchCache,\n                // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                // rather than assuming the same intent as the previous entry, to be consistent with how we\n                // lazily create prefetch entries when intent is left unspecified.\n                kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        buildId,\n        nextUrl,\n        prefetchCache,\n        kind: kind || // in dev, there's never gonna be a prefetch entry so we want to prefetch here\n        ( true ? _routerreducertypes.PrefetchKind.AUTO : 0)\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache } = param;\n    const existingCacheKey = createPrefetchCacheKey(url);\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, nextUrl);\n    prefetchCache.set(newCacheKey, existingCacheEntry);\n    prefetchCache.delete(existingCacheKey);\n}\nfunction createPrefetchCacheEntryForInitialLoad(param) {\n    let { nextUrl, tree, prefetchCache, url, kind, data } = param;\n    const [, , , intercept] = data;\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = intercept ? createPrefetchCacheKey(url, nextUrl) : createPrefetchCacheKey(url);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, buildId, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, tree, nextUrl, buildId, kind).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            const [, , , intercepted] = prefetchResponse;\n            if (intercepted) {\n                prefixExistingPrefetchCacheEntry({\n                    url,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 30 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number(\"30\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime } = param;\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === \"auto\") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === \"full\") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBS0MsR0FBRyxLQUFLLENBQUNDLGdCQUFnQixPQUFPQSxlQUFlSCxZQUFXLElBQUtnQixzQkFBc0I7UUFDMUYsT0FBT2IsZUFBZTNDLG9CQUFvQjZDLHdCQUF3QixDQUFDZ0IsUUFBUSxHQUFHN0Qsb0JBQW9CNkMsd0JBQXdCLENBQUNDLEtBQUs7SUFDcEk7SUFDQSxzR0FBc0c7SUFDdEcsNEVBQTRFO0lBQzVFLHNEQUFzRDtJQUN0RCxJQUFJbkMsU0FBUyxRQUFRO1FBQ2pCLElBQUk4QixLQUFLQyxHQUFHLEtBQUtGLGVBQWVtQixxQkFBcUI7WUFDakQsT0FBTzNELG9CQUFvQjZDLHdCQUF3QixDQUFDaUIsS0FBSztRQUM3RDtJQUNKO0lBQ0EsaUdBQWlHO0lBQ2pHLElBQUluRCxTQUFTLFFBQVE7UUFDakIsSUFBSThCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZW1CLHFCQUFxQjtZQUNqRCxPQUFPM0Qsb0JBQW9CNkMsd0JBQXdCLENBQUNnQixRQUFRO1FBQ2hFO0lBQ0o7SUFDQSxPQUFPN0Qsb0JBQW9CNkMsd0JBQXdCLENBQUNVLE9BQU87QUFDL0Q7QUFFQSxJQUFJLENBQUMsT0FBT3RFLFFBQVE4RSxPQUFPLEtBQUssY0FBZSxPQUFPOUUsUUFBUThFLE9BQU8sS0FBSyxZQUFZOUUsUUFBUThFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzlFLFFBQVE4RSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakYsT0FBT0MsY0FBYyxDQUFDQyxRQUFROEUsT0FBTyxFQUFFLGNBQWM7UUFBRTdFLE9BQU87SUFBSztJQUNuRUgsT0FBT2tGLE1BQU0sQ0FBQ2hGLFFBQVE4RSxPQUFPLEVBQUU5RTtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFROEUsT0FBTztBQUNsQyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLmpzP2QwNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVQcmVmZXRjaENhY2hlRW50cnlGb3JJbml0aWFsTG9hZDogbnVsbCxcbiAgICBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeTogbnVsbCxcbiAgICBwcnVuZVByZWZldGNoQ2FjaGU6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5Rm9ySW5pdGlhbExvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5Rm9ySW5pdGlhbExvYWQ7XG4gICAgfSxcbiAgICBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeTtcbiAgICB9LFxuICAgIHBydW5lUHJlZmV0Y2hDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwcnVuZVByZWZldGNoQ2FjaGU7XG4gICAgfVxufSk7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuY29uc3QgX3ByZWZldGNocmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXJcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBjYWNoZSBrZXkgZm9yIHRoZSByb3V0ZXIgcHJlZmV0Y2ggY2FjaGVcbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBiZWluZyBuYXZpZ2F0ZWQgdG9cbiAqIEBwYXJhbSBuZXh0VXJsIC0gYW4gaW50ZXJuYWwgVVJMLCBwcmltYXJpbHkgdXNlZCBmb3IgaGFuZGxpbmcgcmV3cml0ZXMuIERlZmF1bHRzIHRvICcvJy5cbiAqIEByZXR1cm4gVGhlIGdlbmVyYXRlZCBwcmVmZXRjaCBjYWNoZSBrZXkuXG4gKi8gZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIG5leHRVcmwpIHtcbiAgICBjb25zdCBwYXRobmFtZUZyb21VcmwgPSAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKSh1cmwsIC8vIEVuc3VyZXMgdGhlIGhhc2ggaXMgbm90IHBhcnQgb2YgdGhlIGNhY2hlIGtleSBhcyBpdCBkb2VzIG5vdCBpbXBhY3QgdGhlIHNlcnZlciBmZXRjaFxuICAgIGZhbHNlKTtcbiAgICAvLyBuZXh0VXJsIGlzIHVzZWQgYXMgYSBjYWNoZSBrZXkgZGVsaW1pdGVyIHNpbmNlIGVudHJpZXMgY2FuIHZhcnkgYmFzZWQgb24gdGhlIE5leHQtVVJMIGhlYWRlclxuICAgIGlmIChuZXh0VXJsKSB7XG4gICAgICAgIHJldHVybiBuZXh0VXJsICsgXCIlXCIgKyBwYXRobmFtZUZyb21Vcmw7XG4gICAgfVxuICAgIHJldHVybiBwYXRobmFtZUZyb21Vcmw7XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeShwYXJhbSkge1xuICAgIGxldCB7IHVybCwgbmV4dFVybCwgdHJlZSwgYnVpbGRJZCwgcHJlZmV0Y2hDYWNoZSwga2luZCB9ID0gcGFyYW07XG4gICAgbGV0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHVuZGVmaW5lZDtcbiAgICAvLyBXZSBmaXJzdCBjaGVjayBpZiB0aGVyZSdzIGEgbW9yZSBzcGVjaWZpYyBpbnRlcmNlcHRpb24gcm91dGUgcHJlZmV0Y2ggZW50cnlcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2hlbiB3ZSBkZXRlY3QgYSBwcmVmZXRjaCB0aGF0IGNvcnJlc3BvbmRzIHdpdGggYW4gaW50ZXJjZXB0aW9uIHJvdXRlLCB3ZSBwcmVmaXggaXQgd2l0aCBuZXh0VXJsIChzZWUgYGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlgKVxuICAgIC8vIHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBhZ2VzIHRoYXQgbWF5IGhhdmUgdGhlIHNhbWUgVVJMIGJ1dCByZW5kZXIgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIGBOZXh0LVVSTGAgaGVhZGVyLlxuICAgIGNvbnN0IGludGVyY2VwdGlvbkNhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIG5leHRVcmwpO1xuICAgIGNvbnN0IGludGVyY2VwdGlvbkRhdGEgPSBwcmVmZXRjaENhY2hlLmdldChpbnRlcmNlcHRpb25DYWNoZUtleSk7XG4gICAgaWYgKGludGVyY2VwdGlvbkRhdGEpIHtcbiAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5ID0gaW50ZXJjZXB0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBkb250IGZpbmQgYSBtb3JlIHNwZWNpZmljIGludGVyY2VwdGlvbiByb3V0ZSBwcmVmZXRjaCBlbnRyeSwgd2UgY2hlY2sgZm9yIGEgcmVndWxhciBwcmVmZXRjaCBlbnRyeVxuICAgICAgICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwpO1xuICAgICAgICBjb25zdCBwcmVmZXRjaERhdGEgPSBwcmVmZXRjaENhY2hlLmdldChwcmVmZXRjaENhY2hlS2V5KTtcbiAgICAgICAgaWYgKHByZWZldGNoRGF0YSkge1xuICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hEYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAgICAgLy8gR3JhYiB0aGUgbGF0ZXN0IHN0YXR1cyBvZiB0aGUgY2FjaGUgZW50cnkgYW5kIHVwZGF0ZSBpdFxuICAgICAgICBleGlzdGluZ0NhY2hlRW50cnkuc3RhdHVzID0gZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKGV4aXN0aW5nQ2FjaGVFbnRyeSk7XG4gICAgICAgIC8vIHdoZW4gYGtpbmRgIGlzIHByb3ZpZGVkLCBhbiBleHBsaWNpdCBwcmVmZXRjaCB3YXMgcmVxdWVzdGVkLlxuICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdGVkIHByZWZldGNoIGlzIFwiZnVsbFwiIGFuZCB0aGUgY3VycmVudCBjYWNoZSBlbnRyeSB3YXNuJ3QsIHdlIHdhbnQgdG8gcmUtcHJlZmV0Y2ggd2l0aCB0aGUgbmV3IGludGVudFxuICAgICAgICBjb25zdCBzd2l0Y2hlZFRvRnVsbFByZWZldGNoID0gZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgIT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkZVTEwgJiYga2luZCA9PT0gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuRlVMTDtcbiAgICAgICAgaWYgKHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYnVpbGRJZCxcbiAgICAgICAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBleHBsaWNpdCBwcmVmZXRjaCBraW5kLCB3ZSB3YW50IHRvIHNldCBhIHRlbXBvcmFyeSBraW5kXG4gICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYXNzdW1pbmcgdGhlIHNhbWUgaW50ZW50IGFzIHRoZSBwcmV2aW91cyBlbnRyeSwgdG8gYmUgY29uc2lzdGVudCB3aXRoIGhvdyB3ZVxuICAgICAgICAgICAgICAgIC8vIGxhemlseSBjcmVhdGUgcHJlZmV0Y2ggZW50cmllcyB3aGVuIGludGVudCBpcyBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQgIT0gbnVsbCA/IGtpbmQgOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5URU1QT1JBUllcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB3YXMgbWFya2VkIGFzIHRlbXBvcmFyeSwgaXQgbWVhbnMgaXQgd2FzIGxhemlseSBjcmVhdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBnZXQgYW4gZW50cnksXG4gICAgICAgIC8vIHdoZXJlIHdlIGRpZG4ndCBoYXZlIHRoZSBwcmVmZXRjaCBpbnRlbnQuIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGludGVudCAoaW4gYGtpbmRgKSwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGVudHJ5IHRvIHRoZSBtb3JlIGFjY3VyYXRlIGtpbmQuXG4gICAgICAgIGlmIChraW5kICYmIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID09PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5URU1QT1JBUlkpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgdGhlIGV4aXN0aW5nIGVudHJ5IHdlIGZvdW5kIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSByZXR1cm4gaXQuXG4gICAgICAgIHJldHVybiBleGlzdGluZ0NhY2hlRW50cnk7XG4gICAgfVxuICAgIC8vIElmIHdlIGRpZG4ndCByZXR1cm4gYW4gZW50cnksIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICAgICAgdHJlZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBidWlsZElkLFxuICAgICAgICBuZXh0VXJsLFxuICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICBraW5kOiBraW5kIHx8IC8vIGluIGRldiwgdGhlcmUncyBuZXZlciBnb25uYSBiZSBhIHByZWZldGNoIGVudHJ5IHNvIHdlIHdhbnQgdG8gcHJlZmV0Y2ggaGVyZVxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE8gOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5URU1QT1JBUlkpXG4gICAgfSk7XG59XG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqLyBmdW5jdGlvbiBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeShwYXJhbSkge1xuICAgIGxldCB7IHVybCwgbmV4dFVybCwgcHJlZmV0Y2hDYWNoZSB9ID0gcGFyYW07XG4gICAgY29uc3QgZXhpc3RpbmdDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsKTtcbiAgICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChleGlzdGluZ0NhY2hlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgICAgICAvLyBuby1vcCAtLSB0aGVyZSB3YXNuJ3QgYW4gZW50cnkgdG8gbW92ZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0NhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIG5leHRVcmwpO1xuICAgIHByZWZldGNoQ2FjaGUuc2V0KG5ld0NhY2hlS2V5LCBleGlzdGluZ0NhY2hlRW50cnkpO1xuICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGV4aXN0aW5nQ2FjaGVLZXkpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5Rm9ySW5pdGlhbExvYWQocGFyYW0pIHtcbiAgICBsZXQgeyBuZXh0VXJsLCB0cmVlLCBwcmVmZXRjaENhY2hlLCB1cmwsIGtpbmQsIGRhdGEgfSA9IHBhcmFtO1xuICAgIGNvbnN0IFssICwgLCBpbnRlcmNlcHRdID0gZGF0YTtcbiAgICAvLyBpZiB0aGUgcHJlZmV0Y2ggY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHVzZSB0aGUgbmV4dFVybCB0byBwcmVmaXggdGhlIGNhY2hlIGtleVxuICAgIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBpbnRlcmNlcHQgPyBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwgbmV4dFVybCkgOiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCk7XG4gICAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgICAgIGRhdGE6IFByb21pc2UucmVzb2x2ZShkYXRhKSxcbiAgICAgICAga2luZCxcbiAgICAgICAgcHJlZmV0Y2hUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBsYXN0VXNlZFRpbWU6IERhdGUubm93KCksXG4gICAgICAgIGtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgc3RhdHVzOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaFxuICAgIH07XG4gICAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSk7XG4gICAgcmV0dXJuIHByZWZldGNoRW50cnk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovIGZ1bmN0aW9uIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsLCBraW5kLCB0cmVlLCBuZXh0VXJsLCBidWlsZElkLCBwcmVmZXRjaENhY2hlIH0gPSBwYXJhbTtcbiAgICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwpO1xuICAgIC8vIGluaXRpYXRlcyB0aGUgZmV0Y2ggcmVxdWVzdCBmb3IgdGhlIHByZWZldGNoIGFuZCBhdHRhY2hlcyBhIGxpc3RlbmVyXG4gICAgLy8gdG8gdGhlIHByb21pc2UgdG8gdXBkYXRlIHRoZSBwcmVmZXRjaCBjYWNoZSBlbnRyeSB3aGVuIHRoZSBwcm9taXNlIHJlc29sdmVzIChpZiBuZWNlc3NhcnkpXG4gICAgY29uc3QgZGF0YSA9IF9wcmVmZXRjaHJlZHVjZXIucHJlZmV0Y2hRdWV1ZS5lbnF1ZXVlKCgpPT4oMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkodXJsLCB0cmVlLCBuZXh0VXJsLCBidWlsZElkLCBraW5kKS50aGVuKChwcmVmZXRjaFJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgLy8gVE9ETzogYGZldGNoU2VydmVyUmVzcG9uc2VgIHNob3VsZCBiZSBtb3JlIHRpZ2hseSBjb3VwbGVkIHRvIHRoZXNlIHByZWZldGNoIGNhY2hlIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIGRyaWZ0IGJldHdlZW4gdGhpcyBjYWNoZSBrZXkgcHJlZml4aW5nIGxvZ2ljXG4gICAgICAgICAgICAvLyAod2hpY2ggaXMgY3VycmVudGx5IGRpcmVjdGx5IGluZmx1ZW5jZWQgYnkgdGhlIHNlcnZlciByZXNwb25zZSlcbiAgICAgICAgICAgIGNvbnN0IFssICwgLCBpbnRlcmNlcHRlZF0gPSBwcmVmZXRjaFJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKGludGVyY2VwdGVkKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmVmZXRjaFJlc3BvbnNlO1xuICAgICAgICB9KSk7XG4gICAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGtpbmQsXG4gICAgICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgbGFzdFVzZWRUaW1lOiBudWxsLFxuICAgICAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgICAgIHN0YXR1czogX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgICB9O1xuICAgIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpO1xuICAgIHJldHVybiBwcmVmZXRjaEVudHJ5O1xufVxuZnVuY3Rpb24gcHJ1bmVQcmVmZXRjaENhY2hlKHByZWZldGNoQ2FjaGUpIHtcbiAgICBmb3IgKGNvbnN0IFtocmVmLCBwcmVmZXRjaENhY2hlRW50cnldIG9mIHByZWZldGNoQ2FjaGUpe1xuICAgICAgICBpZiAoZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHByZWZldGNoQ2FjaGVFbnRyeSkgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWQpIHtcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGhyZWYpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlc2UgdmFsdWVzIGFyZSBzZXQgYnkgYGRlZmluZS1lbnYtcGx1Z2luYCAoYmFzZWQgb24gYG5leHRDb25maWcuZXhwZXJpbWVudGFsLnN0YWxlVGltZXNgKVxuLy8gYW5kIGRlZmF1bHQgdG8gNSBtaW51dGVzIChzdGF0aWMpIC8gMzAgc2Vjb25kcyAoZHluYW1pYylcbmNvbnN0IERZTkFNSUNfU1RBTEVUSU1FX01TID0gTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FKSAqIDEwMDA7XG5jb25zdCBTVEFUSUNfU1RBTEVUSU1FX01TID0gTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUpICogMTAwMDtcbmZ1bmN0aW9uIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwYXJhbSkge1xuICAgIGxldCB7IGtpbmQsIHByZWZldGNoVGltZSwgbGFzdFVzZWRUaW1lIH0gPSBwYXJhbTtcbiAgICAvLyBXZSB3aWxsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gdGhlIGBkeW5hbWljYCBzdGFsZXRpbWUgd2luZG93LlxuICAgIGlmIChEYXRlLm5vdygpIDwgKGxhc3RVc2VkVGltZSAhPSBudWxsID8gbGFzdFVzZWRUaW1lIDogcHJlZmV0Y2hUaW1lKSArIERZTkFNSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICAgIHJldHVybiBsYXN0VXNlZFRpbWUgPyBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZSA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoO1xuICAgIH1cbiAgICAvLyBGb3IgXCJhdXRvXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSBvbmx5IHRoZSBsb2FkaW5nIGJvdW5kYXJ5IGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAgIC8vIEEgc3RhbGUgZW50cnkgd2lsbCBvbmx5IHJlLXVzZSB0aGUgYGxvYWRpbmdgIGJvdW5kYXJ5LCBub3QgdGhlIGZ1bGwgZGF0YS5cbiAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIFwibGF6eSBmZXRjaFwiIGZvciB0aGUgZnVsbCBkYXRhLlxuICAgIGlmIChraW5kID09PSBcImF1dG9cIikge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3IgXCJmdWxsXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gYHN0YXRpY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgICBpZiAoa2luZCA9PT0gXCJmdWxsXCIpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWQ7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZldGNoLWNhY2hlLXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeUZvckluaXRpYWxMb2FkIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfY3JlYXRlaHJlZmZyb211cmwiLCJyZXF1aXJlIiwiX2ZldGNoc2VydmVycmVzcG9uc2UiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwiX3ByZWZldGNocmVkdWNlciIsImNyZWF0ZVByZWZldGNoQ2FjaGVLZXkiLCJ1cmwiLCJuZXh0VXJsIiwicGF0aG5hbWVGcm9tVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwYXJhbSIsInRyZWUiLCJidWlsZElkIiwicHJlZmV0Y2hDYWNoZSIsImtpbmQiLCJleGlzdGluZ0NhY2hlRW50cnkiLCJ1bmRlZmluZWQiLCJpbnRlcmNlcHRpb25DYWNoZUtleSIsImludGVyY2VwdGlvbkRhdGEiLCJwcmVmZXRjaENhY2hlS2V5IiwicHJlZmV0Y2hEYXRhIiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSIsIlRFTVBPUkFSWSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkFVVE8iLCJwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSIsImV4aXN0aW5nQ2FjaGVLZXkiLCJuZXdDYWNoZUtleSIsInNldCIsImRlbGV0ZSIsImRhdGEiLCJpbnRlcmNlcHQiLCJwcmVmZXRjaEVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInByZWZldGNoVGltZSIsIkRhdGUiLCJub3ciLCJsYXN0VXNlZFRpbWUiLCJrZXkiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJmcmVzaCIsInByZWZldGNoUXVldWUiLCJlbnF1ZXVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsInRoZW4iLCJwcmVmZXRjaFJlc3BvbnNlIiwiaW50ZXJjZXB0ZWQiLCJocmVmIiwicHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhwaXJlZCIsIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiTnVtYmVyIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUiLCJTVEFUSUNfU1RBTEVUSU1FX01TIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSIsInJldXNhYmxlIiwic3RhbGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2997\n"));

/***/ }),

/***/ 1142:
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js ***!
  \**************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"fastRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return fastRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ 6969);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 6808);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 8082);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 8927);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 1468);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 5013);\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ 3333);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 7679);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 8249);\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ 7246);\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction fastRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        state.tree[0],\n        state.tree[1],\n        state.tree[2],\n        \"refetch\"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log(\"REFRESH FAILED\");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                \"\"\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction fastRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst fastRefreshReducer =  false ? 0 : fastRefreshReducerImpl;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fast-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmFzdC1yZWZyZXNoLXJlZHVjZXIuanM/MTNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZhc3RSZWZyZXNoUmVkdWNlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFzdFJlZnJlc2hSZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX2NyZWF0ZWhyZWZmcm9tdXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xuY29uc3QgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSA9IHJlcXVpcmUoXCIuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZVwiKTtcbmNvbnN0IF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQgPSByZXF1aXJlKFwiLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXRcIik7XG5jb25zdCBfbmF2aWdhdGVyZWR1Y2VyID0gcmVxdWlyZShcIi4vbmF2aWdhdGUtcmVkdWNlclwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2FwcGx5ZmxpZ2h0ZGF0YSA9IHJlcXVpcmUoXCIuLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9hcHByb3V0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlclwiKTtcbmNvbnN0IF9oYW5kbGVzZWdtZW50bWlzbWF0Y2ggPSByZXF1aXJlKFwiLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2hcIik7XG5jb25zdCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlID0gcmVxdWlyZShcIi4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWVcIik7XG4vLyBBIHZlcnNpb24gb2YgcmVmcmVzaCByZWR1Y2VyIHRoYXQga2VlcHMgdGhlIGNhY2hlIGFyb3VuZCBpbnN0ZWFkIG9mIHdpcGluZyBhbGwgb2YgaXQuXG5mdW5jdGlvbiBmYXN0UmVmcmVzaFJlZHVjZXJJbXBsKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IG9yaWdpbiB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IG11dGFibGUgPSB7fTtcbiAgICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsO1xuICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICAgIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gKDAsIF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUuaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKShzdGF0ZS50cmVlKTtcbiAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gICAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgIGNhY2hlLmxhenlEYXRhID0gKDAsIF9mZXRjaHNlcnZlcnJlc3BvbnNlLmZldGNoU2VydmVyUmVzcG9uc2UpKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwgW1xuICAgICAgICBzdGF0ZS50cmVlWzBdLFxuICAgICAgICBzdGF0ZS50cmVlWzFdLFxuICAgICAgICBzdGF0ZS50cmVlWzJdLFxuICAgICAgICBcInJlZmV0Y2hcIlxuICAgIF0sIGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsIHN0YXRlLmJ1aWxkSWQpO1xuICAgIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgbGV0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSBwYXJhbTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVyZWR1Y2VyLmhhbmRsZUV4dGVybmFsVXJsKShzdGF0ZSwgbXV0YWJsZSwgZmxpZ2h0RGF0YSwgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgICAgICBmb3IgKGNvbnN0IGZsaWdodERhdGFQYXRoIG9mIGZsaWdodERhdGEpe1xuICAgICAgICAgICAgLy8gRmxpZ2h0RGF0YVBhdGggd2l0aCBtb3JlIHRoYW4gdHdvIGl0ZW1zIG1lYW5zIHVuZXhwZWN0ZWQgRmxpZ2h0IGRhdGEgd2FzIHJldHVybmVkXG4gICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSRUZSRVNIIEZBSUxFRFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgcnNjIGZvciB0aGUgcm9vdC5cbiAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgXSwgY3VycmVudFRyZWUsIHRyZWVQYXRjaCwgc3RhdGUuY2Fub25pY2FsVXJsKTtcbiAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlc2VnbWVudG1pc21hdGNoLmhhbmRsZVNlZ21lbnRNaXNtYXRjaCkoc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dC5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5oYW5kbGVFeHRlcm5hbFVybCkoc3RhdGUsIG11dGFibGUsIGhyZWYsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKShjYW5vbmljYWxVcmxPdmVycmlkZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwcGxpZWQgPSAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKGN1cnJlbnRDYWNoZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgIGlmIChhcHBsaWVkKSB7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWY7XG4gICAgICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKCk9PnN0YXRlKTtcbn1cbmZ1bmN0aW9uIGZhc3RSZWZyZXNoUmVkdWNlck5vb3Aoc3RhdGUsIF9hY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBmYXN0UmVmcmVzaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmYXN0UmVmcmVzaFJlZHVjZXJOb29wIDogZmFzdFJlZnJlc2hSZWR1Y2VySW1wbDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFzdC1yZWZyZXNoLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImZhc3RSZWZyZXNoUmVkdWNlciIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwicmVxdWlyZSIsIl9jcmVhdGVocmVmZnJvbXVybCIsIl9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX25hdmlnYXRlcmVkdWNlciIsIl9oYW5kbGVtdXRhYmxlIiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsIl9hcHByb3V0ZXIiLCJfaGFuZGxlc2VnbWVudG1pc21hdGNoIiwiX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSIsImZhc3RSZWZyZXNoUmVkdWNlckltcGwiLCJzdGF0ZSIsImFjdGlvbiIsIm9yaWdpbiIsIm11dGFibGUiLCJocmVmIiwiY2Fub25pY2FsVXJsIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiaW5jbHVkZU5leHRVcmwiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJ0cmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibmV4dFVybCIsImJ1aWxkSWQiLCJ0aGVuIiwicGFyYW0iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImZhc3RSZWZyZXNoUmVkdWNlck5vb3AiLCJfYWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1142\n"));

/***/ }),

/***/ 1719:
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js ***!
  \************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findHeadInCache\", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ 2869);\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, \"\");\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + \"/\" + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcxOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyxzQ0FBNEI7QUFDbEUsU0FBU0YsZ0JBQWdCRyxLQUFLLEVBQUVDLGNBQWM7SUFDMUMsT0FBT0Msb0JBQW9CRixPQUFPQyxnQkFBZ0I7QUFDdEQ7QUFDQSxTQUFTQyxvQkFBb0JGLEtBQUssRUFBRUMsY0FBYyxFQUFFRSxTQUFTO0lBQ3pELE1BQU1DLGFBQWFiLE9BQU9jLElBQUksQ0FBQ0osZ0JBQWdCSyxNQUFNLEtBQUs7SUFDMUQsSUFBSUYsWUFBWTtRQUNaLDBFQUEwRTtRQUMxRSxPQUFPO1lBQ0hKO1lBQ0FHO1NBQ0g7SUFDTDtJQUNBLElBQUksTUFBTUksT0FBT04sZUFBZTtRQUM1QixNQUFNLENBQUNPLFNBQVNDLG9CQUFvQixHQUFHUixjQUFjLENBQUNNLElBQUk7UUFDMUQsTUFBTUcsa0JBQWtCVixNQUFNQyxjQUFjLENBQUNMLEdBQUcsQ0FBQ1c7UUFDakQsSUFBSSxDQUFDRyxpQkFBaUI7WUFDbEI7UUFDSjtRQUNBLE1BQU1DLFdBQVcsQ0FBQyxHQUFHYixzQkFBc0JjLG9CQUFvQixFQUFFSjtRQUNqRSxNQUFNSyxZQUFZSCxnQkFBZ0JkLEdBQUcsQ0FBQ2U7UUFDdEMsSUFBSSxDQUFDRSxXQUFXO1lBQ1o7UUFDSjtRQUNBLE1BQU1DLE9BQU9aLG9CQUFvQlcsV0FBV0oscUJBQXFCTixZQUFZLE1BQU1RO1FBQ25GLElBQUlHLE1BQU07WUFDTixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT3JCLFFBQVFzQixPQUFPLEtBQUssY0FBZSxPQUFPdEIsUUFBUXNCLE9BQU8sS0FBSyxZQUFZdEIsUUFBUXNCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3RCLFFBQVFzQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLekIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRc0IsT0FBTyxFQUFFLGNBQWM7UUFBRXJCLE9BQU87SUFBSztJQUNuRUgsT0FBTzBCLE1BQU0sQ0FBQ3hCLFFBQVFzQixPQUFPLEVBQUV0QjtJQUMvQnlCLE9BQU96QixPQUFPLEdBQUdBLFFBQVFzQixPQUFPO0FBQ2xDLEVBRUEsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlLmpzPzc1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmaW5kSGVhZEluQ2FjaGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZTtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleVwiKTtcbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICByZXR1cm4gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsIFwiXCIpO1xufVxuZnVuY3Rpb24gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsIGtleVByZWZpeCkge1xuICAgIGNvbnN0IGlzTGFzdEl0ZW0gPSBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwO1xuICAgIGlmIChpc0xhc3RJdGVtKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGVudGlyZSBDYWNoZSBOb2RlIG9mIHRoZSBzZWdtZW50IHdob3NlIGhlYWQgd2Ugd2lsbCByZW5kZXIuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGtleVByZWZpeFxuICAgICAgICBdO1xuICAgIH1cbiAgICBmb3IoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKXtcbiAgICAgICAgY29uc3QgW3NlZ21lbnQsIGNoaWxkUGFyYWxsZWxSb3V0ZXNdID0gcGFyYWxsZWxSb3V0ZXNba2V5XTtcbiAgICAgICAgY29uc3QgY2hpbGRTZWdtZW50TWFwID0gY2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICghY2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnQpO1xuICAgICAgICBjb25zdCBjYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFjYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBmaW5kSGVhZEluQ2FjaGVJbXBsKGNhY2hlTm9kZSwgY2hpbGRQYXJhbGxlbFJvdXRlcywga2V5UHJlZml4ICsgXCIvXCIgKyBjYWNoZUtleSk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC1oZWFkLWluLWNhY2hlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJmaW5kSGVhZEluQ2FjaGUiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJyZXF1aXJlIiwiY2FjaGUiLCJwYXJhbGxlbFJvdXRlcyIsImZpbmRIZWFkSW5DYWNoZUltcGwiLCJrZXlQcmVmaXgiLCJpc0xhc3RJdGVtIiwia2V5cyIsImxlbmd0aCIsImtleSIsInNlZ21lbnQiLCJjaGlsZFBhcmFsbGVsUm91dGVzIiwiY2hpbGRTZWdtZW50TWFwIiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImNhY2hlTm9kZSIsIml0ZW0iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1719\n"));

/***/ }),

/***/ 3392:
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js ***!
  \***********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSegmentValue\", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsZ0JBQWdCQyxPQUFPO0lBQzVCLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBV0EsT0FBTyxDQUFDLEVBQUUsR0FBR0E7QUFDakQ7QUFFQSxJQUFJLENBQUMsT0FBT0wsUUFBUVEsT0FBTyxLQUFLLGNBQWUsT0FBT1IsUUFBUVEsT0FBTyxLQUFLLFlBQVlSLFFBQVFRLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1IsUUFBUVEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1gsT0FBT0MsY0FBYyxDQUFDQyxRQUFRUSxPQUFPLEVBQUUsY0FBYztRQUFFUCxPQUFPO0lBQUs7SUFDbkVILE9BQU9ZLE1BQU0sQ0FBQ1YsUUFBUVEsT0FBTyxFQUFFUjtJQUMvQlcsT0FBT1gsT0FBTyxHQUFHQSxRQUFRUSxPQUFPO0FBQ2xDLEVBRUEsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWUuanM/NGU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNlZ21lbnRWYWx1ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U2VnbWVudFZhbHVlO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZ2V0U2VnbWVudFZhbHVlKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtc2VnbWVudC12YWx1ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0U2VnbWVudFZhbHVlIiwic2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3392\n"));

/***/ }),

/***/ 7246:
/*!********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js ***!
  \********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ 942);\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === \"di\" || segment[2] === \"ci\")) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === \"string\" && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI0Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgscUVBQW9FO0lBQ2hFSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyxnRUFBdUQ7QUFDM0YsU0FBU0Ysa0NBQWtDRyxLQUFLO0lBQzVDLElBQUksQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNoQyx3R0FBd0c7SUFDeEcsSUFBSUcsTUFBTUMsT0FBTyxDQUFDSCxZQUFhQSxDQUFBQSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVFBLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1FBQ3hFLE9BQU87SUFDWDtJQUNBLG9FQUFvRTtJQUNwRSxJQUFJLE9BQU9BLFlBQVksWUFBWSxDQUFDLEdBQUdILG9CQUFvQk8sMEJBQTBCLEVBQUVKLFVBQVU7UUFDN0YsT0FBTztJQUNYO0lBQ0EsK0NBQStDO0lBQy9DLElBQUlDLGdCQUFnQjtRQUNoQixJQUFJLE1BQU1JLE9BQU9KLGVBQWU7WUFDNUIsSUFBSUwsa0NBQWtDSyxjQUFjLENBQUNJLElBQUksR0FBRztnQkFDeEQsT0FBTztZQUNYO1FBQ0o7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPYixRQUFRYyxPQUFPLEtBQUssY0FBZSxPQUFPZCxRQUFRYyxPQUFPLEtBQUssWUFBWWQsUUFBUWMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPZCxRQUFRYyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRYyxPQUFPLEVBQUUsY0FBYztRQUFFYixPQUFPO0lBQUs7SUFDbkVILE9BQU9rQixNQUFNLENBQUNoQixRQUFRYyxPQUFPLEVBQUVkO0lBQy9CaUIsT0FBT2pCLE9BQU8sR0FBR0EsUUFBUWMsT0FBTztBQUNsQyxFQUVBLGtFQUFrRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLmpzPzEwYzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcmNlcHRpb25yb3V0ZXMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2VydmVyL2Z1dHVyZS9oZWxwZXJzL2ludGVyY2VwdGlvbi1yb3V0ZXNcIik7XG5mdW5jdGlvbiBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUocGFyYW0pIHtcbiAgICBsZXQgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzXSA9IHBhcmFtO1xuICAgIC8vIElmIHdlIGhhdmUgYSBkeW5hbWljIHNlZ21lbnQsIGl0J3MgbWFya2VkIGFzIGFuIGludGVyY2VwdGlvbiByb3V0ZSBieSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGBpYCBzdWZmaXguXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkgJiYgKHNlZ21lbnRbMl0gPT09IFwiZGlcIiB8fCBzZWdtZW50WzJdID09PSBcImNpXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJZiBzZWdtZW50IGlzIG5vdCBhbiBhcnJheSwgYXBwbHkgdGhlIGV4aXN0aW5nIHN0cmluZy1iYXNlZCBjaGVja1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIiAmJiAoMCwgX2ludGVyY2VwdGlvbnJvdXRlcy5pc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCkoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBwYXJhbGxlbFJvdXRlcyBpZiB0aGV5IGV4aXN0XG4gICAgaWYgKHBhcmFsbGVsUm91dGVzKSB7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpe1xuICAgICAgICAgICAgaWYgKGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShwYXJhbGxlbFJvdXRlc1trZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsIl9pbnRlcmNlcHRpb25yb3V0ZXMiLCJyZXF1aXJlIiwicGFyYW0iLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImtleSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7246\n"));

/***/ }),

/***/ 1468:
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js ***!
  \**********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ 6969);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 6808);\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ 973);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 8082);\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ 5805);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 8927);\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ 5910);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 5013);\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ 3333);\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ 4749);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 7679);\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ 8270);\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ 1709);\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ 2997);\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ 8184);\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === \"\") {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nconst navigateReducer =  false ? 0 : navigateReducer_noPPR;\n// This is the implementation when PPR is disabled. We can assume its behavior\n// is relatively stable because it's been running in production for a while.\nfunction navigateReducer_noPPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === \"push\";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById(\"__next-page-redirect\")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                \"\",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                let applied = false;\n                if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                    // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                    // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                    // while copying over the `loading` for the segment that contains the page data.\n                    // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                    applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                    // since we re-used the stale cache's loading state & refreshed the data,\n                    // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                    prefetchValues.lastUsedTime = Date.now();\n                } else {\n                    applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                }\n                const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                if (hardNavigate) {\n                    // Copy rsc for the root node of the cache.\n                    cache.rsc = currentCache.rsc;\n                    cache.prefetchRsc = currentCache.prefetchRsc;\n                    (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                    // Ensure the existing cache value is used when the cache was not invalidated.\n                    mutable.cache = cache;\n                } else if (applied) {\n                    mutable.cache = cache;\n                    // If we applied the cache, we update the \"current cache\" value so any other\n                    // segments in the FlightDataPath will be able to reference the updated cache.\n                    currentCache = cache;\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\n// This is the experimental PPR implementation. It's closer to the behavior we\n// want, but is likelier to include accidental regressions because it rewrites\n// existing functionality.\nfunction navigateReducer_PPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === \"push\";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride, _postponed] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById(\"__next-page-redirect\")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        // TODO: In practice, this is always a single item array. We probably\n        // aren't going to every send multiple segments, at least not in this\n        // format. So we could remove the extra wrapper for now until\n        // that settles.\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                \"\",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                if (// will always send back a static response that's rendered from\n                // the root. If for some reason it doesn't, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via updateCacheNodeOnNavigation. The current structure is just\n                // an incremental step.\n                flightDataPath.length === 3) {\n                    const prefetchedTree = flightDataPath[0];\n                    const seedData = flightDataPath[1];\n                    const head = flightDataPath[2];\n                    const task = (0, _pprnavigations.updateCacheNodeOnNavigation)(currentCache, currentTree, prefetchedTree, seedData, head);\n                    if (task !== null && task.node !== null) {\n                        // We've created a new Cache Node tree that contains a prefetched\n                        // version of the next page. This can be rendered instantly.\n                        // Use the tree computed by updateCacheNodeOnNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        // The prefetched tree has dynamic holes in it. We initiate a\n                        // dynamic request to fill them in.\n                        //\n                        // Do not block on the result. We'll immediately render the Cache\n                        // Node tree and suspend on the dynamic parts. When the request\n                        // comes in, we'll fill in missing data and ping React to\n                        // re-render. Unlike the lazy fetching model in the non-PPR\n                        // implementation, this is modeled as a single React update +\n                        // streaming, rather than multiple top-level updates. (However,\n                        // even in the new model, we'll still need to sometimes update the\n                        // root multiple times per navigation, like if the server sends us\n                        // a different response than we expected. For now, we revert back\n                        // to the lazy fetching mechanism in that case.)\n                        (0, _pprnavigations.listenForDynamicRequest)(task, (0, _fetchserverresponse.fetchServerResponse)(url, currentTree, state.nextUrl, state.buildId));\n                        mutable.cache = newCache;\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = prefetchedTree;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there's no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache's loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = Date.now();\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the \"current cache\" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQ3ZCM0MsUUFBUTBDLFlBQVksR0FBR0E7UUFDdkIsT0FBTyxDQUFDLEdBQUduRCxlQUFlZ0IsYUFBYSxFQUFFUixPQUFPQztJQUNwRCxHQUFHLElBQUlEO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBTzNCLFFBQVFrSSxPQUFPLEtBQUssY0FBZSxPQUFPbEksUUFBUWtJLE9BQU8sS0FBSyxZQUFZbEksUUFBUWtJLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xJLFFBQVFrSSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckksT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0ksT0FBTyxFQUFFLGNBQWM7UUFBRWpJLE9BQU87SUFBSztJQUNuRUgsT0FBT3NJLE1BQU0sQ0FBQ3BJLFFBQVFrSSxPQUFPLEVBQUVsSTtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRa0ksT0FBTztBQUNsQyxFQUVBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXIuanM/ZDgxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGhhbmRsZUV4dGVybmFsVXJsOiBudWxsLFxuICAgIG5hdmlnYXRlUmVkdWNlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBoYW5kbGVFeHRlcm5hbFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybDtcbiAgICB9LFxuICAgIG5hdmlnYXRlUmVkdWNlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0ZVJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfZmV0Y2hzZXJ2ZXJyZXNwb25zZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG5jb25zdCBfaW52YWxpZGF0ZWNhY2hlYmVsb3dmbGlnaHRzZWdtZW50cGF0aCA9IHJlcXVpcmUoXCIuLi9pbnZhbGlkYXRlLWNhY2hlLWJlbG93LWZsaWdodC1zZWdtZW50cGF0aFwiKTtcbmNvbnN0IF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG5jb25zdCBfc2hvdWxkaGFyZG5hdmlnYXRlID0gcmVxdWlyZShcIi4uL3Nob3VsZC1oYXJkLW5hdmlnYXRlXCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbmNvbnN0IF9yb3V0ZXJyZWR1Y2VydHlwZXMgPSByZXF1aXJlKFwiLi4vcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBfaGFuZGxlbXV0YWJsZSA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtbXV0YWJsZVwiKTtcbmNvbnN0IF9hcHBseWZsaWdodGRhdGEgPSByZXF1aXJlKFwiLi4vYXBwbHktZmxpZ2h0LWRhdGFcIik7XG5jb25zdCBfcHJlZmV0Y2hyZWR1Y2VyID0gcmVxdWlyZShcIi4vcHJlZmV0Y2gtcmVkdWNlclwiKTtcbmNvbnN0IF9hcHByb3V0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlclwiKTtcbmNvbnN0IF9zZWdtZW50ID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudFwiKTtcbmNvbnN0IF9wcHJuYXZpZ2F0aW9ucyA9IHJlcXVpcmUoXCIuLi9wcHItbmF2aWdhdGlvbnNcIik7XG5jb25zdCBfcHJlZmV0Y2hjYWNoZXV0aWxzID0gcmVxdWlyZShcIi4uL3ByZWZldGNoLWNhY2hlLXV0aWxzXCIpO1xuY29uc3QgX2NsZWFyY2FjaGVub2RlZGF0YWZvcnNlZ21lbnRwYXRoID0gcmVxdWlyZShcIi4uL2NsZWFyLWNhY2hlLW5vZGUtZGF0YS1mb3Itc2VnbWVudC1wYXRoXCIpO1xuZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIHVybCwgcGVuZGluZ1B1c2gpIHtcbiAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSB0cnVlO1xuICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXJsO1xuICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaDtcbiAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKDAsIF9oYW5kbGVtdXRhYmxlLmhhbmRsZU11dGFibGUpKHN0YXRlLCBtdXRhYmxlKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2goZmxpZ2h0Um91dGVyUGF0Y2gpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJQYXRjaDtcbiAgICBpZiAoT2JqZWN0LmtleXMocGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHNlZ21lbnRcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgcGFyYWxsZWxSb3V0ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYWxsZWxSb3V0ZXMpKXtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZFNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaChwYXJhbGxlbFJvdXRlKSl7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VnbWVudCBpcyBlbXB0eSwgaXQgbWVhbnMgd2UgYXJlIGF0IHRoZSByb290IG9mIHRoZSB0cmVlXG4gICAgICAgICAgICBpZiAoc2VnbWVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZFNlZ21lbnRcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkU2VnbWVudFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50cztcbn1cbmZ1bmN0aW9uIHRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMobmV3Q2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWVQYXRjaCkge1xuICAgIGxldCBhcHBsaWVkUGF0Y2ggPSBmYWxzZTtcbiAgICBuZXdDYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjO1xuICAgIG5ld0NhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjO1xuICAgIG5ld0NhY2hlLmxvYWRpbmcgPSBjdXJyZW50Q2FjaGUubG9hZGluZztcbiAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoY3VycmVudENhY2hlLnBhcmFsbGVsUm91dGVzKTtcbiAgICBjb25zdCBzZWdtZW50UGF0aHNUb0ZpbGwgPSBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHRyZWVQYXRjaCkubWFwKChzZWdtZW50KT0+W1xuICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAuLi5zZWdtZW50XG4gICAgICAgIF0pO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudFBhdGhzIG9mIHNlZ21lbnRQYXRoc1RvRmlsbCl7XG4gICAgICAgICgwLCBfY2xlYXJjYWNoZW5vZGVkYXRhZm9yc2VnbWVudHBhdGguY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgpKG5ld0NhY2hlLCBjdXJyZW50Q2FjaGUsIHNlZ21lbnRQYXRocyk7XG4gICAgICAgIGFwcGxpZWRQYXRjaCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhcHBsaWVkUGF0Y2g7XG59XG5jb25zdCBuYXZpZ2F0ZVJlZHVjZXIgPSBwcm9jZXNzLmVudi5fX05FWFRfUFBSID8gbmF2aWdhdGVSZWR1Y2VyX1BQUiA6IG5hdmlnYXRlUmVkdWNlcl9ub1BQUjtcbi8vIFRoaXMgaXMgdGhlIGltcGxlbWVudGF0aW9uIHdoZW4gUFBSIGlzIGRpc2FibGVkLiBXZSBjYW4gYXNzdW1lIGl0cyBiZWhhdmlvclxuLy8gaXMgcmVsYXRpdmVseSBzdGFibGUgYmVjYXVzZSBpdCdzIGJlZW4gcnVubmluZyBpbiBwcm9kdWN0aW9uIGZvciBhIHdoaWxlLlxuZnVuY3Rpb24gbmF2aWdhdGVSZWR1Y2VyX25vUFBSKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IHVybCwgaXNFeHRlcm5hbFVybCwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBtdXRhYmxlID0ge307XG4gICAgY29uc3QgeyBoYXNoIH0gPSB1cmw7XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHVybCk7XG4gICAgY29uc3QgcGVuZGluZ1B1c2ggPSBuYXZpZ2F0ZVR5cGUgPT09IFwicHVzaFwiO1xuICAgIC8vIHdlIHdhbnQgdG8gcHJ1bmUgdGhlIHByZWZldGNoIGNhY2hlIG9uIGV2ZXJ5IG5hdmlnYXRpb24gdG8gYXZvaWQgaXQgZ3Jvd2luZyB0b28gbGFyZ2VcbiAgICAoMCwgX3ByZWZldGNoY2FjaGV1dGlscy5wcnVuZVByZWZldGNoQ2FjaGUpKHN0YXRlLnByZWZldGNoQ2FjaGUpO1xuICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICBpZiAoaXNFeHRlcm5hbFVybCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIHVybC50b1N0cmluZygpLCBwZW5kaW5nUHVzaCk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZldGNoVmFsdWVzID0gKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMuZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkpKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICB0cmVlOiBzdGF0ZS50cmVlLFxuICAgICAgICBidWlsZElkOiBzdGF0ZS5idWlsZElkLFxuICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlXG4gICAgfSk7XG4gICAgY29uc3QgeyB0cmVlQXRUaW1lT2ZQcmVmZXRjaCwgZGF0YSB9ID0gcHJlZmV0Y2hWYWx1ZXM7XG4gICAgX3ByZWZldGNocmVkdWNlci5wcmVmZXRjaFF1ZXVlLmJ1bXAoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEudGhlbigocGFyYW0pPT57XG4gICAgICAgIGxldCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcGFyYW07XG4gICAgICAgIGxldCBpc0ZpcnN0UmVhZCA9IGZhbHNlO1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gbWFyayB0aGlzIG9uY2VcbiAgICAgICAgaWYgKCFwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogd2Ugc2hvdWxkIG9ubHkgbWFyayB0aGUgY2FjaGUgbm9kZSBhcyBkaXJ0eSBhZnRlciB3ZSB1bnN1c3BlbmQgZnJvbSB0aGUgY2FsbCBhYm92ZVxuICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlzRmlyc3RSZWFkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHBlbmRpbmdQdXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgYDxtZXRhIGh0dHAtZXF1aXY9XCJyZWZyZXNoXCI+YCB0YWcgaXMgcHJlc2VudCxcbiAgICAgICAgLy8gd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJfX25leHQtcGFnZS1yZWRpcmVjdFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZVNlZ21lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgIC8vIFRoZSBvbmUgYmVmb3JlIGxhc3QgaXRlbSBpcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgcGF0Y2hcbiAgICAgICAgICAgIGNvbnN0IHRyZWVQYXRjaCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0zKVswXTtcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSA9IFtcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgICAgICBsZXQgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LCBjdXJyZW50VHJlZSwgdHJlZVBhdGNoLCBocmVmKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0cmVlIHBhdGNoIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgdHJlZSB0aGVuIHdlIHVzZSB0aGUgdHJlZSBhdCB0aW1lIG9mIHByZWZldGNoXG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogVGhpcyBzaG91bGQgaW5zdGVhZCBmaWxsIGluIHRoZSBtaXNzaW5nIHBpZWNlcyBpbiBgY3VycmVudFRyZWVgIHdpdGggdGhlIGRhdGEgZnJvbSBgdHJlZUF0VGltZU9mUHJlZmV0Y2hgLCB0aGVuIGFwcGx5IHRoZSBwYXRjaC5cbiAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSwgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIHRyZWVQYXRjaCwgaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dC5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGUgPSAoMCwgX2FwcHJvdXRlci5jcmVhdGVFbXB0eUNhY2hlTm9kZSkoKTtcbiAgICAgICAgICAgICAgICBsZXQgYXBwbGllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaFZhbHVlcy5zdGF0dXMgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlICYmICFpc0ZpcnN0UmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgYSBzdGFsZSBwcmVmZXRjaCBlbnRyeSwgd2Ugb25seSB3YW50IHRvIHJlLXVzZSB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgcm91dGUgd2UncmUgbmF2aWdhdGluZyB0bywgdG8gc3VwcG9ydCBpbnN0YW50IGxvYWRpbmcgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoIGZvciB0aGUgYWN0dWFsIHBhZ2UgZGF0YSBieSBudWxsaW5nIHRoZSBgcnNjYCBhbmQgYHByZWZldGNoUnNjYCB2YWx1ZXMgZm9yIHBhZ2UgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpbGUgY29weWluZyBvdmVyIHRoZSBgbG9hZGluZ2AgZm9yIHRoZSBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIHBhZ2UgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIG9uIHN1YnNlcXVlbnQgcmVhZHMsIGFzIG90aGVyd2lzZSB0aGVyZSdkIGJlIG5vIGxvYWRpbmcgZGF0YSB0byByZS11c2UuXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWQgPSB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKGNhY2hlLCBjdXJyZW50Q2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSByZS11c2VkIHRoZSBzdGFsZSBjYWNoZSdzIGxvYWRpbmcgc3RhdGUgJiByZWZyZXNoZWQgdGhlIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYGxhc3RVc2VkVGltZWAgc28gdGhhdCBpdCBjYW4gY29udGludWUgdG8gYmUgcmUtdXNlZCBmb3IgdGhlIG5leHQgMzBzXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZCA9ICgwLCBfYXBwbHlmbGlnaHRkYXRhLmFwcGx5RmxpZ2h0RGF0YSkoY3VycmVudENhY2hlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgsIHByZWZldGNoVmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gKDAsIF9zaG91bGRoYXJkbmF2aWdhdGUuc2hvdWxkSGFyZE5hdmlnYXRlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LCBjdXJyZW50VHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhcmROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnJzYyA9IGN1cnJlbnRDYWNoZS5yc2M7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2ludmFsaWRhdGVjYWNoZWJlbG93ZmxpZ2h0c2VnbWVudHBhdGguaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCkoY2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGV4aXN0aW5nIGNhY2hlIHZhbHVlIGlzIHVzZWQgd2hlbiB0aGUgY2FjaGUgd2FzIG5vdCBpbnZhbGlkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZCkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFwcGxpZWQgdGhlIGNhY2hlLCB3ZSB1cGRhdGUgdGhlIFwiY3VycmVudCBjYWNoZVwiIHZhbHVlIHNvIGFueSBvdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBpbiB0aGUgRmxpZ2h0RGF0YVBhdGggd2lsbCBiZSBhYmxlIHRvIHJlZmVyZW5jZSB0aGUgdXBkYXRlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdWJTZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIF9fREVGQVVMVF9fIHBhdGhzIGFzIHRoZXkgc2hvdWxkbid0IGJlIHNjcm9sbGVkIHRvIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVTZWdtZW50UGF0aFtzY3JvbGxhYmxlU2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gIT09IF9zZWdtZW50LkRFRkFVTFRfU0VHTUVOVF9LRVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50cy5wdXNoKHNjcm9sbGFibGVTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IGN1cnJlbnRUcmVlO1xuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogaHJlZjtcbiAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHNjcm9sbGFibGVTZWdtZW50cztcbiAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSBoYXNoO1xuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbDtcbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKCk9PnN0YXRlKTtcbn1cbi8vIFRoaXMgaXMgdGhlIGV4cGVyaW1lbnRhbCBQUFIgaW1wbGVtZW50YXRpb24uIEl0J3MgY2xvc2VyIHRvIHRoZSBiZWhhdmlvciB3ZVxuLy8gd2FudCwgYnV0IGlzIGxpa2VsaWVyIHRvIGluY2x1ZGUgYWNjaWRlbnRhbCByZWdyZXNzaW9ucyBiZWNhdXNlIGl0IHJld3JpdGVzXG4vLyBleGlzdGluZyBmdW5jdGlvbmFsaXR5LlxuZnVuY3Rpb24gbmF2aWdhdGVSZWR1Y2VyX1BQUihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyB1cmwsIGlzRXh0ZXJuYWxVcmwsIG5hdmlnYXRlVHlwZSwgc2hvdWxkU2Nyb2xsIH0gPSBhY3Rpb247XG4gICAgY29uc3QgbXV0YWJsZSA9IHt9O1xuICAgIGNvbnN0IHsgaGFzaCB9ID0gdXJsO1xuICAgIGNvbnN0IGhyZWYgPSAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKSh1cmwpO1xuICAgIGNvbnN0IHBlbmRpbmdQdXNoID0gbmF2aWdhdGVUeXBlID09PSBcInB1c2hcIjtcbiAgICAvLyB3ZSB3YW50IHRvIHBydW5lIHRoZSBwcmVmZXRjaCBjYWNoZSBvbiBldmVyeSBuYXZpZ2F0aW9uIHRvIGF2b2lkIGl0IGdyb3dpbmcgdG9vIGxhcmdlXG4gICAgKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMucHJ1bmVQcmVmZXRjaENhY2hlKShzdGF0ZS5wcmVmZXRjaENhY2hlKTtcbiAgICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgaWYgKGlzRXh0ZXJuYWxVcmwpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwudG9TdHJpbmcoKSwgcGVuZGluZ1B1c2gpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmZXRjaFZhbHVlcyA9ICgwLCBfcHJlZmV0Y2hjYWNoZXV0aWxzLmdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICAgICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICAgICAgYnVpbGRJZDogc3RhdGUuYnVpbGRJZCxcbiAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZVxuICAgIH0pO1xuICAgIGNvbnN0IHsgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIGRhdGEgfSA9IHByZWZldGNoVmFsdWVzO1xuICAgIF9wcmVmZXRjaHJlZHVjZXIucHJlZmV0Y2hRdWV1ZS5idW1wKGRhdGEpO1xuICAgIHJldHVybiBkYXRhLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICBsZXQgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlLCBfcG9zdHBvbmVkXSA9IHBhcmFtO1xuICAgICAgICBsZXQgaXNGaXJzdFJlYWQgPSBmYWxzZTtcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIG1hcmsgdGhpcyBvbmNlXG4gICAgICAgIGlmICghcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lKSB7XG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IHdlIHNob3VsZCBvbmx5IG1hcmsgdGhlIGNhY2hlIG5vZGUgYXMgZGlydHkgYWZ0ZXIgd2UgdW5zdXNwZW5kIGZyb20gdGhlIGNhbGwgYWJvdmVcbiAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpc0ZpcnN0UmVhZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIGA8bWV0YSBodHRwLWVxdWl2PVwicmVmcmVzaFwiPmAgdGFnIGlzIHByZXNlbnQsXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX19uZXh0LXBhZ2UtcmVkaXJlY3RcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgICAgIGxldCBjdXJyZW50Q2FjaGUgPSBzdGF0ZS5jYWNoZTtcbiAgICAgICAgbGV0IHNjcm9sbGFibGVTZWdtZW50cyA9IFtdO1xuICAgICAgICAvLyBUT0RPOiBJbiBwcmFjdGljZSwgdGhpcyBpcyBhbHdheXMgYSBzaW5nbGUgaXRlbSBhcnJheS4gV2UgcHJvYmFibHlcbiAgICAgICAgLy8gYXJlbid0IGdvaW5nIHRvIGV2ZXJ5IHNlbmQgbXVsdGlwbGUgc2VnbWVudHMsIGF0IGxlYXN0IG5vdCBpbiB0aGlzXG4gICAgICAgIC8vIGZvcm1hdC4gU28gd2UgY291bGQgcmVtb3ZlIHRoZSBleHRyYSB3cmFwcGVyIGZvciBub3cgdW50aWxcbiAgICAgICAgLy8gdGhhdCBzZXR0bGVzLlxuICAgICAgICBmb3IgKGNvbnN0IGZsaWdodERhdGFQYXRoIG9mIGZsaWdodERhdGEpe1xuICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICBjb25zdCB0cmVlUGF0Y2ggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgtMylbMF07XG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkgPSBbXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICAgICAgbGV0IG5ld1RyZWUgPSAoMCwgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSwgY3VycmVudFRyZWUsIHRyZWVQYXRjaCwgaHJlZik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJlZSBwYXRjaCBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHRyZWUgdGhlbiB3ZSB1c2UgdGhlIHRyZWUgYXQgdGltZSBvZiBwcmVmZXRjaFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IFRoaXMgc2hvdWxkIGluc3RlYWQgZmlsbCBpbiB0aGUgbWlzc2luZyBwaWVjZXMgaW4gYGN1cnJlbnRUcmVlYCB3aXRoIHRoZSBkYXRhIGZyb20gYHRyZWVBdFRpbWVPZlByZWZldGNoYCwgdGhlbiBhcHBseSB0aGUgcGF0Y2guXG4gICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld1RyZWUgPSAoMCwgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksIHRyZWVBdFRpbWVPZlByZWZldGNoLCB0cmVlUGF0Y2gsIGhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KShjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIGlzIGp1c3QgYSBwYXJhbm9pZCBjaGVjay4gV2hlbiBQUFIgaXMgZW5hYmxlZCwgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYWx3YXlzIHNlbmQgYmFjayBhIHN0YXRpYyByZXNwb25zZSB0aGF0J3MgcmVuZGVyZWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHRoZSByb290LiBJZiBmb3Igc29tZSByZWFzb24gaXQgZG9lc24ndCwgd2UgZmFsbCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5vbi1QUFIgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlIGVsc2UgYnJhbmNoIGFuZCBkbyBhbGwgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB2aWEgdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uLiBUaGUgY3VycmVudCBzdHJ1Y3R1cmUgaXMganVzdFxuICAgICAgICAgICAgICAgIC8vIGFuIGluY3JlbWVudGFsIHN0ZXAuXG4gICAgICAgICAgICAgICAgZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZldGNoZWRUcmVlID0gZmxpZ2h0RGF0YVBhdGhbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZWREYXRhID0gZmxpZ2h0RGF0YVBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBmbGlnaHREYXRhUGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9ICgwLCBfcHBybmF2aWdhdGlvbnMudXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKShjdXJyZW50Q2FjaGUsIGN1cnJlbnRUcmVlLCBwcmVmZXRjaGVkVHJlZSwgc2VlZERhdGEsIGhlYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFzayAhPT0gbnVsbCAmJiB0YXNrLm5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGNyZWF0ZWQgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIHRoYXQgY29udGFpbnMgYSBwcmVmZXRjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9uIG9mIHRoZSBuZXh0IHBhZ2UuIFRoaXMgY2FuIGJlIHJlbmRlcmVkIGluc3RhbnRseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgdHJlZSBjb21wdXRlZCBieSB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24gaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIG9uZSBjb21wdXRlZCBieSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgcmVtb3ZlIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgUFBSIHBhdGggZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkUm91dGVyU3RhdGUgPSB0YXNrLnJvdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJlZSA9IHBhdGNoZWRSb3V0ZXJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gdGFzay5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZWZldGNoZWQgdHJlZSBoYXMgZHluYW1pYyBob2xlcyBpbiBpdC4gV2UgaW5pdGlhdGUgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyByZXF1ZXN0IHRvIGZpbGwgdGhlbSBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYmxvY2sgb24gdGhlIHJlc3VsdC4gV2UnbGwgaW1tZWRpYXRlbHkgcmVuZGVyIHRoZSBDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSB0cmVlIGFuZCBzdXNwZW5kIG9uIHRoZSBkeW5hbWljIHBhcnRzLiBXaGVuIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21lcyBpbiwgd2UnbGwgZmlsbCBpbiBtaXNzaW5nIGRhdGEgYW5kIHBpbmcgUmVhY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLXJlbmRlci4gVW5saWtlIHRoZSBsYXp5IGZldGNoaW5nIG1vZGVsIGluIHRoZSBub24tUFBSXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgdGhpcyBpcyBtb2RlbGVkIGFzIGEgc2luZ2xlIFJlYWN0IHVwZGF0ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJlYW1pbmcsIHJhdGhlciB0aGFuIG11bHRpcGxlIHRvcC1sZXZlbCB1cGRhdGVzLiAoSG93ZXZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gdGhlIG5ldyBtb2RlbCwgd2UnbGwgc3RpbGwgbmVlZCB0byBzb21ldGltZXMgdXBkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm9vdCBtdWx0aXBsZSB0aW1lcyBwZXIgbmF2aWdhdGlvbiwgbGlrZSBpZiB0aGUgc2VydmVyIHNlbmRzIHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGRpZmZlcmVudCByZXNwb25zZSB0aGFuIHdlIGV4cGVjdGVkLiBGb3Igbm93LCB3ZSByZXZlcnQgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIGxhenkgZmV0Y2hpbmcgbWVjaGFuaXNtIGluIHRoYXQgY2FzZS4pXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3Bwcm5hdmlnYXRpb25zLmxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KSh0YXNrLCAoMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkodXJsLCBjdXJyZW50VHJlZSwgc3RhdGUubmV4dFVybCwgc3RhdGUuYnVpbGRJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IG5ld0NhY2hlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBzbyByZXVzZSB0aGUgb2xkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB0aGUgaGVhZCBjaGFuZ2VkIGJ1dCBub3QgYW55IG9mIHRoZSBzZWdtZW50IGRhdGE/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGF0IHBvc3NpYmxlPyBJZiBzbywgd2Ugc2hvdWxkIGNsb25lIHRoZSB3aG9sZSB0cmVlIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJlZSA9IHByZWZldGNoZWRUcmVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHN0YXRpYyByZXNwb25zZSBkb2VzIG5vdCBpbmNsdWRlIGFueSBkeW5hbWljIGhvbGVzLCBzb1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gZG8gYSBzZWNvbmQgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQXMgYW4gaW5jcmVtZW50YWwgc3RlcCB0aGlzIGp1c3QgcmV2ZXJ0cyBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBub24tUFBSIGltcGxlbWVudGF0aW9uLiBXZSBjYW4gc2ltcGxpZnkgdGhpcyBicmFuY2ggZnVydGhlcixcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZW4gdGhhdCBQUFIgcHJlZmV0Y2hlcyBhcmUgYWx3YXlzIHN0YXRpYyBhbmQgcmV0dXJuIHRoZSB3aG9sZVxuICAgICAgICAgICAgICAgICAgICAvLyB0cmVlLiBPciBpbiB0aGUgbWVhbnRpbWUgd2UgY291bGQgZmFjdG9yIGl0IG91dCBpbnRvIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gKDAsIF9hcHByb3V0ZXIuY3JlYXRlRW1wdHlDYWNoZU5vZGUpKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcHBsaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaFZhbHVlcy5zdGF0dXMgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlICYmICFpc0ZpcnN0UmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIGEgc3RhbGUgcHJlZmV0Y2ggZW50cnksIHdlIG9ubHkgd2FudCB0byByZS11c2UgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhlIHJvdXRlIHdlJ3JlIG5hdmlnYXRpbmcgdG8sIHRvIHN1cHBvcnQgaW5zdGFudCBsb2FkaW5nIG5hdmlnYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZm9yIHRoZSBhY3R1YWwgcGFnZSBkYXRhIGJ5IG51bGxpbmcgdGhlIGByc2NgIGFuZCBgcHJlZmV0Y2hSc2NgIHZhbHVlcyBmb3IgcGFnZSBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpbGUgY29weWluZyBvdmVyIHRoZSBgbG9hZGluZ2AgZm9yIHRoZSBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIHBhZ2UgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiBzdWJzZXF1ZW50IHJlYWRzLCBhcyBvdGhlcndpc2UgdGhlcmUnZCBiZSBubyBsb2FkaW5nIGRhdGEgdG8gcmUtdXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZCA9IHRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMoY2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSByZS11c2VkIHRoZSBzdGFsZSBjYWNoZSdzIGxvYWRpbmcgc3RhdGUgJiByZWZyZXNoZWQgdGhlIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGBsYXN0VXNlZFRpbWVgIHNvIHRoYXQgaXQgY2FuIGNvbnRpbnVlIHRvIGJlIHJlLXVzZWQgZm9yIHRoZSBuZXh0IDMwc1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQgPSAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKGN1cnJlbnRDYWNoZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoLCBwcmVmZXRjaFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gKDAsIF9zaG91bGRoYXJkbmF2aWdhdGUuc2hvdWxkSGFyZE5hdmlnYXRlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSwgY3VycmVudFRyZWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFyZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBjdXJyZW50Q2FjaGUucHJlZmV0Y2hSc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2ludmFsaWRhdGVjYWNoZWJlbG93ZmxpZ2h0c2VnbWVudHBhdGguaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCkoY2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBleGlzdGluZyBjYWNoZSB2YWx1ZSBpcyB1c2VkIHdoZW4gdGhlIGNhY2hlIHdhcyBub3QgaW52YWxpZGF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXBwbGllZCB0aGUgY2FjaGUsIHdlIHVwZGF0ZSB0aGUgXCJjdXJyZW50IGNhY2hlXCIgdmFsdWUgc28gYW55IG90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBpbiB0aGUgRmxpZ2h0RGF0YVBhdGggd2lsbCBiZSBhYmxlIHRvIHJlZmVyZW5jZSB0aGUgdXBkYXRlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdWJTZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIF9fREVGQVVMVF9fIHBhdGhzIGFzIHRoZXkgc2hvdWxkbid0IGJlIHNjcm9sbGVkIHRvIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVTZWdtZW50UGF0aFtzY3JvbGxhYmxlU2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gIT09IF9zZWdtZW50LkRFRkFVTFRfU0VHTUVOVF9LRVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50cy5wdXNoKHNjcm9sbGFibGVTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IGN1cnJlbnRUcmVlO1xuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogaHJlZjtcbiAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHNjcm9sbGFibGVTZWdtZW50cztcbiAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSBoYXNoO1xuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbDtcbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKCk9PnN0YXRlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGUtcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsIm5hdmlnYXRlUmVkdWNlciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwicmVxdWlyZSIsIl9jcmVhdGVocmVmZnJvbXVybCIsIl9pbnZhbGlkYXRlY2FjaGViZWxvd2ZsaWdodHNlZ21lbnRwYXRoIiwiX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSIsIl9zaG91bGRoYXJkbmF2aWdhdGUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX3JvdXRlcnJlZHVjZXJ0eXBlcyIsIl9oYW5kbGVtdXRhYmxlIiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsIl9wcmVmZXRjaHJlZHVjZXIiLCJfYXBwcm91dGVyIiwiX3NlZ21lbnQiLCJfcHBybmF2aWdhdGlvbnMiLCJfcHJlZmV0Y2hjYWNoZXV0aWxzIiwiX2NsZWFyY2FjaGVub2RlZGF0YWZvcnNlZ21lbnRwYXRoIiwic3RhdGUiLCJtdXRhYmxlIiwidXJsIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiY2Fub25pY2FsVXJsIiwic2Nyb2xsYWJsZVNlZ21lbnRzIiwidW5kZWZpbmVkIiwiaGFuZGxlTXV0YWJsZSIsImdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2giLCJmbGlnaHRSb3V0ZXJQYXRjaCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJwYXJhbGxlbFJvdXRlIiwiZW50cmllcyIsImNoaWxkU2VnbWVudCIsInB1c2giLCJ0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzIiwibmV3Q2FjaGUiLCJjdXJyZW50Q2FjaGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsImFwcGxpZWRQYXRjaCIsInJzYyIsInByZWZldGNoUnNjIiwibG9hZGluZyIsIk1hcCIsInNlZ21lbnRQYXRoc1RvRmlsbCIsIm1hcCIsInNlZ21lbnRQYXRocyIsImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9QUFIiLCJuYXZpZ2F0ZVJlZHVjZXJfUFBSIiwibmF2aWdhdGVSZWR1Y2VyX25vUFBSIiwiYWN0aW9uIiwiaXNFeHRlcm5hbFVybCIsIm5hdmlnYXRlVHlwZSIsInNob3VsZFNjcm9sbCIsImhhc2giLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJ0b1N0cmluZyIsInByZWZldGNoVmFsdWVzIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwidHJlZSIsImJ1aWxkSWQiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsImRhdGEiLCJwcmVmZXRjaFF1ZXVlIiwiYnVtcCIsInRoZW4iLCJwYXJhbSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImlzRmlyc3RSZWFkIiwibGFzdFVzZWRUaW1lIiwiRGF0ZSIsIm5vdyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjdXJyZW50VHJlZSIsImNhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJzbGljZSIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImFwcGxpZWQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJzdGFsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhcmROYXZpZ2F0ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJzdWJTZWdtZW50Iiwic2Nyb2xsYWJsZVNlZ21lbnRQYXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInBhdGNoZWRUcmVlIiwiaGFzaEZyYWdtZW50IiwiX3Bvc3Rwb25lZCIsInByZWZldGNoZWRUcmVlIiwic2VlZERhdGEiLCJoZWFkIiwidGFzayIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsIm5vZGUiLCJwYXRjaGVkUm91dGVyU3RhdGUiLCJyb3V0ZSIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1468\n"));

/***/ }),

/***/ 4749:
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js ***!
  \**********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ 824);\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ 7806);\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ 2997);\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nfunction prefetchReducer(state, action) {\n    // let's prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    url.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        buildId: state.buildId\n    });\n    return state;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc0OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sb0JBQW9CQyxtQkFBT0EsQ0FBQyxtQ0FBMEI7QUFDNUQsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQywrQkFBcUI7QUFDbkQsTUFBTUUsc0JBQXNCRixtQkFBT0EsQ0FBQyxtQ0FBeUI7QUFDN0QsTUFBTVQsZ0JBQWdCLElBQUlVLGNBQWNFLFlBQVksQ0FBQztBQUNyRCxTQUFTWCxnQkFBZ0JZLEtBQUssRUFBRUMsTUFBTTtJQUNsQyw0REFBNEQ7SUFDM0QsSUFBR0gsb0JBQW9CSSxrQkFBa0IsRUFBRUYsTUFBTUcsYUFBYTtJQUMvRCxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHSDtJQUNoQkcsSUFBSUMsWUFBWSxDQUFDQyxNQUFNLENBQUNYLGtCQUFrQlksb0JBQW9CO0lBQzdELElBQUdULG9CQUFvQlUsNkJBQTZCLEVBQUU7UUFDbkRKO1FBQ0FLLFNBQVNULE1BQU1TLE9BQU87UUFDdEJOLGVBQWVILE1BQU1HLGFBQWE7UUFDbENPLE1BQU1ULE9BQU9TLElBQUk7UUFDakJDLE1BQU1YLE1BQU1XLElBQUk7UUFDaEJDLFNBQVNaLE1BQU1ZLE9BQU87SUFDMUI7SUFDQSxPQUFPWjtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9oQixRQUFRNkIsT0FBTyxLQUFLLGNBQWUsT0FBTzdCLFFBQVE2QixPQUFPLEtBQUssWUFBWTdCLFFBQVE2QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU83QixRQUFRNkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTZCLE9BQU8sRUFBRSxjQUFjO1FBQUU1QixPQUFPO0lBQUs7SUFDbkVILE9BQU9pQyxNQUFNLENBQUMvQixRQUFRNkIsT0FBTyxFQUFFN0I7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUTZCLE9BQU87QUFDbEMsRUFFQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLmpzPzNiM2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwcmVmZXRjaFF1ZXVlOiBudWxsLFxuICAgIHByZWZldGNoUmVkdWNlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBwcmVmZXRjaFF1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByZWZldGNoUXVldWU7XG4gICAgfSxcbiAgICBwcmVmZXRjaFJlZHVjZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJlZmV0Y2hSZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX2FwcHJvdXRlcmhlYWRlcnMgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlci1oZWFkZXJzXCIpO1xuY29uc3QgX3Byb21pc2VxdWV1ZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm9taXNlLXF1ZXVlXCIpO1xuY29uc3QgX3ByZWZldGNoY2FjaGV1dGlscyA9IHJlcXVpcmUoXCIuLi9wcmVmZXRjaC1jYWNoZS11dGlsc1wiKTtcbmNvbnN0IHByZWZldGNoUXVldWUgPSBuZXcgX3Byb21pc2VxdWV1ZS5Qcm9taXNlUXVldWUoNSk7XG5mdW5jdGlvbiBwcmVmZXRjaFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIC8vIGxldCdzIHBydW5lIHRoZSBwcmVmZXRjaCBjYWNoZSBiZWZvcmUgd2UgZG8gYW55dGhpbmcgZWxzZVxuICAgICgwLCBfcHJlZmV0Y2hjYWNoZXV0aWxzLnBydW5lUHJlZmV0Y2hDYWNoZSkoc3RhdGUucHJlZmV0Y2hDYWNoZSk7XG4gICAgY29uc3QgeyB1cmwgfSA9IGFjdGlvbjtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShfYXBwcm91dGVyaGVhZGVycy5ORVhUX1JTQ19VTklPTl9RVUVSWSk7XG4gICAgKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMuZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkpKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICBraW5kOiBhY3Rpb24ua2luZCxcbiAgICAgICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICAgICAgYnVpbGRJZDogc3RhdGUuYnVpbGRJZFxuICAgIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZmV0Y2gtcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJwcmVmZXRjaFF1ZXVlIiwicHJlZmV0Y2hSZWR1Y2VyIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FwcHJvdXRlcmhlYWRlcnMiLCJyZXF1aXJlIiwiX3Byb21pc2VxdWV1ZSIsIl9wcmVmZXRjaGNhY2hldXRpbHMiLCJQcm9taXNlUXVldWUiLCJzdGF0ZSIsImFjdGlvbiIsInBydW5lUHJlZmV0Y2hDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwibmV4dFVybCIsImtpbmQiLCJ0cmVlIiwiYnVpbGRJZCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4749\n"));

/***/ }),

/***/ 4418:
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js ***!
  \*********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"refreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ 6969);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 6808);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 8082);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 8927);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 1468);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 5013);\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ 6251);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 7679);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 8249);\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ 7246);\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ 5800);\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        currentTree[0],\n        currentTree[1],\n        currentTree[2],\n        \"refetch\"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then(async (param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log(\"REFRESH FAILED\");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                \"\"\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[2];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                mutable.prefetchCache = new Map();\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RFLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1FLE9BQU8sRUFBRSxjQUFjO1FBQUVsRSxPQUFPO0lBQUs7SUFDbkVILE9BQU91RSxNQUFNLENBQUNyRSxRQUFRbUUsT0FBTyxFQUFFbkU7SUFDL0JzRSxPQUFPdEUsT0FBTyxHQUFHQSxRQUFRbUUsT0FBTztBQUNsQyxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci5qcz8yOTNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVmcmVzaFJlZHVjZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlZnJlc2hSZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX2NyZWF0ZWhyZWZmcm9tdXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xuY29uc3QgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSA9IHJlcXVpcmUoXCIuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZVwiKTtcbmNvbnN0IF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQgPSByZXF1aXJlKFwiLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXRcIik7XG5jb25zdCBfbmF2aWdhdGVyZWR1Y2VyID0gcmVxdWlyZShcIi4vbmF2aWdhdGUtcmVkdWNlclwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkID0gcmVxdWlyZShcIi4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuY29uc3QgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaFwiKTtcbmNvbnN0IF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUgPSByZXF1aXJlKFwiLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZVwiKTtcbmNvbnN0IF9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHNcIik7XG5mdW5jdGlvbiByZWZyZXNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvbjtcbiAgICBjb25zdCBtdXRhYmxlID0ge307XG4gICAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybDtcbiAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlO1xuICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICAgIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gKDAsIF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUuaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKShzdGF0ZS50cmVlKTtcbiAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gICAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgIGNhY2hlLmxhenlEYXRhID0gKDAsIF9mZXRjaHNlcnZlcnJlc3BvbnNlLmZldGNoU2VydmVyUmVzcG9uc2UpKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwgW1xuICAgICAgICBjdXJyZW50VHJlZVswXSxcbiAgICAgICAgY3VycmVudFRyZWVbMV0sXG4gICAgICAgIGN1cnJlbnRUcmVlWzJdLFxuICAgICAgICBcInJlZmV0Y2hcIlxuICAgIF0sIGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsIHN0YXRlLmJ1aWxkSWQpO1xuICAgIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKGFzeW5jIChwYXJhbSk9PntcbiAgICAgICAgbGV0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSBwYXJhbTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVyZWR1Y2VyLmhhbmRsZUV4dGVybmFsVXJsKShzdGF0ZSwgbXV0YWJsZSwgZmxpZ2h0RGF0YSwgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKXtcbiAgICAgICAgICAgIC8vIEZsaWdodERhdGFQYXRoIHdpdGggbW9yZSB0aGFuIHR3byBpdGVtcyBtZWFucyB1bmV4cGVjdGVkIEZsaWdodCBkYXRhIHdhcyByZXR1cm5lZFxuICAgICAgICAgICAgaWYgKGZsaWdodERhdGFQYXRoLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVGUkVTSCBGQUlMRURcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2l2ZW4gdGhlIHBhdGggY2FuIG9ubHkgaGF2ZSB0d28gaXRlbXMgdGhlIGl0ZW1zIGFyZSBvbmx5IHRoZSByb3V0ZXIgc3RhdGUgYW5kIHJzYyBmb3IgdGhlIHJvb3QuXG4gICAgICAgICAgICBjb25zdCBbdHJlZVBhdGNoXSA9IGZsaWdodERhdGFQYXRoO1xuICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgIF0sIGN1cnJlbnRUcmVlLCB0cmVlUGF0Y2gsIHN0YXRlLmNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaC5oYW5kbGVTZWdtZW50TWlzbWF0Y2gpKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KShjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICBjb25zdCBbY2FjaGVOb2RlU2VlZERhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTIpO1xuICAgICAgICAgICAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIHByZWZldGNoIG9ubHkgcmV0dXJucyB0aGUgcm91dGVyIHRyZWUgcGF0Y2ggd2l0aG91dCByZW5kZXJlZCBjb21wb25lbnRzLlxuICAgICAgICAgICAgaWYgKGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMl07XG4gICAgICAgICAgICAgICAgY2FjaGUucnNjID0gcnNjO1xuICAgICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICAoMCwgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKShjYWNoZSwgLy8gRXhpc3RpbmcgY2FjaGUgaXMgbm90IHBhc3NlZCBpbiBhcyBgcm91dGVyLnJlZnJlc2goKWAgaGFzIHRvIGludmFsaWRhdGUgdGhlIGVudGlyZSBjYWNoZS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHRyZWVQYXRjaCwgY2FjaGVOb2RlU2VlZERhdGEsIGhlYWQpO1xuICAgICAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCBfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cy5yZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzKSh7XG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdXBkYXRlZFRyZWU6IG5ld1RyZWUsXG4gICAgICAgICAgICAgICAgdXBkYXRlZENhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlTmV4dFVybCxcbiAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsIHx8IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gaHJlZjtcbiAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIF9oYW5kbGVtdXRhYmxlLmhhbmRsZU11dGFibGUpKHN0YXRlLCBtdXRhYmxlKTtcbiAgICB9LCAoKT0+c3RhdGUpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZyZXNoLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInJlZnJlc2hSZWR1Y2VyIiwiX2ZldGNoc2VydmVycmVzcG9uc2UiLCJyZXF1aXJlIiwiX2NyZWF0ZWhyZWZmcm9tdXJsIiwiX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSIsIl9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQiLCJfbmF2aWdhdGVyZWR1Y2VyIiwiX2hhbmRsZW11dGFibGUiLCJfZmlsbGxhenlpdGVtc3RpbGxsZWFmd2l0aGhlYWQiLCJfYXBwcm91dGVyIiwiX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCIsIl9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUiLCJfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyIsInN0YXRlIiwiYWN0aW9uIiwib3JpZ2luIiwibXV0YWJsZSIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJjdXJyZW50VHJlZSIsInRyZWUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsInBhcmFtIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJmbGlnaHREYXRhUGF0aCIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJ0cmVlUGF0Y2giLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJzbGljZSIsInJzYyIsInByZWZldGNoUnNjIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4418\n"));

/***/ }),

/***/ 4622:
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js ***!
  \*********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"restoreReducer\", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 6808);\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ 2074);\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ 1709);\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        buildId: state.buildId,\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYyMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMscUJBQXFCQyxtQkFBT0EsQ0FBQyxtQ0FBeUI7QUFDNUQsTUFBTUMsc0JBQXNCRCxtQkFBT0EsQ0FBQyxtQ0FBeUI7QUFDN0QsTUFBTUUsa0JBQWtCRixtQkFBT0EsQ0FBQyw4QkFBb0I7QUFDcEQsU0FBU0YsZUFBZUssS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUUsR0FBR0Y7SUFDdEIsTUFBTUcsT0FBTyxDQUFDLEdBQUdSLG1CQUFtQlMsaUJBQWlCLEVBQUVIO0lBQ3ZELDBFQUEwRTtJQUMxRSw0RkFBNEY7SUFDNUYsZ0dBQWdHO0lBQ2hHLDZGQUE2RjtJQUM3Riw4REFBOEQ7SUFDOUQseUdBQXlHO0lBQ3pHLE1BQU1JLGdCQUFnQkgsUUFBUUgsTUFBTUcsSUFBSTtJQUN4QyxNQUFNSSxXQUFXUCxNQUFNUSxLQUFLO0lBQzVCLE1BQU1DLFdBQVdDLE1BQXNCLEdBR3ZDLDJEQUYyRDtJQUMzRCwyQkFBMkI7SUFDMUIsQ0FBaUZKLEdBQUdDO0lBQ3JGLElBQUlPO0lBQ0osT0FBTztRQUNIQyxTQUFTZixNQUFNZSxPQUFPO1FBQ3RCLG9CQUFvQjtRQUNwQkMsY0FBY1o7UUFDZGEsU0FBUztZQUNMQyxhQUFhO1lBQ2JDLGVBQWU7WUFDZiw2RkFBNkY7WUFDN0ZDLDRCQUE0QjtRQUNoQztRQUNBQyxtQkFBbUJyQixNQUFNcUIsaUJBQWlCO1FBQzFDYixPQUFPQztRQUNQYSxlQUFldEIsTUFBTXNCLGFBQWE7UUFDbEMsd0JBQXdCO1FBQ3hCbkIsTUFBTUc7UUFDTmlCLFNBQVMsQ0FBQ1Qsb0NBQW9DLENBQUMsR0FBR2hCLG9CQUFvQjBCLGdDQUFnQyxFQUFFbEIsY0FBYSxLQUFNLE9BQU9RLG9DQUFvQ1osSUFBSXVCLFFBQVE7SUFDdEw7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPbEMsUUFBUW1DLE9BQU8sS0FBSyxjQUFlLE9BQU9uQyxRQUFRbUMsT0FBTyxLQUFLLFlBQVluQyxRQUFRbUMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkMsUUFBUW1DLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFtQyxPQUFPLEVBQUUsY0FBYztRQUFFbEMsT0FBTztJQUFLO0lBQ25FSCxPQUFPdUMsTUFBTSxDQUFDckMsUUFBUW1DLE9BQU8sRUFBRW5DO0lBQy9Cc0MsT0FBT3RDLE9BQU8sR0FBR0EsUUFBUW1DLE9BQU87QUFDbEMsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXIuanM/NzkzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc3RvcmVSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXN0b3JlUmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVocmVmZnJvbXVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9jb21wdXRlY2hhbmdlZHBhdGggPSByZXF1aXJlKFwiLi4vY29tcHV0ZS1jaGFuZ2VkLXBhdGhcIik7XG5jb25zdCBfcHBybmF2aWdhdGlvbnMgPSByZXF1aXJlKFwiLi4vcHByLW5hdmlnYXRpb25zXCIpO1xuZnVuY3Rpb24gcmVzdG9yZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHsgdXJsLCB0cmVlIH0gPSBhY3Rpb247XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHVybCk7XG4gICAgLy8gVGhpcyBhY3Rpb24gaXMgdXNlZCB0byByZXN0b3JlIHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICAvLyBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIHRoZSBgRmxpZ2h0Um91dGVyU3RhdGVgLlxuICAgIC8vIFdlIHdpbGwgY29weSBvdmVyIHRoZSBpbnRlcm5hbCBzdGF0ZSBvbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGV2ZW50cywgYnV0IGlmIGEgaGlzdG9yeSBlbnRyeVxuICAgIC8vIG9jY3VycmVkIGJlZm9yZSBoeWRyYXRpb24sIG9yIGlmIHRoZSB1c2VyIG5hdmlnYXRlZCB0byBhIGhhc2ggdXNpbmcgYSByZWd1bGFyIGFuY2hvciBsaW5rLFxuICAgIC8vIHRoZSBoaXN0b3J5IHN0YXRlIHdpbGwgbm90IGNvbnRhaW4gdGhlIGBGbGlnaHRSb3V0ZXJTdGF0ZWAuXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSdsbCBjb250aW51ZSB0byB1c2UgdGhlIGV4aXN0aW5nIHRyZWUgc28gdGhlIHJvdXRlciBkb2Vzbid0IGdldCBpbnRvIGFuIGludmFsaWQgc3RhdGUuXG4gICAgY29uc3QgdHJlZVRvUmVzdG9yZSA9IHRyZWUgfHwgc3RhdGUudHJlZTtcbiAgICBjb25zdCBvbGRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgIGNvbnN0IG5ld0NhY2hlID0gcHJvY2Vzcy5lbnYuX19ORVhUX1BQUiA/IC8vIGRhdGEgZm9yIGFueSBzZWdtZW50IHdob3NlIGR5bmFtaWMgZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFuIHVubmVjZXNzYXJ5IGZsYXNoIGJhY2sgdG8gUFBSIHN0YXRlIGR1cmluZyBhXG4gICAgLy8gYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gICAgKDAsIF9wcHJuYXZpZ2F0aW9ucy51cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24pKG9sZENhY2hlLCB0cmVlVG9SZXN0b3JlKSA6IG9sZENhY2hlO1xuICAgIHZhciBfZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVpbGRJZDogc3RhdGUuYnVpbGRJZCxcbiAgICAgICAgLy8gU2V0IGNhbm9uaWNhbCB1cmxcbiAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgY3VzdG9tIGhpc3Rvcnkgc3RhdGUgdGhhdCB3YXMgc2V0IGlzIHByZXNlcnZlZCB3aGVuIGFwcGx5aW5nIHRoaXMgdXBkYXRlLlxuICAgICAgICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICBjYWNoZTogbmV3Q2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgICAgICB0cmVlOiB0cmVlVG9SZXN0b3JlLFxuICAgICAgICBuZXh0VXJsOiAoX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlID0gKDAsIF9jb21wdXRlY2hhbmdlZHBhdGguZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUpKHRyZWVUb1Jlc3RvcmUpKSAhPSBudWxsID8gX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIDogdXJsLnBhdGhuYW1lXG4gICAgfTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdG9yZS1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXN0b3JlUmVkdWNlciIsIl9jcmVhdGVocmVmZnJvbXVybCIsInJlcXVpcmUiLCJfY29tcHV0ZWNoYW5nZWRwYXRoIiwiX3Bwcm5hdmlnYXRpb25zIiwic3RhdGUiLCJhY3Rpb24iLCJ1cmwiLCJ0cmVlIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidHJlZVRvUmVzdG9yZSIsIm9sZENhY2hlIiwiY2FjaGUiLCJuZXdDYWNoZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUFBSIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiYnVpbGRJZCIsImNhbm9uaWNhbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwicHJlZmV0Y2hDYWNoZSIsIm5leHRVcmwiLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsInBhdGhuYW1lIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4622\n"));

/***/ }),

/***/ 862:
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js ***!
  \***************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverActionReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ 4281);\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ 824);\nconst _addbasepath = __webpack_require__(/*! ../../../add-base-path */ 5263);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 6808);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 1468);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 8082);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 8927);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 5013);\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ 6251);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 7679);\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ 7246);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 8249);\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ 5800);\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, encodeReply } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ 6671);\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const body = await encodeReply(actionArgs);\n    const res = await fetch(\"\", {\n        method: \"POST\",\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const location = res.headers.get(\"x-action-redirect\");\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get(\"x-action-revalidated\") || \"[[],0,0]\");\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? new URL((0, _addbasepath.addBasePath)(location), new URL(state.canonicalUrl, window.location.href)) : undefined;\n    let isFlightResponse = res.headers.get(\"content-type\") === _approuterheaders.RSC_CONTENT_TYPE_HEADER;\n    if (isFlightResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            const [, actionFlightData] = response != null ? response : [];\n            return {\n                actionFlightData: actionFlightData,\n                redirectLocation,\n                revalidatedParts\n            };\n        }\n        // otherwise it's a tuple of [actionResult, actionFlightData]\n        const [actionResult, [, actionFlightData]] = response != null ? response : [];\n        return {\n            actionResult,\n            actionFlightData,\n            redirectLocation,\n            revalidatedParts\n        };\n    }\n    return {\n        redirectLocation,\n        revalidatedParts\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action);\n    return mutable.inFlightServerAction.then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation } = param;\n        // Make sure the redirection is a push instead of a replace.\n        // Issue: https://github.com/vercel/next.js/issues/53911\n        if (redirectLocation) {\n            state.pushRef.pendingPush = true;\n            mutable.pendingPush = true;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === \"string\") {\n            // Handle case when navigating to page in `pages` from `app`\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.data as it has been resolved at this point.\n        mutable.inFlightServerAction = null;\n        if (redirectLocation) {\n            const newHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = newHref;\n        }\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log(\"SERVER ACTION APPLY FAILED\");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                \"\"\n            ], currentTree, treePatch, redirectLocation ? (0, _createhreffromurl.createHrefFromUrl)(redirectLocation) : state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null;\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (rsc !== null) {\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                    state,\n                    updatedTree: newTree,\n                    updatedCache: cache,\n                    includeNextUrl: Boolean(nextUrl),\n                    canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                });\n                mutable.cache = cache;\n                mutable.prefetchCache = new Map();\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        resolve(actionResult);\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NEM7SUFDcEQsR0FBRyxDQUFDakI7UUFDQSxtSEFBbUg7UUFDbkhnQixPQUFPaEI7UUFDUCxPQUFPM0I7SUFDWDtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU96QixRQUFRMkcsT0FBTyxLQUFLLGNBQWUsT0FBTzNHLFFBQVEyRyxPQUFPLEtBQUssWUFBWTNHLFFBQVEyRyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zRyxRQUFRMkcsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlHLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJHLE9BQU8sRUFBRSxjQUFjO1FBQUUxRyxPQUFPO0lBQUs7SUFDbkVILE9BQU8rRyxNQUFNLENBQUM3RyxRQUFRMkcsT0FBTyxFQUFFM0c7SUFDL0I4RyxPQUFPOUcsT0FBTyxHQUFHQSxRQUFRMkcsT0FBTztBQUNsQyxFQUVBLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci5qcz8wNjE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VydmVyQWN0aW9uUmVkdWNlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VydmVyQWN0aW9uUmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9hcHBjYWxsc2VydmVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2FwcC1jYWxsLXNlcnZlclwiKTtcbmNvbnN0IF9hcHByb3V0ZXJoZWFkZXJzID0gcmVxdWlyZShcIi4uLy4uL2FwcC1yb3V0ZXItaGVhZGVyc1wiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9hZGQtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2NyZWF0ZWhyZWZmcm9tdXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xuY29uc3QgX25hdmlnYXRlcmVkdWNlciA9IHJlcXVpcmUoXCIuL25hdmlnYXRlLXJlZHVjZXJcIik7XG5jb25zdCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlID0gcmVxdWlyZShcIi4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlXCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkID0gcmVxdWlyZShcIi4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuY29uc3QgX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSA9IHJlcXVpcmUoXCIuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlXCIpO1xuY29uc3QgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaFwiKTtcbmNvbnN0IF9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHNcIik7XG4vLyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4vLyBpbXBvcnQgeyBjcmVhdGVGcm9tRmV0Y2ggfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuLy8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IHsgZW5jb2RlUmVwbHkgfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuY29uc3QgeyBjcmVhdGVGcm9tRmV0Y2gsIGVuY29kZVJlcGx5IH0gPSAhIXByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA/IHJlcXVpcmUoXCJyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmVkZ2VcIikgOiByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudFwiKTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKHN0YXRlLCBuZXh0VXJsLCBwYXJhbSkge1xuICAgIGxldCB7IGFjdGlvbklkLCBhY3Rpb25BcmdzIH0gPSBwYXJhbTtcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgZW5jb2RlUmVwbHkoYWN0aW9uQXJncyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXCJcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBY2NlcHQ6IF9hcHByb3V0ZXJoZWFkZXJzLlJTQ19DT05URU5UX1RZUEVfSEVBREVSLFxuICAgICAgICAgICAgW19hcHByb3V0ZXJoZWFkZXJzLkFDVElPTl06IGFjdGlvbklkLFxuICAgICAgICAgICAgW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVdOiBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSkpLFxuICAgICAgICAgICAgLi4ucHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEID8ge1xuICAgICAgICAgICAgICAgIFwieC1kZXBsb3ltZW50LWlkXCI6IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgICAgLi4ubmV4dFVybCA/IHtcbiAgICAgICAgICAgICAgICBbX2FwcHJvdXRlcmhlYWRlcnMuTkVYVF9VUkxdOiBuZXh0VXJsXG4gICAgICAgICAgICB9IDoge31cbiAgICAgICAgfSxcbiAgICAgICAgYm9keVxuICAgIH0pO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMuZ2V0KFwieC1hY3Rpb24tcmVkaXJlY3RcIik7XG4gICAgbGV0IHJldmFsaWRhdGVkUGFydHM7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV2YWxpZGF0ZWRIZWFkZXIgPSBKU09OLnBhcnNlKHJlcy5oZWFkZXJzLmdldChcIngtYWN0aW9uLXJldmFsaWRhdGVkXCIpIHx8IFwiW1tdLDAsMF1cIik7XG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMgPSB7XG4gICAgICAgICAgICBwYXRoczogcmV2YWxpZGF0ZWRIZWFkZXJbMF0gfHwgW10sXG4gICAgICAgICAgICB0YWc6ICEhcmV2YWxpZGF0ZWRIZWFkZXJbMV0sXG4gICAgICAgICAgICBjb29raWU6IHJldmFsaWRhdGVkSGVhZGVyWzJdXG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXZhbGlkYXRlZFBhcnRzID0ge1xuICAgICAgICAgICAgcGF0aHM6IFtdLFxuICAgICAgICAgICAgdGFnOiBmYWxzZSxcbiAgICAgICAgICAgIGNvb2tpZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RMb2NhdGlvbiA9IGxvY2F0aW9uID8gbmV3IFVSTCgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShsb2NhdGlvbiksIC8vIEVuc3VyZSByZWxhdGl2ZSByZWRpcmVjdHMgaW4gU2VydmVyIEFjdGlvbnMgd29yaywgZS5nLiByZWRpcmVjdCgnLi9zb21ld2hlcmUtZWxzZScpXG4gICAgbmV3IFVSTChzdGF0ZS5jYW5vbmljYWxVcmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSByZXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgPT09IF9hcHByb3V0ZXJoZWFkZXJzLlJTQ19DT05URU5UX1RZUEVfSEVBREVSO1xuICAgIGlmIChpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlRnJvbUZldGNoKFByb21pc2UucmVzb2x2ZShyZXMpLCB7XG4gICAgICAgICAgICBjYWxsU2VydmVyOiBfYXBwY2FsbHNlcnZlci5jYWxsU2VydmVyXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IHdhcyBhIHJlZGlyZWN0aW9uLCB0aGVuIHJlc3VsdCBpcyBqdXN0IGEgcmVndWxhciBSU0MgcGF5bG9hZFxuICAgICAgICAgICAgY29uc3QgWywgYWN0aW9uRmxpZ2h0RGF0YV0gPSByZXNwb25zZSAhPSBudWxsID8gcmVzcG9uc2UgOiBbXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uRmxpZ2h0RGF0YTogYWN0aW9uRmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVkUGFydHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYSB0dXBsZSBvZiBbYWN0aW9uUmVzdWx0LCBhY3Rpb25GbGlnaHREYXRhXVxuICAgICAgICBjb25zdCBbYWN0aW9uUmVzdWx0LCBbLCBhY3Rpb25GbGlnaHREYXRhXV0gPSByZXNwb25zZSAhPSBudWxsID8gcmVzcG9uc2UgOiBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgICAgIGFjdGlvbkZsaWdodERhdGEsXG4gICAgICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRlZFBhcnRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlckFjdGlvblJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSBhY3Rpb247XG4gICAgY29uc3QgbXV0YWJsZSA9IHt9O1xuICAgIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmw7XG4gICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgLy8gb25seSBwYXNzIGFsb25nIHRoZSBgbmV4dFVybGAgcGFyYW0gKHVzZWQgZm9yIGludGVyY2VwdGlvbiByb3V0ZXMpIGlmIHRoZSBjdXJyZW50IHJvdXRlIHdhcyBpbnRlcmNlcHRlZC5cbiAgICAvLyBJZiB0aGUgcm91dGUgaGFzIGJlZW4gaW50ZXJjZXB0ZWQsIHRoZSBhY3Rpb24gc2hvdWxkIGJlIGFzIHdlbGwuXG4gICAgLy8gT3RoZXJ3aXNlIHRoZSBzZXJ2ZXIgYWN0aW9uIG1pZ2h0IGJlIGludGVyY2VwdGVkIHdpdGggdGhlIHdyb25nIGFjdGlvbiBpZFxuICAgIC8vIChpZSwgb25lIHRoYXQgY29ycmVzcG9uZHMgd2l0aCB0aGUgaW50ZXJjZXB0ZWQgcm91dGUpXG4gICAgY29uc3QgbmV4dFVybCA9IHN0YXRlLm5leHRVcmwgJiYgKDAsIF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUuaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKShzdGF0ZS50cmVlKSA/IHN0YXRlLm5leHRVcmwgOiBudWxsO1xuICAgIG11dGFibGUuaW5GbGlnaHRTZXJ2ZXJBY3Rpb24gPSBmZXRjaFNlcnZlckFjdGlvbihzdGF0ZSwgbmV4dFVybCwgYWN0aW9uKTtcbiAgICByZXR1cm4gbXV0YWJsZS5pbkZsaWdodFNlcnZlckFjdGlvbi50aGVuKGFzeW5jIChwYXJhbSk9PntcbiAgICAgICAgbGV0IHsgYWN0aW9uUmVzdWx0LCBhY3Rpb25GbGlnaHREYXRhOiBmbGlnaHREYXRhLCByZWRpcmVjdExvY2F0aW9uIH0gPSBwYXJhbTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZWRpcmVjdGlvbiBpcyBhIHB1c2ggaW5zdGVhZCBvZiBhIHJlcGxhY2UuXG4gICAgICAgIC8vIElzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzUzOTExXG4gICAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmxpZ2h0RGF0YSkge1xuICAgICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWRpcmVjdCBidXQgbm8gZmxpZ2h0IGRhdGEgd2UgbmVlZCB0byBkbyBhIG1wYU5hdmlnYXRpb24uXG4gICAgICAgICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5oYW5kbGVFeHRlcm5hbFVybCkoc3RhdGUsIG11dGFibGUsIHJlZGlyZWN0TG9jYXRpb24uaHJlZiwgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5oYW5kbGVFeHRlcm5hbFVybCkoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBjYWNoZS5kYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIG11dGFibGUuaW5GbGlnaHRTZXJ2ZXJBY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmV3SHJlZiA9ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHJlZGlyZWN0TG9jYXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gbmV3SHJlZjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZsaWdodERhdGFQYXRoIG9mIGZsaWdodERhdGEpe1xuICAgICAgICAgICAgLy8gRmxpZ2h0RGF0YVBhdGggd2l0aCBtb3JlIHRoYW4gdHdvIGl0ZW1zIG1lYW5zIHVuZXhwZWN0ZWQgRmxpZ2h0IGRhdGEgd2FzIHJldHVybmVkXG4gICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTRVJWRVIgQUNUSU9OIEFQUExZIEZBSUxFRFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgcnNjIGZvciB0aGUgcm9vdC5cbiAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgXSwgY3VycmVudFRyZWUsIHRyZWVQYXRjaCwgcmVkaXJlY3RMb2NhdGlvbiA/ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHJlZGlyZWN0TG9jYXRpb24pIDogc3RhdGUuY2Fub25pY2FsVXJsKTtcbiAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlc2VnbWVudG1pc21hdGNoLmhhbmRsZVNlZ21lbnRNaXNtYXRjaCkoc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dC5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5oYW5kbGVFeHRlcm5hbFVybCkoc3RhdGUsIG11dGFibGUsIGhyZWYsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICAgICAgY29uc3QgW2NhY2hlTm9kZVNlZWREYXRhLCBoZWFkXSA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0yKTtcbiAgICAgICAgICAgIGNvbnN0IHJzYyA9IGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsID8gY2FjaGVOb2RlU2VlZERhdGFbMl0gOiBudWxsO1xuICAgICAgICAgICAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIHByZWZldGNoIG9ubHkgcmV0dXJucyB0aGUgcm91dGVyIHRyZWUgcGF0Y2ggd2l0aG91dCByZW5kZXJlZCBjb21wb25lbnRzLlxuICAgICAgICAgICAgaWYgKHJzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gKDAsIF9hcHByb3V0ZXIuY3JlYXRlRW1wdHlDYWNoZU5vZGUpKCk7XG4gICAgICAgICAgICAgICAgY2FjaGUucnNjID0gcnNjO1xuICAgICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICAoMCwgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKShjYWNoZSwgLy8gRXhpc3RpbmcgY2FjaGUgaXMgbm90IHBhc3NlZCBpbiBhcyBgcm91dGVyLnJlZnJlc2goKWAgaGFzIHRvIGludmFsaWRhdGUgdGhlIGVudGlyZSBjYWNoZS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHRyZWVQYXRjaCwgY2FjaGVOb2RlU2VlZERhdGEsIGhlYWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cy5yZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzKSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkVHJlZTogbmV3VHJlZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZU5leHRVcmw6IEJvb2xlYW4obmV4dFVybCksXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmwgfHwgc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKGUpPT57XG4gICAgICAgIC8vIFdoZW4gdGhlIHNlcnZlciBhY3Rpb24gaXMgcmVqZWN0ZWQgd2UgZG9uJ3QgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgaW5zdGVhZCBjYWxsIHRoZSByZWplY3QgaGFuZGxlciBvZiB0aGUgcHJvbWlzZS5cbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1hY3Rpb24tcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VydmVyQWN0aW9uUmVkdWNlciIsIl9hcHBjYWxsc2VydmVyIiwicmVxdWlyZSIsIl9hcHByb3V0ZXJoZWFkZXJzIiwiX2FkZGJhc2VwYXRoIiwiX2NyZWF0ZWhyZWZmcm9tdXJsIiwiX25hdmlnYXRlcmVkdWNlciIsIl9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX2hhbmRsZW11dGFibGUiLCJfZmlsbGxhenlpdGVtc3RpbGxsZWFmd2l0aGhlYWQiLCJfYXBwcm91dGVyIiwiX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSIsIl9oYW5kbGVzZWdtZW50bWlzbWF0Y2giLCJfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyIsImNyZWF0ZUZyb21GZXRjaCIsImVuY29kZVJlcGx5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsImZldGNoU2VydmVyQWN0aW9uIiwic3RhdGUiLCJuZXh0VXJsIiwicGFyYW0iLCJhY3Rpb25JZCIsImFjdGlvbkFyZ3MiLCJib2R5IiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQWNjZXB0IiwiUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIiLCJBQ1RJT04iLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInRyZWUiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJORVhUX1VSTCIsImxvY2F0aW9uIiwicmV2YWxpZGF0ZWRQYXJ0cyIsInJldmFsaWRhdGVkSGVhZGVyIiwicGFyc2UiLCJwYXRocyIsInRhZyIsImNvb2tpZSIsImUiLCJyZWRpcmVjdExvY2F0aW9uIiwiVVJMIiwiYWRkQmFzZVBhdGgiLCJjYW5vbmljYWxVcmwiLCJ3aW5kb3ciLCJocmVmIiwidW5kZWZpbmVkIiwiaXNGbGlnaHRSZXNwb25zZSIsInJlc3BvbnNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYWxsU2VydmVyIiwiYWN0aW9uRmxpZ2h0RGF0YSIsImFjdGlvblJlc3VsdCIsImFjdGlvbiIsInJlamVjdCIsIm11dGFibGUiLCJjdXJyZW50VHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwiaW5GbGlnaHRTZXJ2ZXJBY3Rpb24iLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImhhbmRsZUV4dGVybmFsVXJsIiwibmV3SHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiZmxpZ2h0RGF0YVBhdGgiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsInNsaWNlIiwicnNjIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsInByZWZldGNoUnNjIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsIkJvb2xlYW4iLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///862\n"));

/***/ }),

/***/ 5940:
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js ***!
  \**************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverPatchReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 6808);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 8082);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 8927);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 1468);\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ 3333);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 5013);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 7679);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 8249);\nfunction serverPatchReducer(state, action) {\n    const { serverResponse } = action;\n    const [flightData, overrideCanonicalUrl] = serverResponse;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const flightDataPath of flightData){\n        // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n        const flightSegmentPath = flightDataPath.slice(0, -4);\n        const [treePatch] = flightDataPath.slice(-3, -2);\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            \"\",\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        if (newTree === null) {\n            return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = overrideCanonicalUrl ? (0, _createhreffromurl.createHrefFromUrl)(overrideCanonicalUrl) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVE0QyxPQUFPLEVBQUUsY0FBYztRQUFFM0MsT0FBTztJQUFLO0lBQ25FSCxPQUFPZ0QsTUFBTSxDQUFDOUMsUUFBUTRDLE9BQU8sRUFBRTVDO0lBQy9CK0MsT0FBTy9DLE9BQU8sR0FBR0EsUUFBUTRDLE9BQU87QUFDbEMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlci5qcz9kYWYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VydmVyUGF0Y2hSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJQYXRjaFJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG5jb25zdCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlID0gcmVxdWlyZShcIi4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlXCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbmNvbnN0IF9uYXZpZ2F0ZXJlZHVjZXIgPSByZXF1aXJlKFwiLi9uYXZpZ2F0ZS1yZWR1Y2VyXCIpO1xuY29uc3QgX2FwcGx5ZmxpZ2h0ZGF0YSA9IHJlcXVpcmUoXCIuLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuY29uc3QgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaFwiKTtcbmZ1bmN0aW9uIHNlcnZlclBhdGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBzZXJ2ZXJSZXNwb25zZSB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IFtmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybF0gPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICBjb25zdCBtdXRhYmxlID0ge307XG4gICAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlO1xuICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGU7XG4gICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKXtcbiAgICAgICAgLy8gU2xpY2VzIG9mZiB0aGUgbGFzdCBzZWdtZW50ICh3aGljaCBpcyBhdCAtNCkgYXMgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSB5ZXRcbiAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMsIC0yKTtcbiAgICAgICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBbXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgXSwgY3VycmVudFRyZWUsIHRyZWVQYXRjaCwgc3RhdGUuY2Fub25pY2FsVXJsKTtcbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaC5oYW5kbGVTZWdtZW50TWlzbWF0Y2gpKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0LmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBzdGF0ZS5jYW5vbmljYWxVcmwsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IG92ZXJyaWRlQ2Fub25pY2FsVXJsID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkob3ZlcnJpZGVDYW5vbmljYWxVcmwpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmKSB7XG4gICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgICAgICAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKGN1cnJlbnRDYWNoZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGU7XG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1wYXRjaC1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJfY3JlYXRlaHJlZmZyb211cmwiLCJyZXF1aXJlIiwiX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSIsIl9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQiLCJfbmF2aWdhdGVyZWR1Y2VyIiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsIl9oYW5kbGVtdXRhYmxlIiwiX2FwcHJvdXRlciIsIl9oYW5kbGVzZWdtZW50bWlzbWF0Y2giLCJzdGF0ZSIsImFjdGlvbiIsInNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwibXV0YWJsZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsImZsaWdodERhdGFQYXRoIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJzbGljZSIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJjYW5vbmljYWxVcmwiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5940\n"));

/***/ }),

/***/ 5800:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js ***!
  \*******************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ 3333);\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ 6969);\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ 8270);\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === \"refresh\" && // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        [\n            rootTree[0],\n            rootTree[1],\n            rootTree[2],\n            \"refetch\"\n        ], includeNextUrl ? state.nextUrl : null, state.buildId).then((fetchResponse)=>{\n            const flightData = fetchResponse[0];\n            if (typeof flightData !== \"string\") {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n                    // just been created & has been written to, but hasn't been \"committed\" yet.\n                    (0, _applyflightdata.applyFlightData)(updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== \"refresh\") {\n        tree[2] = path;\n        tree[3] = \"refresh\";\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFXO1FBQzVFb0IsSUFBSSxDQUFDLEVBQUUsR0FBR0M7UUFDVkQsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNkO0lBQ0EsSUFBSSxNQUFNSCxPQUFPbkIsZUFBZTtRQUM1QnZCLHlDQUF5Q3VCLGNBQWMsQ0FBQ21CLElBQUksRUFBRUk7SUFDbEU7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPakQsUUFBUXFELE9BQU8sS0FBSyxjQUFlLE9BQU9yRCxRQUFRcUQsT0FBTyxLQUFLLFlBQVlyRCxRQUFRcUQsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPckQsUUFBUXFELE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt4RCxPQUFPQyxjQUFjLENBQUNDLFFBQVFxRCxPQUFPLEVBQUUsY0FBYztRQUFFcEQsT0FBTztJQUFLO0lBQ25FSCxPQUFPeUQsTUFBTSxDQUFDdkQsUUFBUXFELE9BQU8sRUFBRXJEO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFxRCxPQUFPO0FBQ2xDLEVBRUEsOERBQThEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy5qcz81ZDI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50czogbnVsbCxcbiAgICByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cztcbiAgICB9LFxuICAgIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cztcbiAgICB9XG59KTtcbmNvbnN0IF9hcHBseWZsaWdodGRhdGEgPSByZXF1aXJlKFwiLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX3NlZ21lbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50XCIpO1xuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyhvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hlZFNlZ21lbnRzID0gbmV3IFNldCgpO1xuICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcm9vdFRyZWU6IG9wdGlvbnMudXBkYXRlZFRyZWUsXG4gICAgICAgIGZldGNoZWRTZWdtZW50c1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwocGFyYW0pIHtcbiAgICBsZXQgeyBzdGF0ZSwgdXBkYXRlZFRyZWUsIHVwZGF0ZWRDYWNoZSwgaW5jbHVkZU5leHRVcmwsIGZldGNoZWRTZWdtZW50cywgcm9vdFRyZWUgPSB1cGRhdGVkVHJlZSwgY2Fub25pY2FsVXJsIH0gPSBwYXJhbTtcbiAgICBjb25zdCBbLCBwYXJhbGxlbFJvdXRlcywgcmVmZXRjaFBhdGgsIHJlZmV0Y2hNYXJrZXJdID0gdXBkYXRlZFRyZWU7XG4gICAgY29uc3QgZmV0Y2hQcm9taXNlcyA9IFtdO1xuICAgIGlmIChyZWZldGNoUGF0aCAmJiByZWZldGNoUGF0aCAhPT0gY2Fub25pY2FsVXJsICYmIHJlZmV0Y2hNYXJrZXIgPT09IFwicmVmcmVzaFwiICYmIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSB0cmVlIHRvIGNvbnRhaW4gbXVsdGlwbGUgc2VnbWVudHMgdGhhdCBjb250YWluIGRhdGEgYXQgdGhlIHNhbWUgVVJMXG4gICAgLy8gd2Uga2VlcCB0cmFjayBvZiB0aGVtIHNvIHdlIGNhbiBkZWR1cGUgdGhlIHJlcXVlc3RzXG4gICAgIWZldGNoZWRTZWdtZW50cy5oYXMocmVmZXRjaFBhdGgpKSB7XG4gICAgICAgIGZldGNoZWRTZWdtZW50cy5hZGQocmVmZXRjaFBhdGgpIC8vIE1hcmsgdGhpcyBVUkwgYXMgZmV0Y2hlZFxuICAgICAgICA7XG4gICAgICAgIC8vIEVhZ2VybHkga2ljayBvZmYgdGhlIGZldGNoIGZvciB0aGUgcmVmZXRjaCBwYXRoICYgdGhlIHBhcmFsbGVsIHJvdXRlcy4gVGhpcyBzaG91bGQgYmUgZmluZSB0byBkbyBhcyB0aGV5IGVhY2ggb3BlcmF0ZVxuICAgICAgICAvLyBpbmRlcGVuZGVudGx5IG9uIHRoZWlyIG93biBjYWNoZSBub2RlcywgYW5kIGBhcHBseUZsaWdodERhdGFgIHdpbGwgY29weSBhbnl0aGluZyBpdCBkb2Vzbid0IGNhcmUgYWJvdXQgZnJvbSB0aGUgZXhpc3RpbmcgY2FjaGUuXG4gICAgICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9ICgwLCBfZmV0Y2hzZXJ2ZXJyZXNwb25zZS5mZXRjaFNlcnZlclJlc3BvbnNlKShuZXcgVVJMKHJlZmV0Y2hQYXRoLCBsb2NhdGlvbi5vcmlnaW4pLCAvLyByZWZldGNoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHVwZGF0ZWQgdHJlZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgc2NvcGVkIHRvIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgICAgLy8gYW5kIG1pZ2h0IG5vdCBjb250YWluIHRoZSBkYXRhIHdlIG5lZWQgdG8gcGF0Y2ggaW4gaW50ZXJjZXB0aW9uIHJvdXRlIGRhdGEgKHN1Y2ggYXMgZHluYW1pYyBwYXJhbXMgZnJvbSBhIHByZXZpb3VzIHNlZ21lbnQpXG4gICAgICAgIFtcbiAgICAgICAgICAgIHJvb3RUcmVlWzBdLFxuICAgICAgICAgICAgcm9vdFRyZWVbMV0sXG4gICAgICAgICAgICByb290VHJlZVsyXSxcbiAgICAgICAgICAgIFwicmVmZXRjaFwiXG4gICAgICAgIF0sIGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsIHN0YXRlLmJ1aWxkSWQpLnRoZW4oKGZldGNoUmVzcG9uc2UpPT57XG4gICAgICAgICAgICBjb25zdCBmbGlnaHREYXRhID0gZmV0Y2hSZXNwb25zZVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG9ubHkgcGFzcyB0aGUgbmV3IGNhY2hlIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGNsZWFyaW5nIHRoZSByb3V0ZXIgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGZpbGxpbmcgaW4gdGhlIG5ldyBwYWdlIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBNZWFuaW5nIHRoZSBleGlzdGluZyBjYWNoZSBpcyBhY3R1YWxseSB0aGUgY2FjaGUgdGhhdCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYmVlbiBjcmVhdGVkICYgaGFzIGJlZW4gd3JpdHRlbiB0bywgYnV0IGhhc24ndCBiZWVuIFwiY29tbWl0dGVkXCIgeWV0LlxuICAgICAgICAgICAgICAgICAgICAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKHVwZGF0ZWRDYWNoZSwgdXBkYXRlZENhY2hlLCBmbGlnaHREYXRhUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZmxpZ2h0RGF0YSBpcyBhIHN0cmluZywgaXQgc3VnZ2VzdHMgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIHNob3VsZCBoYXZlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvblxuICAgICAgICAgICAgLy8gSSdtIG5vdCAxMDAlIHN1cmUgb2YgdGhpcyBkZWNpc2lvbiwgYnV0IGl0IHNlZW1zIHVubGlrZWx5IHRoYXQgd2UnZCB3YW50IHRvIGludHJvZHVjZSBhIHJlZGlyZWN0IHNpZGUgZWZmZWN0XG4gICAgICAgICAgICAvLyB3aGVuIHJlZnJlc2hpbmcgb24tc2NyZWVuIGRhdGEsIHNvIGhhbmRsaW5nIHRoaXMgaGFzIGJlZW4gb21taXR0ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmZXRjaFByb21pc2VzLnB1c2goZmV0Y2hQcm9taXNlKTtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsRmV0Y2hQcm9taXNlID0gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB1cGRhdGVkVHJlZTogcGFyYWxsZWxSb3V0ZXNba2V5XSxcbiAgICAgICAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgICAgICAgIGluY2x1ZGVOZXh0VXJsLFxuICAgICAgICAgICAgZmV0Y2hlZFNlZ21lbnRzLFxuICAgICAgICAgICAgcm9vdFRyZWUsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGZldGNoUHJvbWlzZXMucHVzaChwYXJhbGxlbEZldGNoUHJvbWlzZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGZldGNoUHJvbWlzZXMpO1xufVxuZnVuY3Rpb24gYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyh0cmVlLCBwYXRoKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsIHJlZmV0Y2hNYXJrZXJdID0gdHJlZTtcbiAgICAvLyBhIHBhZ2Ugc2VnbWVudCBtaWdodCBhbHNvIGNvbnRhaW4gY29uY2F0ZW5hdGVkIHNlYXJjaCBwYXJhbXMsIHNvIHdlIGRvIGEgcGFydGlhbCBtYXRjaCBvbiB0aGUga2V5XG4gICAgaWYgKHNlZ21lbnQuaW5jbHVkZXMoX3NlZ21lbnQuUEFHRV9TRUdNRU5UX0tFWSkgJiYgcmVmZXRjaE1hcmtlciAhPT0gXCJyZWZyZXNoXCIpIHtcbiAgICAgICAgdHJlZVsyXSA9IHBhdGg7XG4gICAgICAgIHRyZWVbM10gPSBcInJlZnJlc2hcIjtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMocGFyYWxsZWxSb3V0ZXNba2V5XSwgcGF0aCk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsInJlcXVpcmUiLCJfZmV0Y2hzZXJ2ZXJyZXNwb25zZSIsIl9zZWdtZW50Iiwib3B0aW9ucyIsImZldGNoZWRTZWdtZW50cyIsIlNldCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsIiwicm9vdFRyZWUiLCJ1cGRhdGVkVHJlZSIsInBhcmFtIiwic3RhdGUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsImNhbm9uaWNhbFVybCIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFBhdGgiLCJyZWZldGNoTWFya2VyIiwiZmV0Y2hQcm9taXNlcyIsImhhcyIsImFkZCIsImZldGNoUHJvbWlzZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsImZldGNoUmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJhcHBseUZsaWdodERhdGEiLCJwdXNoIiwia2V5IiwicGFyYWxsZWxGZXRjaFByb21pc2UiLCJQcm9taXNlIiwidHJlZSIsInBhdGgiLCJzZWdtZW50IiwiaW5jbHVkZXMiLCJQQUdFX1NFR01FTlRfS0VZIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5800\n"));

/***/ }),

/***/ 5910:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_FAST_REFRESH: function() {\n        return ACTION_FAST_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    },\n    isThenable: function() {\n        return isThenable;\n    }\n});\nconst ACTION_REFRESH = \"refresh\";\nconst ACTION_NAVIGATE = \"navigate\";\nconst ACTION_RESTORE = \"restore\";\nconst ACTION_SERVER_PATCH = \"server-patch\";\nconst ACTION_PREFETCH = \"prefetch\";\nconst ACTION_FAST_REFRESH = \"fast-refresh\";\nconst ACTION_SERVER_ACTION = \"server-action\";\nvar PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n})(PrefetchKind || (PrefetchKind = {}));\nvar PrefetchCacheEntryStatus;\n(function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\n})(PrefetchCacheEntryStatus || (PrefetchCacheEntryStatus = {}));\nfunction isThenable(value) {\n    // TODO: We don't gain anything from this abstraction. It's unsound, and only\n    // makes sense in the specific places where we use it. So it's better to keep\n    // the type coercion inline, instead of leaking this to other places in\n    // the codebase.\n    return value && (typeof value === \"object\" || typeof value === \"function\") && typeof value.then === \"function\";\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkxMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQVdOO0FBQ0EsU0FBU1csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSWpCLE9BQU9DLGNBQWMsQ0FBQ2UsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRYixTQUFTO0lBQ2JHLHFCQUFxQjtRQUNqQixPQUFPQTtJQUNYO0lBQ0FDLGlCQUFpQjtRQUNiLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT0E7SUFDWDtJQUNBQyxnQkFBZ0I7UUFDWixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsMEJBQTBCO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQUMsY0FBYztRQUNWLE9BQU9BO0lBQ1g7SUFDQUMsWUFBWTtRQUNSLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1OLGlCQUFpQjtBQUN2QixNQUFNRixrQkFBa0I7QUFDeEIsTUFBTUcsaUJBQWlCO0FBQ3ZCLE1BQU1FLHNCQUFzQjtBQUM1QixNQUFNSixrQkFBa0I7QUFDeEIsTUFBTUYsc0JBQXNCO0FBQzVCLE1BQU1LLHVCQUF1QjtBQUM3QixJQUFJRztBQUNILFVBQVNBLFlBQVk7SUFDbEJBLFlBQVksQ0FBQyxPQUFPLEdBQUc7SUFDdkJBLFlBQVksQ0FBQyxPQUFPLEdBQUc7SUFDdkJBLFlBQVksQ0FBQyxZQUFZLEdBQUc7QUFDaEMsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEMsSUFBSUQ7QUFDSCxVQUFTQSx3QkFBd0I7SUFDOUJBLHdCQUF3QixDQUFDLFFBQVEsR0FBRztJQUNwQ0Esd0JBQXdCLENBQUMsV0FBVyxHQUFHO0lBQ3ZDQSx3QkFBd0IsQ0FBQyxVQUFVLEdBQUc7SUFDdENBLHdCQUF3QixDQUFDLFFBQVEsR0FBRztBQUN4QyxHQUFHQSw0QkFBNkJBLENBQUFBLDJCQUEyQixDQUFDO0FBQzVELFNBQVNFLFdBQVdYLEtBQUs7SUFDckIsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSx1RUFBdUU7SUFDdkUsZ0JBQWdCO0lBQ2hCLE9BQU9BLFNBQVUsUUFBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsVUFBUyxLQUFNLE9BQU9BLE1BQU1rQixJQUFJLEtBQUs7QUFDeEc7QUFFQSxJQUFJLENBQUMsT0FBT25CLFFBQVFvQixPQUFPLEtBQUssY0FBZSxPQUFPcEIsUUFBUW9CLE9BQU8sS0FBSyxZQUFZcEIsUUFBUW9CLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3BCLFFBQVFvQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRb0IsT0FBTyxFQUFFLGNBQWM7UUFBRW5CLE9BQU87SUFBSztJQUNuRUgsT0FBT3dCLE1BQU0sQ0FBQ3RCLFFBQVFvQixPQUFPLEVBQUVwQjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRb0IsT0FBTztBQUNsQyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzPzY1N2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQ1RJT05fRkFTVF9SRUZSRVNIOiBudWxsLFxuICAgIEFDVElPTl9OQVZJR0FURTogbnVsbCxcbiAgICBBQ1RJT05fUFJFRkVUQ0g6IG51bGwsXG4gICAgQUNUSU9OX1JFRlJFU0g6IG51bGwsXG4gICAgQUNUSU9OX1JFU1RPUkU6IG51bGwsXG4gICAgQUNUSU9OX1NFUlZFUl9BQ1RJT046IG51bGwsXG4gICAgQUNUSU9OX1NFUlZFUl9QQVRDSDogbnVsbCxcbiAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXM6IG51bGwsXG4gICAgUHJlZmV0Y2hLaW5kOiBudWxsLFxuICAgIGlzVGhlbmFibGU6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgQUNUSU9OX0ZBU1RfUkVGUkVTSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fRkFTVF9SRUZSRVNIO1xuICAgIH0sXG4gICAgQUNUSU9OX05BVklHQVRFOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9OQVZJR0FURTtcbiAgICB9LFxuICAgIEFDVElPTl9QUkVGRVRDSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUFJFRkVUQ0g7XG4gICAgfSxcbiAgICBBQ1RJT05fUkVGUkVTSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUkVGUkVTSDtcbiAgICB9LFxuICAgIEFDVElPTl9SRVNUT1JFOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9SRVNUT1JFO1xuICAgIH0sXG4gICAgQUNUSU9OX1NFUlZFUl9BQ1RJT046IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1NFUlZFUl9BQ1RJT047XG4gICAgfSxcbiAgICBBQ1RJT05fU0VSVkVSX1BBVENIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9TRVJWRVJfUEFUQ0g7XG4gICAgfSxcbiAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzO1xuICAgIH0sXG4gICAgUHJlZmV0Y2hLaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByZWZldGNoS2luZDtcbiAgICB9LFxuICAgIGlzVGhlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNUaGVuYWJsZTtcbiAgICB9XG59KTtcbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gXCJyZWZyZXNoXCI7XG5jb25zdCBBQ1RJT05fTkFWSUdBVEUgPSBcIm5hdmlnYXRlXCI7XG5jb25zdCBBQ1RJT05fUkVTVE9SRSA9IFwicmVzdG9yZVwiO1xuY29uc3QgQUNUSU9OX1NFUlZFUl9QQVRDSCA9IFwic2VydmVyLXBhdGNoXCI7XG5jb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSBcInByZWZldGNoXCI7XG5jb25zdCBBQ1RJT05fRkFTVF9SRUZSRVNIID0gXCJmYXN0LXJlZnJlc2hcIjtcbmNvbnN0IEFDVElPTl9TRVJWRVJfQUNUSU9OID0gXCJzZXJ2ZXItYWN0aW9uXCI7XG52YXIgUHJlZmV0Y2hLaW5kO1xuKGZ1bmN0aW9uKFByZWZldGNoS2luZCkge1xuICAgIFByZWZldGNoS2luZFtcIkFVVE9cIl0gPSBcImF1dG9cIjtcbiAgICBQcmVmZXRjaEtpbmRbXCJGVUxMXCJdID0gXCJmdWxsXCI7XG4gICAgUHJlZmV0Y2hLaW5kW1wiVEVNUE9SQVJZXCJdID0gXCJ0ZW1wb3JhcnlcIjtcbn0pKFByZWZldGNoS2luZCB8fCAoUHJlZmV0Y2hLaW5kID0ge30pKTtcbnZhciBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXM7XG4oZnVuY3Rpb24oUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzKSB7XG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzW1wiZnJlc2hcIl0gPSBcImZyZXNoXCI7XG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzW1wicmV1c2FibGVcIl0gPSBcInJldXNhYmxlXCI7XG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzW1wiZXhwaXJlZFwiXSA9IFwiZXhwaXJlZFwiO1xuICAgIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1c1tcInN0YWxlXCJdID0gXCJzdGFsZVwiO1xufSkoUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIHx8IChQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMgPSB7fSkpO1xuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xuICAgIC8vIFRPRE86IFdlIGRvbid0IGdhaW4gYW55dGhpbmcgZnJvbSB0aGlzIGFic3RyYWN0aW9uLiBJdCdzIHVuc291bmQsIGFuZCBvbmx5XG4gICAgLy8gbWFrZXMgc2Vuc2UgaW4gdGhlIHNwZWNpZmljIHBsYWNlcyB3aGVyZSB3ZSB1c2UgaXQuIFNvIGl0J3MgYmV0dGVyIHRvIGtlZXBcbiAgICAvLyB0aGUgdHlwZSBjb2VyY2lvbiBpbmxpbmUsIGluc3RlYWQgb2YgbGVha2luZyB0aGlzIHRvIG90aGVyIHBsYWNlcyBpblxuICAgIC8vIHRoZSBjb2RlYmFzZS5cbiAgICByZXR1cm4gdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXItdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiQUNUSU9OX0ZBU1RfUkVGUkVTSCIsIkFDVElPTl9OQVZJR0FURSIsIkFDVElPTl9QUkVGRVRDSCIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJQcmVmZXRjaEtpbmQiLCJpc1RoZW5hYmxlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidGhlbiIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5910\n"));

/***/ }),

/***/ 7198:
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer.js ***!
  \***********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"reducer\", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ 5910);\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ 1468);\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ 5940);\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ 4622);\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ 4418);\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ 4749);\nconst _fastrefreshreducer = __webpack_require__(/*! ./reducers/fast-refresh-reducer */ 1142);\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ 862);\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_FAST_REFRESH:\n            {\n                return (0, _fastrefreshreducer.fastRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer = typeof window === \"undefined\" ? serverReducer : clientReducer;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE5OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyxrQ0FBd0I7QUFDNUQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx1Q0FBNkI7QUFDOUQsTUFBTUUsc0JBQXNCRixtQkFBT0EsQ0FBQywyQ0FBaUM7QUFDckUsTUFBTUcsa0JBQWtCSCxtQkFBT0EsQ0FBQyxzQ0FBNEI7QUFDNUQsTUFBTUksa0JBQWtCSixtQkFBT0EsQ0FBQyxzQ0FBNEI7QUFDNUQsTUFBTUssbUJBQW1CTCxtQkFBT0EsQ0FBQyx1Q0FBNkI7QUFDOUQsTUFBTU0sc0JBQXNCTixtQkFBT0EsQ0FBQywyQ0FBaUM7QUFDckUsTUFBTU8sdUJBQXVCUCxtQkFBT0EsQ0FBQywyQ0FBa0M7QUFDdkU7O0NBRUMsR0FBRyxTQUFTUSxjQUFjQyxLQUFLLEVBQUVDLE1BQU07SUFDcEMsT0FBT0EsT0FBT0MsSUFBSTtRQUNkLEtBQUtaLG9CQUFvQmEsZUFBZTtZQUNwQztnQkFDSSxPQUFPLENBQUMsR0FBR1gsaUJBQWlCWSxlQUFlLEVBQUVKLE9BQU9DO1lBQ3hEO1FBQ0osS0FBS1gsb0JBQW9CZSxtQkFBbUI7WUFDeEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdaLG9CQUFvQmEsa0JBQWtCLEVBQUVOLE9BQU9DO1lBQzlEO1FBQ0osS0FBS1gsb0JBQW9CaUIsY0FBYztZQUNuQztnQkFDSSxPQUFPLENBQUMsR0FBR2IsZ0JBQWdCYyxjQUFjLEVBQUVSLE9BQU9DO1lBQ3REO1FBQ0osS0FBS1gsb0JBQW9CbUIsY0FBYztZQUNuQztnQkFDSSxPQUFPLENBQUMsR0FBR2QsZ0JBQWdCZSxjQUFjLEVBQUVWLE9BQU9DO1lBQ3REO1FBQ0osS0FBS1gsb0JBQW9CcUIsbUJBQW1CO1lBQ3hDO2dCQUNJLE9BQU8sQ0FBQyxHQUFHZCxvQkFBb0JlLGtCQUFrQixFQUFFWixPQUFPQztZQUM5RDtRQUNKLEtBQUtYLG9CQUFvQnVCLGVBQWU7WUFDcEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdqQixpQkFBaUJrQixlQUFlLEVBQUVkLE9BQU9DO1lBQ3hEO1FBQ0osS0FBS1gsb0JBQW9CeUIsb0JBQW9CO1lBQ3pDO2dCQUNJLE9BQU8sQ0FBQyxHQUFHakIscUJBQXFCa0IsbUJBQW1CLEVBQUVoQixPQUFPQztZQUNoRTtRQUNKLCtEQUErRDtRQUMvRDtZQUNJLE1BQU0sSUFBSWdCLE1BQU07SUFDeEI7QUFDSjtBQUNBLFNBQVNDLGNBQWNsQixLQUFLLEVBQUVtQixPQUFPO0lBQ2pDLE9BQU9uQjtBQUNYO0FBQ0EsTUFBTVgsVUFBVSxPQUFPK0IsV0FBVyxjQUFjRixnQkFBZ0JuQjtBQUVoRSxJQUFJLENBQUMsT0FBT2QsUUFBUW9DLE9BQU8sS0FBSyxjQUFlLE9BQU9wQyxRQUFRb0MsT0FBTyxLQUFLLFlBQVlwQyxRQUFRb0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPcEMsUUFBUW9DLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt2QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFvQyxPQUFPLEVBQUUsY0FBYztRQUFFbkMsT0FBTztJQUFLO0lBQ25FSCxPQUFPd0MsTUFBTSxDQUFDdEMsUUFBUW9DLE9BQU8sRUFBRXBDO0lBQy9CdUMsT0FBT3ZDLE9BQU8sR0FBR0EsUUFBUW9DLE9BQU87QUFDbEMsRUFFQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci5qcz8xZGRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVkdWNlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9yb3V0ZXJyZWR1Y2VydHlwZXMgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcbmNvbnN0IF9uYXZpZ2F0ZXJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyXCIpO1xuY29uc3QgX3NlcnZlcnBhdGNocmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyXCIpO1xuY29uc3QgX3Jlc3RvcmVyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyXCIpO1xuY29uc3QgX3JlZnJlc2hyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyXCIpO1xuY29uc3QgX3ByZWZldGNocmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXJcIik7XG5jb25zdCBfZmFzdHJlZnJlc2hyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvZmFzdC1yZWZyZXNoLXJlZHVjZXJcIik7XG5jb25zdCBfc2VydmVyYWN0aW9ucmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlclwiKTtcbi8qKlxuICogUmVkdWNlciB0aGF0IGhhbmRsZXMgdGhlIGFwcC1yb3V0ZXIgc3RhdGUgdXBkYXRlcy5cbiAqLyBmdW5jdGlvbiBjbGllbnRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2goYWN0aW9uLnR5cGUpe1xuICAgICAgICBjYXNlIF9yb3V0ZXJyZWR1Y2VydHlwZXMuQUNUSU9OX05BVklHQVRFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5uYXZpZ2F0ZVJlZHVjZXIpKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJyZWR1Y2VydHlwZXMuQUNUSU9OX1NFUlZFUl9QQVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zZXJ2ZXJwYXRjaHJlZHVjZXIuc2VydmVyUGF0Y2hSZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9SRVNUT1JFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3RvcmVyZWR1Y2VyLnJlc3RvcmVSZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9SRUZSRVNIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3JlZnJlc2hyZWR1Y2VyLnJlZnJlc2hSZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9GQVNUX1JFRlJFU0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZmFzdHJlZnJlc2hyZWR1Y2VyLmZhc3RSZWZyZXNoUmVkdWNlcikoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlcnJlZHVjZXJ0eXBlcy5BQ1RJT05fUFJFRkVUQ0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfcHJlZmV0Y2hyZWR1Y2VyLnByZWZldGNoUmVkdWNlcikoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlcnJlZHVjZXJ0eXBlcy5BQ1RJT05fU0VSVkVSX0FDVElPTjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zZXJ2ZXJhY3Rpb25yZWR1Y2VyLnNlcnZlckFjdGlvblJlZHVjZXIpKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGJlIGhpdCBhcyBkaXNwYXRjaCBpcyBzdHJvbmdseSB0eXBlZC5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcnZlclJlZHVjZXIoc3RhdGUsIF9hY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCByZWR1Y2VyID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHNlcnZlclJlZHVjZXIgOiBjbGllbnRSZWR1Y2VyO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicmVkdWNlciIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJyZXF1aXJlIiwiX25hdmlnYXRlcmVkdWNlciIsIl9zZXJ2ZXJwYXRjaHJlZHVjZXIiLCJfcmVzdG9yZXJlZHVjZXIiLCJfcmVmcmVzaHJlZHVjZXIiLCJfcHJlZmV0Y2hyZWR1Y2VyIiwiX2Zhc3RyZWZyZXNocmVkdWNlciIsIl9zZXJ2ZXJhY3Rpb25yZWR1Y2VyIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIkFDVElPTl9OQVZJR0FURSIsIm5hdmlnYXRlUmVkdWNlciIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJBQ1RJT05fUkVTVE9SRSIsInJlc3RvcmVSZWR1Y2VyIiwiQUNUSU9OX1JFRlJFU0giLCJyZWZyZXNoUmVkdWNlciIsIkFDVElPTl9GQVNUX1JFRlJFU0giLCJmYXN0UmVmcmVzaFJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJwcmVmZXRjaFJlZHVjZXIiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsInNlcnZlckFjdGlvblJlZHVjZXIiLCJFcnJvciIsInNlcnZlclJlZHVjZXIiLCJfYWN0aW9uIiwid2luZG93IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7198\n"));

/***/ }),

/***/ 5805:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"shouldHardNavigate\", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ 6880);\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgwNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsaUJBQWlCQyxtQkFBT0EsQ0FBQyw2QkFBbUI7QUFDbEQsU0FBU0YsbUJBQW1CRyxpQkFBaUIsRUFBRUMsaUJBQWlCO0lBQzVELE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNsQywyQ0FBMkM7SUFDM0MsTUFBTSxDQUFDRyxnQkFBZ0JDLGlCQUFpQixHQUFHTDtJQUMzQyx5REFBeUQ7SUFDekQsSUFBSSxDQUFDLENBQUMsR0FBR0YsZUFBZVEsWUFBWSxFQUFFRixnQkFBZ0JGLFVBQVU7UUFDNUQsa0dBQWtHO1FBQ2xHLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osaUJBQWlCO1lBQy9CLE9BQU87UUFDWDtRQUNBLHNFQUFzRTtRQUN0RSxPQUFPO0lBQ1g7SUFDQSxNQUFNSyxjQUFjVCxrQkFBa0JVLE1BQU0sSUFBSTtJQUNoRCxJQUFJRCxhQUFhO1FBQ2IsT0FBTztJQUNYO0lBQ0EsT0FBT1osbUJBQW1CRyxrQkFBa0JXLEtBQUssQ0FBQyxJQUFJUixjQUFjLENBQUNFLGlCQUFpQjtBQUMxRjtBQUVBLElBQUksQ0FBQyxPQUFPWixRQUFRbUIsT0FBTyxLQUFLLGNBQWUsT0FBT25CLFFBQVFtQixPQUFPLEtBQUssWUFBWW5CLFFBQVFtQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9uQixRQUFRbUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1CLE9BQU8sRUFBRSxjQUFjO1FBQUVsQixPQUFPO0lBQUs7SUFDbkVILE9BQU91QixNQUFNLENBQUNyQixRQUFRbUIsT0FBTyxFQUFFbkI7SUFDL0JzQixPQUFPdEIsT0FBTyxHQUFHQSxRQUFRbUIsT0FBTztBQUNsQyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Nob3VsZC1oYXJkLW5hdmlnYXRlLmpzPzY2MzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaG91bGRIYXJkTmF2aWdhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZEhhcmROYXZpZ2F0ZTtcbiAgICB9XG59KTtcbmNvbnN0IF9tYXRjaHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL21hdGNoLXNlZ21lbnRzXCIpO1xuZnVuY3Rpb24gc2hvdWxkSGFyZE5hdmlnYXRlKGZsaWdodFNlZ21lbnRQYXRoLCBmbGlnaHRSb3V0ZXJTdGF0ZSkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBUT0RPLUFQUDogQ2hlY2sgaWYgYGFzYCBjYW4gYmUgcmVwbGFjZWQuXG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgc2VnbWVudCBtYXRjaGVzIHRoZSBleGlzdGluZyBzZWdtZW50LlxuICAgIGlmICghKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkoY3VycmVudFNlZ21lbnQsIHNlZ21lbnQpKSB7XG4gICAgICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGV4aXN0aW5nIHNlZ21lbnQgZGlkIG5vdCBtYXRjaCBzb2Z0IG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoIDw9IDI7XG4gICAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaG91bGQtaGFyZC1uYXZpZ2F0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiX21hdGNoc2VnbWVudHMiLCJyZXF1aXJlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsImN1cnJlbnRTZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsIm1hdGNoU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImxhc3RTZWdtZW50IiwibGVuZ3RoIiwic2xpY2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5805\n"));

/***/ })

}]);