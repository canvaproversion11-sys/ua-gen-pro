"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_next_dist_client_components_react-dev-overlay_app_R";
exports.ids = ["vendors-node_modules_next_dist_client_components_react-dev-overlay_app_R"];
exports.modules = {

/***/ 7558:
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/app/ReactDevOverlay.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return ReactDevOverlay;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ 6870);\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ 7247);\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ 8964));\nconst _shared = __webpack_require__(/*! ../shared */ 5745);\nconst _ShadowPortal = __webpack_require__(/*! ../internal/components/ShadowPortal */ 6902);\nconst _BuildError = __webpack_require__(/*! ../internal/container/BuildError */ 3742);\nconst _Errors = __webpack_require__(/*! ../internal/container/Errors */ 5948);\nconst _parseStack = __webpack_require__(/*! ../internal/helpers/parseStack */ 7648);\nconst _Base = __webpack_require__(/*! ../internal/styles/Base */ 5595);\nconst _ComponentStyles = __webpack_require__(/*! ../internal/styles/ComponentStyles */ 1839);\nconst _CssReset = __webpack_require__(/*! ../internal/styles/CssReset */ 9993);\nconst _rootlayoutmissingtagserror = __webpack_require__(/*! ../internal/container/root-layout-missing-tags-error */ 5872);\nclass ReactDevOverlay extends _react.PureComponent {\n    static getDerivedStateFromError(error) {\n        if (!error.stack) return {\n            reactError: null\n        };\n        return {\n            reactError: {\n                id: 0,\n                event: {\n                    type: _shared.ACTION_UNHANDLED_ERROR,\n                    reason: error,\n                    frames: (0, _parseStack.parseStack)(error.stack)\n                }\n            }\n        };\n    }\n    componentDidCatch(componentErr) {\n        this.props.onReactError(componentErr);\n    }\n    render() {\n        var _state_rootLayoutMissingTags, _state_rootLayoutMissingTags1;\n        const { state, children } = this.props;\n        const { reactError } = this.state;\n        const hasBuildError = state.buildError != null;\n        const hasRuntimeErrors = Boolean(state.errors.length);\n        const hasMissingTags = Boolean((_state_rootLayoutMissingTags = state.rootLayoutMissingTags) == null ? void 0 : _state_rootLayoutMissingTags.length);\n        const isMounted = hasBuildError || hasRuntimeErrors || reactError || hasMissingTags;\n        return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n            children: [\n                reactError ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"html\", {\n                    children: [\n                        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"head\", {}),\n                        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"body\", {})\n                    ]\n                }) : children,\n                isMounted ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(_ShadowPortal.ShadowPortal, {\n                    children: [\n                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_CssReset.CssReset, {}),\n                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_Base.Base, {}),\n                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_ComponentStyles.ComponentStyles, {}),\n                        ((_state_rootLayoutMissingTags1 = state.rootLayoutMissingTags) == null ? void 0 : _state_rootLayoutMissingTags1.length) ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_rootlayoutmissingtagserror.RootLayoutMissingTagsError, {\n                            missingTags: state.rootLayoutMissingTags\n                        }) : hasBuildError ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_BuildError.BuildError, {\n                            message: state.buildError,\n                            versionInfo: state.versionInfo\n                        }) : reactError ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_Errors.Errors, {\n                            isAppDir: true,\n                            versionInfo: state.versionInfo,\n                            initialDisplayState: \"fullscreen\",\n                            errors: [\n                                reactError\n                            ]\n                        }) : hasRuntimeErrors ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_Errors.Errors, {\n                            isAppDir: true,\n                            initialDisplayState: \"minimized\",\n                            errors: state.errors,\n                            versionInfo: state.versionInfo\n                        }) : undefined\n                    ]\n                }) : undefined\n            ]\n        });\n    }\n    constructor(...args){\n        super(...args);\n        this.state = {\n            reactError: null\n        };\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ReactDevOverlay.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUksS0FBTSxPQUFPbkUsUUFBUW1FLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0RSxPQUFPQyxjQUFjLENBQUNDLFFBQVFtRSxPQUFPLEVBQUUsY0FBYztRQUFFbEUsT0FBTztJQUFLO0lBQ25FSCxPQUFPdUUsTUFBTSxDQUFDckUsUUFBUW1FLE9BQU8sRUFBRW5FO0lBQy9Cc0UsT0FBT3RFLE9BQU8sR0FBR0EsUUFBUW1FLE9BQU87QUFDbEMsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9hcHAvUmVhY3REZXZPdmVybGF5LmpzPzFkYzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdERldk92ZXJsYXk7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfc2hhcmVkID0gcmVxdWlyZShcIi4uL3NoYXJlZFwiKTtcbmNvbnN0IF9TaGFkb3dQb3J0YWwgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvY29tcG9uZW50cy9TaGFkb3dQb3J0YWxcIik7XG5jb25zdCBfQnVpbGRFcnJvciA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9jb250YWluZXIvQnVpbGRFcnJvclwiKTtcbmNvbnN0IF9FcnJvcnMgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvY29udGFpbmVyL0Vycm9yc1wiKTtcbmNvbnN0IF9wYXJzZVN0YWNrID0gcmVxdWlyZShcIi4uL2ludGVybmFsL2hlbHBlcnMvcGFyc2VTdGFja1wiKTtcbmNvbnN0IF9CYXNlID0gcmVxdWlyZShcIi4uL2ludGVybmFsL3N0eWxlcy9CYXNlXCIpO1xuY29uc3QgX0NvbXBvbmVudFN0eWxlcyA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9zdHlsZXMvQ29tcG9uZW50U3R5bGVzXCIpO1xuY29uc3QgX0Nzc1Jlc2V0ID0gcmVxdWlyZShcIi4uL2ludGVybmFsL3N0eWxlcy9Dc3NSZXNldFwiKTtcbmNvbnN0IF9yb290bGF5b3V0bWlzc2luZ3RhZ3NlcnJvciA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9jb250YWluZXIvcm9vdC1sYXlvdXQtbWlzc2luZy10YWdzLWVycm9yXCIpO1xuY2xhc3MgUmVhY3REZXZPdmVybGF5IGV4dGVuZHMgX3JlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFlcnJvci5zdGFjaykgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWN0RXJyb3I6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWN0RXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBfc2hhcmVkLkFDVElPTl9VTkhBTkRMRURfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lczogKDAsIF9wYXJzZVN0YWNrLnBhcnNlU3RhY2spKGVycm9yLnN0YWNrKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25SZWFjdEVycm9yKGNvbXBvbmVudEVycik7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9zdGF0ZV9yb290TGF5b3V0TWlzc2luZ1RhZ3MsIF9zdGF0ZV9yb290TGF5b3V0TWlzc2luZ1RhZ3MxO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyByZWFjdEVycm9yIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBoYXNCdWlsZEVycm9yID0gc3RhdGUuYnVpbGRFcnJvciAhPSBudWxsO1xuICAgICAgICBjb25zdCBoYXNSdW50aW1lRXJyb3JzID0gQm9vbGVhbihzdGF0ZS5lcnJvcnMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaGFzTWlzc2luZ1RhZ3MgPSBCb29sZWFuKChfc3RhdGVfcm9vdExheW91dE1pc3NpbmdUYWdzID0gc3RhdGUucm9vdExheW91dE1pc3NpbmdUYWdzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlX3Jvb3RMYXlvdXRNaXNzaW5nVGFncy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBpc01vdW50ZWQgPSBoYXNCdWlsZEVycm9yIHx8IGhhc1J1bnRpbWVFcnJvcnMgfHwgcmVhY3RFcnJvciB8fCBoYXNNaXNzaW5nVGFncztcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIHJlYWN0RXJyb3IgPyAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShcImh0bWxcIiwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImhlYWRcIiwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImJvZHlcIiwge30pXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KSA6IGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGlzTW91bnRlZCA/IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9TaGFkb3dQb3J0YWwuU2hhZG93UG9ydGFsLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9Dc3NSZXNldC5Dc3NSZXNldCwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfQmFzZS5CYXNlLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9Db21wb25lbnRTdHlsZXMuQ29tcG9uZW50U3R5bGVzLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9zdGF0ZV9yb290TGF5b3V0TWlzc2luZ1RhZ3MxID0gc3RhdGUucm9vdExheW91dE1pc3NpbmdUYWdzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlX3Jvb3RMYXlvdXRNaXNzaW5nVGFnczEubGVuZ3RoKSA/IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX3Jvb3RsYXlvdXRtaXNzaW5ndGFnc2Vycm9yLlJvb3RMYXlvdXRNaXNzaW5nVGFnc0Vycm9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1RhZ3M6IHN0YXRlLnJvb3RMYXlvdXRNaXNzaW5nVGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBoYXNCdWlsZEVycm9yID8gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfQnVpbGRFcnJvci5CdWlsZEVycm9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc3RhdGUuYnVpbGRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uSW5mbzogc3RhdGUudmVyc2lvbkluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogcmVhY3RFcnJvciA/IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX0Vycm9ycy5FcnJvcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FwcERpcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uSW5mbzogc3RhdGUudmVyc2lvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERpc3BsYXlTdGF0ZTogXCJmdWxsc2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0RXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IGhhc1J1bnRpbWVFcnJvcnMgPyAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9FcnJvcnMuRXJyb3JzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBcHBEaXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERpc3BsYXlTdGF0ZTogXCJtaW5pbWl6ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uSW5mbzogc3RhdGUudmVyc2lvbkluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVhY3RFcnJvcjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhY3REZXZPdmVybGF5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJSZWFjdERldk92ZXJsYXkiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsIl9zaGFyZWQiLCJfU2hhZG93UG9ydGFsIiwiX0J1aWxkRXJyb3IiLCJfRXJyb3JzIiwiX3BhcnNlU3RhY2siLCJfQmFzZSIsIl9Db21wb25lbnRTdHlsZXMiLCJfQ3NzUmVzZXQiLCJfcm9vdGxheW91dG1pc3Npbmd0YWdzZXJyb3IiLCJQdXJlQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJzdGFjayIsInJlYWN0RXJyb3IiLCJpZCIsImV2ZW50IiwidHlwZSIsIkFDVElPTl9VTkhBTkRMRURfRVJST1IiLCJyZWFzb24iLCJmcmFtZXMiLCJwYXJzZVN0YWNrIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjb21wb25lbnRFcnIiLCJwcm9wcyIsIm9uUmVhY3RFcnJvciIsInJlbmRlciIsIl9zdGF0ZV9yb290TGF5b3V0TWlzc2luZ1RhZ3MiLCJfc3RhdGVfcm9vdExheW91dE1pc3NpbmdUYWdzMSIsInN0YXRlIiwiY2hpbGRyZW4iLCJoYXNCdWlsZEVycm9yIiwiYnVpbGRFcnJvciIsImhhc1J1bnRpbWVFcnJvcnMiLCJCb29sZWFuIiwiZXJyb3JzIiwibGVuZ3RoIiwiaGFzTWlzc2luZ1RhZ3MiLCJyb290TGF5b3V0TWlzc2luZ1RhZ3MiLCJpc01vdW50ZWQiLCJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJTaGFkb3dQb3J0YWwiLCJDc3NSZXNldCIsIkJhc2UiLCJDb21wb25lbnRTdHlsZXMiLCJSb290TGF5b3V0TWlzc2luZ1RhZ3NFcnJvciIsIm1pc3NpbmdUYWdzIiwiQnVpbGRFcnJvciIsIm1lc3NhZ2UiLCJ2ZXJzaW9uSW5mbyIsIkVycm9ycyIsImlzQXBwRGlyIiwiaW5pdGlhbERpc3BsYXlTdGF0ZSIsInVuZGVmaW5lZCIsImNvbnN0cnVjdG9yIiwiYXJncyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7558\n");

/***/ }),

/***/ 1857:
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js ***!
  \***********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return HotReload;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ 352);\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ 7247);\nconst _react = __webpack_require__(/*! react */ 8964);\nconst _stripansi = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/compiled/strip-ansi */ 8860));\nconst _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../internal/helpers/format-webpack-messages */ 8729));\nconst _navigation = __webpack_require__(/*! ../../navigation */ 5289);\nconst _shared = __webpack_require__(/*! ../shared */ 5745);\nconst _parseStack = __webpack_require__(/*! ../internal/helpers/parseStack */ 7648);\nconst _ReactDevOverlay = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./ReactDevOverlay */ 7558));\nconst _useerrorhandler = __webpack_require__(/*! ../internal/helpers/use-error-handler */ 7168);\nconst _runtimeerrorhandler = __webpack_require__(/*! ../internal/helpers/runtime-error-handler */ 8384);\nconst _usewebsocket = __webpack_require__(/*! ../internal/helpers/use-websocket */ 6178);\nconst _parsecomponentstack = __webpack_require__(/*! ../internal/helpers/parse-component-stack */ 9297);\nconst _hotreloadertypes = __webpack_require__(/*! ../../../../server/dev/hot-reloader-types */ 5915);\nconst _extractmodulesfromturbopackmessage = __webpack_require__(/*! ../../../../server/dev/extract-modules-from-turbopack-message */ 2808);\nlet mostRecentCompilationHash = null;\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now());\nlet reloading = false;\nlet startLatency = null;\nfunction onBeforeFastRefresh(dispatcher, hasUpdates) {\n    if (hasUpdates) {\n        dispatcher.onBeforeRefresh();\n    }\n}\nfunction onFastRefresh(dispatcher, sendMessage, updatedModules) {\n    dispatcher.onBuildOk();\n    reportHmrLatency(sendMessage, updatedModules);\n    dispatcher.onRefresh();\n}\nfunction reportHmrLatency(sendMessage, updatedModules) {\n    if (!startLatency) return;\n    let endLatency = Date.now();\n    const latency = endLatency - startLatency;\n    console.log(\"[Fast Refresh] done in \" + latency + \"ms\");\n    sendMessage(JSON.stringify({\n        event: \"client-hmr-latency\",\n        id: window.__nextDevClientId,\n        startTime: startLatency,\n        endTime: endLatency,\n        page: window.location.pathname,\n        updatedModules,\n        // Whether the page (tab) was hidden at the time the event occurred.\n        // This can impact the accuracy of the event's timing.\n        isPageHidden: document.visibilityState === \"hidden\"\n    }));\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */ function isUpdateAvailable() {\n    if (false) {}\n    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    return mostRecentCompilationHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    // @ts-expect-error module.hot exists\n    return module.hot.status() === \"idle\";\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === \"idle\") {\n                // @ts-expect-error module.hot exists\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        // @ts-expect-error module.hot exists\n        module.hot.addStatusHandler(handler);\n    }\n}\nfunction performFullReload(err, sendMessage) {\n    const stackTrace = err && (err.stack && err.stack.split(\"\\n\").slice(0, 5).join(\"\\n\") || err.message || err + \"\");\n    sendMessage(JSON.stringify({\n        event: \"client-full-reload\",\n        stackTrace,\n        hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,\n        dependencyChain: err ? err.dependencyChain : undefined\n    }));\n    if (reloading) return;\n    reloading = true;\n    window.location.reload();\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdates(onBeforeUpdate, onHotUpdateSuccess, sendMessage, dispatcher) {\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        dispatcher.onBuildOk();\n        return;\n    }\n    function handleApplyUpdates(err, updatedModules) {\n        if (err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || !updatedModules) {\n            if (err) {\n                console.warn(\"[Fast Refresh] performing full reload\\n\\n\" + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + \"You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n\" + \"Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n\" + \"It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n\" + \"Fast Refresh requires at least one parent function component in your React tree.\");\n            } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n                console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n            }\n            performFullReload(err, sendMessage);\n            return;\n        }\n        const hasUpdates = Boolean(updatedModules.length);\n        if (typeof onHotUpdateSuccess === \"function\") {\n            // Maybe we want to do something.\n            onHotUpdateSuccess(updatedModules);\n        }\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            tryApplyUpdates(hasUpdates ? ()=>{} : onBeforeUpdate, hasUpdates ? ()=>dispatcher.onBuildOk() : onHotUpdateSuccess, sendMessage, dispatcher);\n        } else {\n            dispatcher.onBuildOk();\n            if (false) {}\n        }\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    // @ts-expect-error module.hot exists\n    module.hot.check(/* autoApply */ false).then((updatedModules)=>{\n        if (!updatedModules) {\n            return null;\n        }\n        if (typeof onBeforeUpdate === \"function\") {\n            const hasUpdates = Boolean(updatedModules.length);\n            onBeforeUpdate(hasUpdates);\n        }\n        // https://webpack.js.org/api/hot-module-replacement/#apply\n        // @ts-expect-error module.hot exists\n        return module.hot.apply();\n    }).then((updatedModules)=>{\n        handleApplyUpdates(null, updatedModules);\n    }, (err)=>{\n        handleApplyUpdates(err, null);\n    });\n}\n/** Handles messages from the sevrer for the App Router. */ function processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher) {\n    if (!(\"action\" in obj)) {\n        return;\n    }\n    function handleErrors(errors) {\n        // \"Massage\" webpack messages.\n        const formatted = (0, _formatwebpackmessages.default)({\n            errors: errors,\n            warnings: []\n        });\n        // Only show the first error.\n        dispatcher.onBuildError(formatted.errors[0]);\n        // Also log them to the console.\n        for(let i = 0; i < formatted.errors.length; i++){\n            console.error((0, _stripansi.default)(formatted.errors[i]));\n        }\n        // Do not attempt to reload now.\n        // We will reload on next success instead.\n        if (false) {}\n    }\n    function handleHotUpdate() {\n        if (false) {} else {\n            tryApplyUpdates(function onBeforeHotUpdate(hasUpdates) {\n                onBeforeFastRefresh(dispatcher, hasUpdates);\n            }, function onSuccessfulHotUpdate(webpackUpdatedModules) {\n                // Only dismiss it when we're sure it's a hot update.\n                // Otherwise it would flicker right before the reload.\n                onFastRefresh(dispatcher, sendMessage, webpackUpdatedModules);\n            }, sendMessage, dispatcher);\n        }\n    }\n    switch(obj.action){\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:\n            {\n                startLatency = Date.now();\n                console.log(\"[Fast Refresh] rebuilding\");\n                break;\n            }\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:\n            {\n                if (obj.hash) {\n                    handleAvailableHash(obj.hash);\n                }\n                const { errors, warnings } = obj;\n                // Is undefined when it's a 'built' event\n                if (\"versionInfo\" in obj) dispatcher.onVersionInfo(obj.versionInfo);\n                const hasErrors = Boolean(errors && errors.length);\n                // Compilation with errors (e.g. syntax error or missing modules).\n                if (hasErrors) {\n                    sendMessage(JSON.stringify({\n                        event: \"client-error\",\n                        errorCount: errors.length,\n                        clientId: __nextDevClientId\n                    }));\n                    handleErrors(errors);\n                    return;\n                }\n                const hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    sendMessage(JSON.stringify({\n                        event: \"client-warning\",\n                        warningCount: warnings.length,\n                        clientId: __nextDevClientId\n                    }));\n                    // Print warnings to the console.\n                    const formattedMessages = (0, _formatwebpackmessages.default)({\n                        warnings: warnings,\n                        errors: []\n                    });\n                    for(let i = 0; i < formattedMessages.warnings.length; i++){\n                        if (i === 5) {\n                            console.warn(\"There were more warnings in other files.\\n\" + \"You can find a complete log in the terminal.\");\n                            break;\n                        }\n                        console.warn((0, _stripansi.default)(formattedMessages.warnings[i]));\n                    }\n                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n                }\n                sendMessage(JSON.stringify({\n                    event: \"client-success\",\n                    clientId: __nextDevClientId\n                }));\n                if (obj.action === _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {\n                    // Handle hot updates\n                    handleHotUpdate();\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:\n            {\n                processTurbopackMessage({\n                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n                });\n                break;\n            }\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:\n            {\n                const updatedModules = (0, _extractmodulesfromturbopackmessage.extractModulesFromTurbopackMessage)(obj.data);\n                dispatcher.onBeforeRefresh();\n                processTurbopackMessage({\n                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n                    data: obj.data\n                });\n                dispatcher.onRefresh();\n                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n                    console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n                    performFullReload(null, sendMessage);\n                }\n                reportHmrLatency(sendMessage, updatedModules);\n                break;\n            }\n        // TODO-APP: make server component change more granular\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:\n            {\n                sendMessage(JSON.stringify({\n                    event: \"server-component-reload-page\",\n                    clientId: __nextDevClientId\n                }));\n                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n                    if (reloading) return;\n                    reloading = true;\n                    return window.location.reload();\n                }\n                (0, _react.startTransition)(()=>{\n                    router.fastRefresh();\n                    dispatcher.onRefresh();\n                });\n                if (false) {}\n                return;\n            }\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE:\n            {\n                sendMessage(JSON.stringify({\n                    event: \"client-reload-page\",\n                    clientId: __nextDevClientId\n                }));\n                if (reloading) return;\n                reloading = true;\n                return window.location.reload();\n            }\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE:\n            {\n                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n                return router.fastRefresh();\n            }\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:\n            {\n                const { errorJSON } = obj;\n                if (errorJSON) {\n                    const { message, stack } = JSON.parse(errorJSON);\n                    const error = new Error(message);\n                    error.stack = stack;\n                    handleErrors([\n                        error\n                    ]);\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:\n            {\n                return;\n            }\n        default:\n            {}\n    }\n}\nfunction HotReload(param) {\n    let { assetPrefix, children } = param;\n    const [state, dispatch] = (0, _shared.useErrorOverlayReducer)();\n    const dispatcher = (0, _react.useMemo)(()=>{\n        return {\n            onBuildOk () {\n                dispatch({\n                    type: _shared.ACTION_BUILD_OK\n                });\n            },\n            onBuildError (message) {\n                dispatch({\n                    type: _shared.ACTION_BUILD_ERROR,\n                    message\n                });\n            },\n            onBeforeRefresh () {\n                dispatch({\n                    type: _shared.ACTION_BEFORE_REFRESH\n                });\n            },\n            onRefresh () {\n                dispatch({\n                    type: _shared.ACTION_REFRESH\n                });\n            },\n            onVersionInfo (versionInfo) {\n                dispatch({\n                    type: _shared.ACTION_VERSION_INFO,\n                    versionInfo\n                });\n            }\n        };\n    }, [\n        dispatch\n    ]);\n    const handleOnUnhandledError = (0, _react.useCallback)((error)=>{\n        const errorDetails = error.details;\n        // Component stack is added to the error in use-error-handler in case there was a hydration errror\n        const componentStack = errorDetails == null ? void 0 : errorDetails.componentStack;\n        const warning = errorDetails == null ? void 0 : errorDetails.warning;\n        dispatch({\n            type: _shared.ACTION_UNHANDLED_ERROR,\n            reason: error,\n            frames: (0, _parseStack.parseStack)(error.stack),\n            componentStackFrames: componentStack ? (0, _parsecomponentstack.parseComponentStack)(componentStack) : undefined,\n            warning\n        });\n    }, [\n        dispatch\n    ]);\n    const handleOnUnhandledRejection = (0, _react.useCallback)((reason)=>{\n        dispatch({\n            type: _shared.ACTION_UNHANDLED_REJECTION,\n            reason: reason,\n            frames: (0, _parseStack.parseStack)(reason.stack)\n        });\n    }, [\n        dispatch\n    ]);\n    const handleOnReactError = (0, _react.useCallback)(()=>{\n        _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError = true;\n    }, []);\n    (0, _useerrorhandler.useErrorHandler)(handleOnUnhandledError, handleOnUnhandledRejection);\n    const webSocketRef = (0, _usewebsocket.useWebsocket)(assetPrefix);\n    (0, _usewebsocket.useWebsocketPing)(webSocketRef);\n    const sendMessage = (0, _usewebsocket.useSendMessage)(webSocketRef);\n    const processTurbopackMessage = (0, _usewebsocket.useTurbopack)(sendMessage, (err)=>performFullReload(err, sendMessage));\n    const router = (0, _navigation.useRouter)();\n    (0, _react.useEffect)(()=>{\n        const websocket = webSocketRef.current;\n        if (!websocket) return;\n        const handler = (event)=>{\n            try {\n                const obj = JSON.parse(event.data);\n                processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher);\n            } catch (err) {\n                var _err_stack;\n                console.warn(\"[HMR] Invalid message: \" + event.data + \"\\n\" + ((_err_stack = err == null ? void 0 : err.stack) != null ? _err_stack : \"\"));\n            }\n        };\n        websocket.addEventListener(\"message\", handler);\n        return ()=>websocket.removeEventListener(\"message\", handler);\n    }, [\n        sendMessage,\n        router,\n        webSocketRef,\n        dispatcher,\n        processTurbopackMessage\n    ]);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_ReactDevOverlay.default, {\n        onReactError: handleOnReactError,\n        state: state,\n        children: children\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hot-reloader-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVRyxnQkFBZ0IsQ0FBQyxXQUFXakg7UUFDdEMsT0FBTyxJQUFJOEcsVUFBVUksbUJBQW1CLENBQUMsV0FBV2xIO0lBQ3hELEdBQUc7UUFDQ25DO1FBQ0FvRTtRQUNBc0U7UUFDQTlJO1FBQ0F1RTtLQUNIO0lBQ0QsT0FBcUIsV0FBSCxHQUFJLElBQUdoRyxZQUFZbUwsR0FBRyxFQUFFM0ssaUJBQWlCNkYsT0FBTyxFQUFFO1FBQ2hFK0UsY0FBY2Y7UUFDZHZCLE9BQU9BO1FBQ1BELFVBQVVBO0lBQ2Q7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPcEosUUFBUTRHLE9BQU8sS0FBSyxjQUFlLE9BQU81RyxRQUFRNEcsT0FBTyxLQUFLLFlBQVk1RyxRQUFRNEcsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPNUcsUUFBUTRHLE9BQU8sQ0FBQ2dGLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUwsT0FBT0MsY0FBYyxDQUFDQyxRQUFRNEcsT0FBTyxFQUFFLGNBQWM7UUFBRTNHLE9BQU87SUFBSztJQUNuRUgsT0FBTytMLE1BQU0sQ0FBQzdMLFFBQVE0RyxPQUFPLEVBQUU1RztJQUMvQmtFLE9BQU9sRSxPQUFPLEdBQUdBLFFBQVE0RyxPQUFPO0FBQ2xDLEVBRUEsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2hvdC1yZWxvYWRlci1jbGllbnQuanM/MmM3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhvdFJlbG9hZDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmNvbnN0IF9zdHJpcGFuc2kgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKSk7XG5jb25zdCBfZm9ybWF0d2VicGFja21lc3NhZ2VzID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi4vaW50ZXJuYWwvaGVscGVycy9mb3JtYXQtd2VicGFjay1tZXNzYWdlc1wiKSk7XG5jb25zdCBfbmF2aWdhdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9uYXZpZ2F0aW9uXCIpO1xuY29uc3QgX3NoYXJlZCA9IHJlcXVpcmUoXCIuLi9zaGFyZWRcIik7XG5jb25zdCBfcGFyc2VTdGFjayA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9oZWxwZXJzL3BhcnNlU3RhY2tcIik7XG5jb25zdCBfUmVhY3REZXZPdmVybGF5ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9SZWFjdERldk92ZXJsYXlcIikpO1xuY29uc3QgX3VzZWVycm9yaGFuZGxlciA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9oZWxwZXJzL3VzZS1lcnJvci1oYW5kbGVyXCIpO1xuY29uc3QgX3J1bnRpbWVlcnJvcmhhbmRsZXIgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvaGVscGVycy9ydW50aW1lLWVycm9yLWhhbmRsZXJcIik7XG5jb25zdCBfdXNld2Vic29ja2V0ID0gcmVxdWlyZShcIi4uL2ludGVybmFsL2hlbHBlcnMvdXNlLXdlYnNvY2tldFwiKTtcbmNvbnN0IF9wYXJzZWNvbXBvbmVudHN0YWNrID0gcmVxdWlyZShcIi4uL2ludGVybmFsL2hlbHBlcnMvcGFyc2UtY29tcG9uZW50LXN0YWNrXCIpO1xuY29uc3QgX2hvdHJlbG9hZGVydHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2VydmVyL2Rldi9ob3QtcmVsb2FkZXItdHlwZXNcIik7XG5jb25zdCBfZXh0cmFjdG1vZHVsZXNmcm9tdHVyYm9wYWNrbWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9zZXJ2ZXIvZGV2L2V4dHJhY3QtbW9kdWxlcy1mcm9tLXR1cmJvcGFjay1tZXNzYWdlXCIpO1xubGV0IG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggPSBudWxsO1xubGV0IF9fbmV4dERldkNsaWVudElkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwICsgRGF0ZS5ub3coKSk7XG5sZXQgcmVsb2FkaW5nID0gZmFsc2U7XG5sZXQgc3RhcnRMYXRlbmN5ID0gbnVsbDtcbmZ1bmN0aW9uIG9uQmVmb3JlRmFzdFJlZnJlc2goZGlzcGF0Y2hlciwgaGFzVXBkYXRlcykge1xuICAgIGlmIChoYXNVcGRhdGVzKSB7XG4gICAgICAgIGRpc3BhdGNoZXIub25CZWZvcmVSZWZyZXNoKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25GYXN0UmVmcmVzaChkaXNwYXRjaGVyLCBzZW5kTWVzc2FnZSwgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICBkaXNwYXRjaGVyLm9uQnVpbGRPaygpO1xuICAgIHJlcG9ydEhtckxhdGVuY3koc2VuZE1lc3NhZ2UsIHVwZGF0ZWRNb2R1bGVzKTtcbiAgICBkaXNwYXRjaGVyLm9uUmVmcmVzaCgpO1xufVxuZnVuY3Rpb24gcmVwb3J0SG1yTGF0ZW5jeShzZW5kTWVzc2FnZSwgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICBpZiAoIXN0YXJ0TGF0ZW5jeSkgcmV0dXJuO1xuICAgIGxldCBlbmRMYXRlbmN5ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBsYXRlbmN5ID0gZW5kTGF0ZW5jeSAtIHN0YXJ0TGF0ZW5jeTtcbiAgICBjb25zb2xlLmxvZyhcIltGYXN0IFJlZnJlc2hdIGRvbmUgaW4gXCIgKyBsYXRlbmN5ICsgXCJtc1wiKTtcbiAgICBzZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV2ZW50OiBcImNsaWVudC1obXItbGF0ZW5jeVwiLFxuICAgICAgICBpZDogd2luZG93Ll9fbmV4dERldkNsaWVudElkLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0TGF0ZW5jeSxcbiAgICAgICAgZW5kVGltZTogZW5kTGF0ZW5jeSxcbiAgICAgICAgcGFnZTogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICB1cGRhdGVkTW9kdWxlcyxcbiAgICAgICAgLy8gV2hldGhlciB0aGUgcGFnZSAodGFiKSB3YXMgaGlkZGVuIGF0IHRoZSB0aW1lIHRoZSBldmVudCBvY2N1cnJlZC5cbiAgICAgICAgLy8gVGhpcyBjYW4gaW1wYWN0IHRoZSBhY2N1cmFjeSBvZiB0aGUgZXZlbnQncyB0aW1pbmcuXG4gICAgICAgIGlzUGFnZUhpZGRlbjogZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiXG4gICAgfSkpO1xufVxuLy8gVGhlcmUgaXMgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBjb2RlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIGhhbmRsZUF2YWlsYWJsZUhhc2goaGFzaCkge1xuICAgIC8vIFVwZGF0ZSBsYXN0IGtub3duIGNvbXBpbGF0aW9uIGhhc2guXG4gICAgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IGhhc2g7XG59XG4vKipcbiAqIElzIHRoZXJlIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGlzIGNvZGUgYXZhaWxhYmxlP1xuICogRm9yIHdlYnBhY2s6IENoZWNrIGlmIHRoZSBoYXNoIGNoYW5nZWQgY29tcGFyZWQgdG8gX193ZWJwYWNrX2hhc2hfX1xuICogRm9yIFR1cmJvcGFjazogQWx3YXlzIHRydWUgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgX193ZWJwYWNrX2hhc2hfX1xuICovIGZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIGdsb2JhbHMgX193ZWJwYWNrX2hhc2hfXyAqLyAvLyBfX3dlYnBhY2tfaGFzaF9fIGlzIHRoZSBoYXNoIG9mIHRoZSBjdXJyZW50IGNvbXBpbGF0aW9uLlxuICAgIC8vIEl0J3MgYSBnbG9iYWwgdmFyaWFibGUgaW5qZWN0ZWQgYnkgV2VicGFjay5cbiAgICByZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfXztcbn1cbi8vIFdlYnBhY2sgZGlzYWxsb3dzIHVwZGF0ZXMgaW4gb3RoZXIgc3RhdGVzLlxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbW9kdWxlLmhvdCBleGlzdHNcbiAgICByZXR1cm4gbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gXCJpZGxlXCI7XG59XG5mdW5jdGlvbiBhZnRlckFwcGx5VXBkYXRlcyhmbikge1xuICAgIGlmIChjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgICAgICBmbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoc3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSBcImlkbGVcIikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbW9kdWxlLmhvdCBleGlzdHNcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LnJlbW92ZVN0YXR1c0hhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1vZHVsZS5ob3QgZXhpc3RzXG4gICAgICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwZXJmb3JtRnVsbFJlbG9hZChlcnIsIHNlbmRNZXNzYWdlKSB7XG4gICAgY29uc3Qgc3RhY2tUcmFjZSA9IGVyciAmJiAoZXJyLnN0YWNrICYmIGVyci5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgwLCA1KS5qb2luKFwiXFxuXCIpIHx8IGVyci5tZXNzYWdlIHx8IGVyciArIFwiXCIpO1xuICAgIHNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZXZlbnQ6IFwiY2xpZW50LWZ1bGwtcmVsb2FkXCIsXG4gICAgICAgIHN0YWNrVHJhY2UsXG4gICAgICAgIGhhZFJ1bnRpbWVFcnJvcjogISFfcnVudGltZWVycm9yaGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcixcbiAgICAgICAgZGVwZW5kZW5jeUNoYWluOiBlcnIgPyBlcnIuZGVwZW5kZW5jeUNoYWluIDogdW5kZWZpbmVkXG4gICAgfSkpO1xuICAgIGlmIChyZWxvYWRpbmcpIHJldHVybjtcbiAgICByZWxvYWRpbmcgPSB0cnVlO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbn1cbi8vIEF0dGVtcHQgdG8gdXBkYXRlIGNvZGUgb24gdGhlIGZseSwgZmFsbCBiYWNrIHRvIGEgaGFyZCByZWxvYWQuXG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXMob25CZWZvcmVVcGRhdGUsIG9uSG90VXBkYXRlU3VjY2Vzcywgc2VuZE1lc3NhZ2UsIGRpc3BhdGNoZXIpIHtcbiAgICBpZiAoIWlzVXBkYXRlQXZhaWxhYmxlKCkgfHwgIWNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgICAgIGRpc3BhdGNoZXIub25CdWlsZE9rKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKGVyciB8fCBfcnVudGltZWVycm9yaGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvciB8fCAhdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuXCIgKyBcIkZhc3QgUmVmcmVzaCB3aWxsIHBlcmZvcm0gYSBmdWxsIHJlbG9hZCB3aGVuIHlvdSBlZGl0IGEgZmlsZSB0aGF0J3MgaW1wb3J0ZWQgYnkgbW9kdWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCByZW5kZXJpbmcgdHJlZS5cXG5cIiArIFwiWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIGV4cG9ydHMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50IGZpbGUuXFxuXCIgKyBcIkNvbnNpZGVyIG1pZ3JhdGluZyB0aGUgbm9uLVJlYWN0IGNvbXBvbmVudCBleHBvcnQgdG8gYSBzZXBhcmF0ZSBmaWxlIGFuZCBpbXBvcnRpbmcgaXQgaW50byBib3RoIGZpbGVzLlxcblxcblwiICsgXCJJdCBpcyBhbHNvIHBvc3NpYmxlIHRoZSBwYXJlbnQgY29tcG9uZW50IG9mIHRoZSBjb21wb25lbnQgeW91IGVkaXRlZCBpcyBhIGNsYXNzIGNvbXBvbmVudCwgd2hpY2ggZGlzYWJsZXMgRmFzdCBSZWZyZXNoLlxcblwiICsgXCJGYXN0IFJlZnJlc2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmVudCBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3J1bnRpbWVlcnJvcmhhbmRsZXIuUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oX3NoYXJlZC5SRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVyZm9ybUZ1bGxSZWxvYWQoZXJyLCBzZW5kTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVXBkYXRlcyA9IEJvb2xlYW4odXBkYXRlZE1vZHVsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkhvdFVwZGF0ZVN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gTWF5YmUgd2Ugd2FudCB0byBkbyBzb21ldGhpbmcuXG4gICAgICAgICAgICBvbkhvdFVwZGF0ZVN1Y2Nlc3ModXBkYXRlZE1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VwZGF0ZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBXaGlsZSB3ZSB3ZXJlIHVwZGF0aW5nLCB0aGVyZSB3YXMgYSBuZXcgdXBkYXRlISBEbyBpdCBhZ2Fpbi5cbiAgICAgICAgICAgIHRyeUFwcGx5VXBkYXRlcyhoYXNVcGRhdGVzID8gKCk9Pnt9IDogb25CZWZvcmVVcGRhdGUsIGhhc1VwZGF0ZXMgPyAoKT0+ZGlzcGF0Y2hlci5vbkJ1aWxkT2soKSA6IG9uSG90VXBkYXRlU3VjY2Vzcywgc2VuZE1lc3NhZ2UsIGRpc3BhdGNoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5vbkJ1aWxkT2soKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJBcHBseVVwZGF0ZXMoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jY2hlY2tcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1vZHVsZS5ob3QgZXhpc3RzXG4gICAgbW9kdWxlLmhvdC5jaGVjaygvKiBhdXRvQXBwbHkgKi8gZmFsc2UpLnRoZW4oKHVwZGF0ZWRNb2R1bGVzKT0+e1xuICAgICAgICBpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uQmVmb3JlVXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc1VwZGF0ZXMgPSBCb29sZWFuKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBvbkJlZm9yZVVwZGF0ZShoYXNVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNhcHBseVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1vZHVsZS5ob3QgZXhpc3RzXG4gICAgICAgIHJldHVybiBtb2R1bGUuaG90LmFwcGx5KCk7XG4gICAgfSkudGhlbigodXBkYXRlZE1vZHVsZXMpPT57XG4gICAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhudWxsLCB1cGRhdGVkTW9kdWxlcyk7XG4gICAgfSwgKGVycik9PntcbiAgICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgbnVsbCk7XG4gICAgfSk7XG59XG4vKiogSGFuZGxlcyBtZXNzYWdlcyBmcm9tIHRoZSBzZXZyZXIgZm9yIHRoZSBBcHAgUm91dGVyLiAqLyBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShvYmosIHNlbmRNZXNzYWdlLCBwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZSwgcm91dGVyLCBkaXNwYXRjaGVyKSB7XG4gICAgaWYgKCEoXCJhY3Rpb25cIiBpbiBvYmopKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3JzKGVycm9ycykge1xuICAgICAgICAvLyBcIk1hc3NhZ2VcIiB3ZWJwYWNrIG1lc3NhZ2VzLlxuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSAoMCwgX2Zvcm1hdHdlYnBhY2ttZXNzYWdlcy5kZWZhdWx0KSh7XG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gT25seSBzaG93IHRoZSBmaXJzdCBlcnJvci5cbiAgICAgICAgZGlzcGF0Y2hlci5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSk7XG4gICAgICAgIC8vIEFsc28gbG9nIHRoZW0gdG8gdGhlIGNvbnNvbGUuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKDAsIF9zdHJpcGFuc2kuZGVmYXVsdCkoZm9ybWF0dGVkLmVycm9yc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBub3cuXG4gICAgICAgIC8vIFdlIHdpbGwgcmVsb2FkIG9uIG5leHQgc3VjY2VzcyBpbnN0ZWFkLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQihmb3JtYXR0ZWQuZXJyb3JzWzBdKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUhvdFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5vbkJ1aWxkT2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeUFwcGx5VXBkYXRlcyhmdW5jdGlvbiBvbkJlZm9yZUhvdFVwZGF0ZShoYXNVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgb25CZWZvcmVGYXN0UmVmcmVzaChkaXNwYXRjaGVyLCBoYXNVcGRhdGVzKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZSh3ZWJwYWNrVXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRpc21pc3MgaXQgd2hlbiB3ZSdyZSBzdXJlIGl0J3MgYSBob3QgdXBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCB3b3VsZCBmbGlja2VyIHJpZ2h0IGJlZm9yZSB0aGUgcmVsb2FkLlxuICAgICAgICAgICAgICAgIG9uRmFzdFJlZnJlc2goZGlzcGF0Y2hlciwgc2VuZE1lc3NhZ2UsIHdlYnBhY2tVcGRhdGVkTW9kdWxlcyk7XG4gICAgICAgICAgICB9LCBzZW5kTWVzc2FnZSwgZGlzcGF0Y2hlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoKG9iai5hY3Rpb24pe1xuICAgICAgICBjYXNlIF9ob3RyZWxvYWRlcnR5cGVzLkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMRElORzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydExhdGVuY3kgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0Zhc3QgUmVmcmVzaF0gcmVidWlsZGluZ1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTFQ6XG4gICAgICAgIGNhc2UgX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNZTkM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUF2YWlsYWJsZUhhc2gob2JqLmhhc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycywgd2FybmluZ3MgfSA9IG9iajtcbiAgICAgICAgICAgICAgICAvLyBJcyB1bmRlZmluZWQgd2hlbiBpdCdzIGEgJ2J1aWx0JyBldmVudFxuICAgICAgICAgICAgICAgIGlmIChcInZlcnNpb25JbmZvXCIgaW4gb2JqKSBkaXNwYXRjaGVyLm9uVmVyc2lvbkluZm8ob2JqLnZlcnNpb25JbmZvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNFcnJvcnMgPSBCb29sZWFuKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbiAgICAgICAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNsaWVudC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb3VudDogZXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9ycyhlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1dhcm5pbmdzID0gQm9vbGVhbih3YXJuaW5ncyAmJiB3YXJuaW5ncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNXYXJuaW5ncykge1xuICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjbGllbnQtd2FybmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ0NvdW50OiB3YXJuaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmludCB3YXJuaW5ncyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZXMgPSAoMCwgX2Zvcm1hdHdlYnBhY2ttZXNzYWdlcy5kZWZhdWx0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkTWVzc2FnZXMud2FybmluZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGVyZSB3ZXJlIG1vcmUgd2FybmluZ3MgaW4gb3RoZXIgZmlsZXMuXFxuXCIgKyBcIllvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCgwLCBfc3RyaXBhbnNpLmRlZmF1bHQpKGZvcm1hdHRlZE1lc3NhZ2VzLndhcm5pbmdzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObyBlYXJseSByZXR1cm4gaGVyZSBhcyB3ZSBuZWVkIHRvIGFwcGx5IG1vZHVsZXMgaW4gdGhlIHNhbWUgd2F5IGJldHdlZW4gd2FybmluZ3Mgb25seSBhbmQgY29tcGlsZXMgd2l0aG91dCB3YXJuaW5nc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNsaWVudC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmFjdGlvbiA9PT0gX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkJVSUxUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBob3QgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIb3RVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9ob3RyZWxvYWRlcnR5cGVzLkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfQ09OTkVDVEVEOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NUdXJib3BhY2tNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURURcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX01FU1NBR0U6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE1vZHVsZXMgPSAoMCwgX2V4dHJhY3Rtb2R1bGVzZnJvbXR1cmJvcGFja21lc3NhZ2UuZXh0cmFjdE1vZHVsZXNGcm9tVHVyYm9wYWNrTWVzc2FnZSkob2JqLmRhdGEpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIub25CZWZvcmVSZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX01FU1NBR0UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9iai5kYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5vblJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBpZiAoX3J1bnRpbWVlcnJvcmhhbmRsZXIuUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKF9zaGFyZWQuUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUZ1bGxSZWxvYWQobnVsbCwgc2VuZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBvcnRIbXJMYXRlbmN5KHNlbmRNZXNzYWdlLCB1cGRhdGVkTW9kdWxlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8tQVBQOiBtYWtlIHNlcnZlciBjb21wb25lbnQgY2hhbmdlIG1vcmUgZ3JhbnVsYXJcbiAgICAgICAgY2FzZSBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX0NPTVBPTkVOVF9DSEFOR0VTOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwic2VydmVyLWNvbXBvbmVudC1yZWxvYWQtcGFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKF9ydW50aW1lZXJyb3JoYW5kbGVyLlJ1bnRpbWVFcnJvckhhbmRsZXIuaGFkUnVudGltZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxvYWRpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgcmVsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKDAsIF9yZWFjdC5zdGFydFRyYW5zaXRpb24pKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlci5mYXN0UmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLm9uUmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9fTkVYVF9ITVJfQ0IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlJFTE9BRF9QQUdFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiY2xpZW50LXJlbG9hZC1wYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2FkaW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcmVsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9ob3RyZWxvYWRlcnR5cGVzLkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5BRERFRF9QQUdFOlxuICAgICAgICBjYXNlIF9ob3RyZWxvYWRlcnR5cGVzLkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5SRU1PVkVEX1BBR0U6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHBvdGVudGlhbGx5IG9ubHkgcmVmcmVzaCBpZiB0aGUgY3VycmVudGx5IHZpZXdlZCBwYWdlIHdhcyBhZGRlZC9yZW1vdmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZXIuZmFzdFJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX0VSUk9SOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JKU09OIH0gPSBvYmo7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ySlNPTikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBKU09OLnBhcnNlKGVycm9ySlNPTik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcnMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuREVWX1BBR0VTX01BTklGRVNUX1VQREFURTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7fVxuICAgIH1cbn1cbmZ1bmN0aW9uIEhvdFJlbG9hZChwYXJhbSkge1xuICAgIGxldCB7IGFzc2V0UHJlZml4LCBjaGlsZHJlbiB9ID0gcGFyYW07XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3NoYXJlZC51c2VFcnJvck92ZXJsYXlSZWR1Y2VyKSgpO1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSAoMCwgX3JlYWN0LnVzZU1lbW8pKCgpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbkJ1aWxkT2sgKCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogX3NoYXJlZC5BQ1RJT05fQlVJTERfT0tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkJ1aWxkRXJyb3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX0JVSUxEX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25CZWZvcmVSZWZyZXNoICgpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX0JFRk9SRV9SRUZSRVNIXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWZyZXNoICgpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX1JFRlJFU0hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblZlcnNpb25JbmZvICh2ZXJzaW9uSW5mbykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogX3NoYXJlZC5BQ1RJT05fVkVSU0lPTl9JTkZPLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uSW5mb1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICBjb25zdCBoYW5kbGVPblVuaGFuZGxlZEVycm9yID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGVycm9yKT0+e1xuICAgICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvci5kZXRhaWxzO1xuICAgICAgICAvLyBDb21wb25lbnQgc3RhY2sgaXMgYWRkZWQgdG8gdGhlIGVycm9yIGluIHVzZS1lcnJvci1oYW5kbGVyIGluIGNhc2UgdGhlcmUgd2FzIGEgaHlkcmF0aW9uIGVycnJvclxuICAgICAgICBjb25zdCBjb21wb25lbnRTdGFjayA9IGVycm9yRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JEZXRhaWxzLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICBjb25zdCB3YXJuaW5nID0gZXJyb3JEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckRldGFpbHMud2FybmluZztcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogX3NoYXJlZC5BQ1RJT05fVU5IQU5ETEVEX0VSUk9SLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvcixcbiAgICAgICAgICAgIGZyYW1lczogKDAsIF9wYXJzZVN0YWNrLnBhcnNlU3RhY2spKGVycm9yLnN0YWNrKSxcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrRnJhbWVzOiBjb21wb25lbnRTdGFjayA/ICgwLCBfcGFyc2Vjb21wb25lbnRzdGFjay5wYXJzZUNvbXBvbmVudFN0YWNrKShjb21wb25lbnRTdGFjaykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3YXJuaW5nXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICBjb25zdCBoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbiA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKChyZWFzb24pPT57XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04sXG4gICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgIGZyYW1lczogKDAsIF9wYXJzZVN0YWNrLnBhcnNlU3RhY2spKHJlYXNvbi5zdGFjaylcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaFxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZU9uUmVhY3RFcnJvciA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIF9ydW50aW1lZXJyb3JoYW5kbGVyLlJ1bnRpbWVFcnJvckhhbmRsZXIuaGFkUnVudGltZUVycm9yID0gdHJ1ZTtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF91c2VlcnJvcmhhbmRsZXIudXNlRXJyb3JIYW5kbGVyKShoYW5kbGVPblVuaGFuZGxlZEVycm9yLCBoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbik7XG4gICAgY29uc3Qgd2ViU29ja2V0UmVmID0gKDAsIF91c2V3ZWJzb2NrZXQudXNlV2Vic29ja2V0KShhc3NldFByZWZpeCk7XG4gICAgKDAsIF91c2V3ZWJzb2NrZXQudXNlV2Vic29ja2V0UGluZykod2ViU29ja2V0UmVmKTtcbiAgICBjb25zdCBzZW5kTWVzc2FnZSA9ICgwLCBfdXNld2Vic29ja2V0LnVzZVNlbmRNZXNzYWdlKSh3ZWJTb2NrZXRSZWYpO1xuICAgIGNvbnN0IHByb2Nlc3NUdXJib3BhY2tNZXNzYWdlID0gKDAsIF91c2V3ZWJzb2NrZXQudXNlVHVyYm9wYWNrKShzZW5kTWVzc2FnZSwgKGVycik9PnBlcmZvcm1GdWxsUmVsb2FkKGVyciwgc2VuZE1lc3NhZ2UpKTtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24udXNlUm91dGVyKSgpO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXQgPSB3ZWJTb2NrZXRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCF3ZWJzb2NrZXQpIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudCk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzTWVzc2FnZShvYmosIHNlbmRNZXNzYWdlLCBwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZSwgcm91dGVyLCBkaXNwYXRjaGVyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBfZXJyX3N0YWNrO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltITVJdIEludmFsaWQgbWVzc2FnZTogXCIgKyBldmVudC5kYXRhICsgXCJcXG5cIiArICgoX2Vycl9zdGFjayA9IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLnN0YWNrKSAhPSBudWxsID8gX2Vycl9zdGFjayA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCk9PndlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICB9LCBbXG4gICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIHdlYlNvY2tldFJlZixcbiAgICAgICAgZGlzcGF0Y2hlcixcbiAgICAgICAgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2VcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfUmVhY3REZXZPdmVybGF5LmRlZmF1bHQsIHtcbiAgICAgICAgb25SZWFjdEVycm9yOiBoYW5kbGVPblJlYWN0RXJyb3IsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvdC1yZWxvYWRlci1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkhvdFJlbG9hZCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl9zdHJpcGFuc2kiLCJfIiwiX2Zvcm1hdHdlYnBhY2ttZXNzYWdlcyIsIl9uYXZpZ2F0aW9uIiwiX3NoYXJlZCIsIl9wYXJzZVN0YWNrIiwiX1JlYWN0RGV2T3ZlcmxheSIsIl91c2VlcnJvcmhhbmRsZXIiLCJfcnVudGltZWVycm9yaGFuZGxlciIsIl91c2V3ZWJzb2NrZXQiLCJfcGFyc2Vjb21wb25lbnRzdGFjayIsIl9ob3RyZWxvYWRlcnR5cGVzIiwiX2V4dHJhY3Rtb2R1bGVzZnJvbXR1cmJvcGFja21lc3NhZ2UiLCJtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoIiwiX19uZXh0RGV2Q2xpZW50SWQiLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCJEYXRlIiwibm93IiwicmVsb2FkaW5nIiwic3RhcnRMYXRlbmN5Iiwib25CZWZvcmVGYXN0UmVmcmVzaCIsImRpc3BhdGNoZXIiLCJoYXNVcGRhdGVzIiwib25CZWZvcmVSZWZyZXNoIiwib25GYXN0UmVmcmVzaCIsInNlbmRNZXNzYWdlIiwidXBkYXRlZE1vZHVsZXMiLCJvbkJ1aWxkT2siLCJyZXBvcnRIbXJMYXRlbmN5Iiwib25SZWZyZXNoIiwiZW5kTGF0ZW5jeSIsImxhdGVuY3kiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsImV2ZW50IiwiaWQiLCJ3aW5kb3ciLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwicGFnZSIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJpc1BhZ2VIaWRkZW4iLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsImhhbmRsZUF2YWlsYWJsZUhhc2giLCJoYXNoIiwiaXNVcGRhdGVBdmFpbGFibGUiLCJwcm9jZXNzIiwiZW52IiwiVFVSQk9QQUNLIiwiX193ZWJwYWNrX2hhc2hfXyIsImNhbkFwcGx5VXBkYXRlcyIsIm1vZHVsZSIsImhvdCIsInN0YXR1cyIsImFmdGVyQXBwbHlVcGRhdGVzIiwiZm4iLCJoYW5kbGVyIiwicmVtb3ZlU3RhdHVzSGFuZGxlciIsImFkZFN0YXR1c0hhbmRsZXIiLCJwZXJmb3JtRnVsbFJlbG9hZCIsImVyciIsInN0YWNrVHJhY2UiLCJzdGFjayIsInNwbGl0Iiwic2xpY2UiLCJqb2luIiwibWVzc2FnZSIsImhhZFJ1bnRpbWVFcnJvciIsIlJ1bnRpbWVFcnJvckhhbmRsZXIiLCJkZXBlbmRlbmN5Q2hhaW4iLCJ1bmRlZmluZWQiLCJyZWxvYWQiLCJ0cnlBcHBseVVwZGF0ZXMiLCJvbkJlZm9yZVVwZGF0ZSIsIm9uSG90VXBkYXRlU3VjY2VzcyIsImhhbmRsZUFwcGx5VXBkYXRlcyIsIndhcm4iLCJSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IiLCJCb29sZWFuIiwibGVuZ3RoIiwiX19ORVhUX1RFU1RfTU9ERSIsInNlbGYiLCJfX05FWFRfSE1SX0NCIiwiY2hlY2siLCJ0aGVuIiwiYXBwbHkiLCJwcm9jZXNzTWVzc2FnZSIsIm9iaiIsInByb2Nlc3NUdXJib3BhY2tNZXNzYWdlIiwicm91dGVyIiwiaGFuZGxlRXJyb3JzIiwiZXJyb3JzIiwiZm9ybWF0dGVkIiwiZGVmYXVsdCIsIndhcm5pbmdzIiwib25CdWlsZEVycm9yIiwiaSIsImVycm9yIiwiaGFuZGxlSG90VXBkYXRlIiwib25CZWZvcmVIb3RVcGRhdGUiLCJvblN1Y2Nlc3NmdWxIb3RVcGRhdGUiLCJ3ZWJwYWNrVXBkYXRlZE1vZHVsZXMiLCJhY3Rpb24iLCJITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIiLCJCVUlMRElORyIsIkJVSUxUIiwiU1lOQyIsIm9uVmVyc2lvbkluZm8iLCJ2ZXJzaW9uSW5mbyIsImhhc0Vycm9ycyIsImVycm9yQ291bnQiLCJjbGllbnRJZCIsImhhc1dhcm5pbmdzIiwid2FybmluZ0NvdW50IiwiZm9ybWF0dGVkTWVzc2FnZXMiLCJUVVJCT1BBQ0tfQ09OTkVDVEVEIiwidHlwZSIsIlRVUkJPUEFDS19NRVNTQUdFIiwiZXh0cmFjdE1vZHVsZXNGcm9tVHVyYm9wYWNrTWVzc2FnZSIsImRhdGEiLCJTRVJWRVJfQ09NUE9ORU5UX0NIQU5HRVMiLCJzdGFydFRyYW5zaXRpb24iLCJmYXN0UmVmcmVzaCIsIlJFTE9BRF9QQUdFIiwiQURERURfUEFHRSIsIlJFTU9WRURfUEFHRSIsIlNFUlZFUl9FUlJPUiIsImVycm9ySlNPTiIsInBhcnNlIiwiRXJyb3IiLCJERVZfUEFHRVNfTUFOSUZFU1RfVVBEQVRFIiwicGFyYW0iLCJhc3NldFByZWZpeCIsImNoaWxkcmVuIiwic3RhdGUiLCJkaXNwYXRjaCIsInVzZUVycm9yT3ZlcmxheVJlZHVjZXIiLCJ1c2VNZW1vIiwiQUNUSU9OX0JVSUxEX09LIiwiQUNUSU9OX0JVSUxEX0VSUk9SIiwiQUNUSU9OX0JFRk9SRV9SRUZSRVNIIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fVkVSU0lPTl9JTkZPIiwiaGFuZGxlT25VbmhhbmRsZWRFcnJvciIsInVzZUNhbGxiYWNrIiwiZXJyb3JEZXRhaWxzIiwiZGV0YWlscyIsImNvbXBvbmVudFN0YWNrIiwid2FybmluZyIsIkFDVElPTl9VTkhBTkRMRURfRVJST1IiLCJyZWFzb24iLCJmcmFtZXMiLCJwYXJzZVN0YWNrIiwiY29tcG9uZW50U3RhY2tGcmFtZXMiLCJwYXJzZUNvbXBvbmVudFN0YWNrIiwiaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24iLCJBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTiIsImhhbmRsZU9uUmVhY3RFcnJvciIsInVzZUVycm9ySGFuZGxlciIsIndlYlNvY2tldFJlZiIsInVzZVdlYnNvY2tldCIsInVzZVdlYnNvY2tldFBpbmciLCJ1c2VTZW5kTWVzc2FnZSIsInVzZVR1cmJvcGFjayIsInVzZVJvdXRlciIsInVzZUVmZmVjdCIsIndlYnNvY2tldCIsImN1cnJlbnQiLCJfZXJyX3N0YWNrIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJqc3giLCJvblJlYWN0RXJyb3IiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1857\n");

/***/ })

};
;