"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_next_dist_client_c";
exports.ids = ["vendors-node_modules_next_dist_client_c"];
exports.modules = {

/***/ 3118:
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return RenderFromTemplateContext;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ 6870);\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ 7247);\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ 8964));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ 7240);\nfunction RenderFromTemplateContext() {\n    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzExOC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDRCQUE0QkMsbUJBQU9BLENBQUMsb0RBQTBDO0FBQ3BGLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDZCQUFtQjtBQUMvQyxNQUFNRSxTQUFTLFdBQVcsR0FBR0gsMEJBQTBCSSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLGlCQUFPO0FBQ3hFLE1BQU1JLGlDQUFpQ0osbUJBQU9BLENBQUMsOERBQW9EO0FBQ25HLFNBQVNGO0lBQ0wsTUFBTU8sV0FBVyxDQUFDLEdBQUdILE9BQU9JLFVBQVUsRUFBRUYsK0JBQStCRyxlQUFlO0lBQ3RGLE9BQXFCLFdBQUgsR0FBSSxJQUFHTixZQUFZTyxHQUFHLEVBQUVQLFlBQVlRLFFBQVEsRUFBRTtRQUM1REosVUFBVUE7SUFDZDtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9YLFFBQVFnQixPQUFPLEtBQUssY0FBZSxPQUFPaEIsUUFBUWdCLE9BQU8sS0FBSyxZQUFZaEIsUUFBUWdCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2hCLFFBQVFnQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbkIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRZ0IsT0FBTyxFQUFFLGNBQWM7UUFBRWYsT0FBTztJQUFLO0lBQ25FSCxPQUFPb0IsTUFBTSxDQUFDbEIsUUFBUWdCLE9BQU8sRUFBRWhCO0lBQy9CbUIsT0FBT25CLE9BQU8sR0FBR0EsUUFBUWdCLE9BQU87QUFDbEMsRUFFQSx3REFBd0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzPzhlZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmZ1bmN0aW9uIFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5UZW1wbGF0ZUNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJqc3giLCJGcmFnbWVudCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3118\n");

/***/ }),

/***/ 543:
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"applyFlightData\", ({\n    enumerable: true,\n    get: function() {\n        return applyFlightData;\n    }\n}));\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ 9839);\nconst _fillcachewithnewsubtreedata = __webpack_require__(/*! ./fill-cache-with-new-subtree-data */ 121);\nfunction applyFlightData(existingCache, cache, flightDataPath, prefetchEntry) {\n    // The one before last item is the router state tree patch\n    const [treePatch, cacheNodeSeedData, head] = flightDataPath.slice(-3);\n    // Handles case where prefetch only returns the router tree patch without rendered components.\n    if (cacheNodeSeedData === null) {\n        return false;\n    }\n    if (flightDataPath.length === 3) {\n        const rsc = cacheNodeSeedData[2];\n        const loading = cacheNodeSeedData[3];\n        cache.loading = loading;\n        cache.rsc = rsc;\n        // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n        // this path during a navigation, but until PPR is fully implemented\n        // yet it's possible the existing node does have a non-null\n        // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n        // old behavior â€” no PPR value.\n        cache.prefetchRsc = null;\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, existingCache, treePatch, cacheNodeSeedData, head, prefetchEntry);\n    } else {\n        // Copy rsc for the root node of the cache.\n        cache.rsc = existingCache.rsc;\n        // This is a PPR-only field. Unlike the previous branch, since we're\n        // just cloning the existing cache node, we might as well keep the\n        // PPR value, if it exists.\n        cache.prefetchRsc = existingCache.prefetchRsc;\n        cache.parallelRoutes = new Map(existingCache.parallelRoutes);\n        cache.loading = existingCache.loading;\n        // Create a copy of the existing cache with the rsc applied.\n        (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(cache, existingCache, flightDataPath, prefetchEntry);\n    }\n    return true;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-flight-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxpQ0FBaUNDLG1CQUFPQSxDQUFDLGlEQUF1QztBQUN0RixNQUFNQywrQkFBK0JELG1CQUFPQSxDQUFDLDZDQUFvQztBQUNqRixTQUFTRixnQkFBZ0JJLGFBQWEsRUFBRUMsS0FBSyxFQUFFQyxjQUFjLEVBQUVDLGFBQWE7SUFDeEUsMERBQTBEO0lBQzFELE1BQU0sQ0FBQ0MsV0FBV0MsbUJBQW1CQyxLQUFLLEdBQUdKLGVBQWVLLEtBQUssQ0FBQyxDQUFDO0lBQ25FLDhGQUE4RjtJQUM5RixJQUFJRixzQkFBc0IsTUFBTTtRQUM1QixPQUFPO0lBQ1g7SUFDQSxJQUFJSCxlQUFlTSxNQUFNLEtBQUssR0FBRztRQUM3QixNQUFNQyxNQUFNSixpQkFBaUIsQ0FBQyxFQUFFO1FBQ2hDLE1BQU1LLFVBQVVMLGlCQUFpQixDQUFDLEVBQUU7UUFDcENKLE1BQU1TLE9BQU8sR0FBR0E7UUFDaEJULE1BQU1RLEdBQUcsR0FBR0E7UUFDWixrRUFBa0U7UUFDbEUsb0VBQW9FO1FBQ3BFLDJEQUEyRDtRQUMzRCxrRUFBa0U7UUFDbEUsK0JBQStCO1FBQy9CUixNQUFNVSxXQUFXLEdBQUc7UUFDbkIsSUFBR2QsK0JBQStCZSw2QkFBNkIsRUFBRVgsT0FBT0QsZUFBZUksV0FBV0MsbUJBQW1CQyxNQUFNSDtJQUNoSSxPQUFPO1FBQ0gsMkNBQTJDO1FBQzNDRixNQUFNUSxHQUFHLEdBQUdULGNBQWNTLEdBQUc7UUFDN0Isb0VBQW9FO1FBQ3BFLGtFQUFrRTtRQUNsRSwyQkFBMkI7UUFDM0JSLE1BQU1VLFdBQVcsR0FBR1gsY0FBY1csV0FBVztRQUM3Q1YsTUFBTVksY0FBYyxHQUFHLElBQUlDLElBQUlkLGNBQWNhLGNBQWM7UUFDM0RaLE1BQU1TLE9BQU8sR0FBR1YsY0FBY1UsT0FBTztRQUNyQyw0REFBNEQ7UUFDM0QsSUFBR1gsNkJBQTZCZ0IsMkJBQTJCLEVBQUVkLE9BQU9ELGVBQWVFLGdCQUFnQkM7SUFDeEc7SUFDQSxPQUFPO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1gsUUFBUXdCLE9BQU8sS0FBSyxjQUFlLE9BQU94QixRQUFRd0IsT0FBTyxLQUFLLFlBQVl4QixRQUFRd0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPeEIsUUFBUXdCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckszQixPQUFPQyxjQUFjLENBQUNDLFFBQVF3QixPQUFPLEVBQUUsY0FBYztRQUFFdkIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNEIsTUFBTSxDQUFDMUIsUUFBUXdCLE9BQU8sRUFBRXhCO0lBQy9CMkIsT0FBTzNCLE9BQU8sR0FBR0EsUUFBUXdCLE9BQU87QUFDbEMsRUFFQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1mbGlnaHQtZGF0YS5qcz9mNmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlGbGlnaHREYXRhXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcHBseUZsaWdodERhdGE7XG4gICAgfVxufSk7XG5jb25zdCBfZmlsbGxhenlpdGVtc3RpbGxsZWFmd2l0aGhlYWQgPSByZXF1aXJlKFwiLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbmNvbnN0IF9maWxsY2FjaGV3aXRobmV3c3VidHJlZWRhdGEgPSByZXF1aXJlKFwiLi9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YVwiKTtcbmZ1bmN0aW9uIGFwcGx5RmxpZ2h0RGF0YShleGlzdGluZ0NhY2hlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgsIHByZWZldGNoRW50cnkpIHtcbiAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgY29uc3QgW3RyZWVQYXRjaCwgY2FjaGVOb2RlU2VlZERhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgICBpZiAoY2FjaGVOb2RlU2VlZERhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbnN0IHJzYyA9IGNhY2hlTm9kZVNlZWREYXRhWzJdO1xuICAgICAgICBjb25zdCBsb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM107XG4gICAgICAgIGNhY2hlLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICBjYWNoZS5yc2MgPSByc2M7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBQUFItb25seSBmaWVsZC4gV2hlbiBQUFIgaXMgZW5hYmxlZCwgd2Ugc2hvdWxkbid0IGhpdFxuICAgICAgICAvLyB0aGlzIHBhdGggZHVyaW5nIGEgbmF2aWdhdGlvbiwgYnV0IHVudGlsIFBQUiBpcyBmdWxseSBpbXBsZW1lbnRlZFxuICAgICAgICAvLyB5ZXQgaXQncyBwb3NzaWJsZSB0aGUgZXhpc3Rpbmcgbm9kZSBkb2VzIGhhdmUgYSBub24tbnVsbFxuICAgICAgICAvLyBgcHJlZmV0Y2hSc2NgLiBBcyBhbiBpbmNyZW1lbnRhbCBzdGVwLCB3ZSdsbCBqdXN0IGRlLW9wdCB0byB0aGVcbiAgICAgICAgLy8gb2xkIGJlaGF2aW9yIOKAlCBubyBQUFIgdmFsdWUuXG4gICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbDtcbiAgICAgICAgKDAsIF9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZC5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCkoY2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHRyZWVQYXRjaCwgY2FjaGVOb2RlU2VlZERhdGEsIGhlYWQsIHByZWZldGNoRW50cnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvcHkgcnNjIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgY2FjaGUucnNjID0gZXhpc3RpbmdDYWNoZS5yc2M7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBQUFItb25seSBmaWVsZC4gVW5saWtlIHRoZSBwcmV2aW91cyBicmFuY2gsIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGp1c3QgY2xvbmluZyB0aGUgZXhpc3RpbmcgY2FjaGUgbm9kZSwgd2UgbWlnaHQgYXMgd2VsbCBrZWVwIHRoZVxuICAgICAgICAvLyBQUFIgdmFsdWUsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBleGlzdGluZ0NhY2hlLnByZWZldGNoUnNjO1xuICAgICAgICBjYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcyk7XG4gICAgICAgIGNhY2hlLmxvYWRpbmcgPSBleGlzdGluZ0NhY2hlLmxvYWRpbmc7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGV4aXN0aW5nIGNhY2hlIHdpdGggdGhlIHJzYyBhcHBsaWVkLlxuICAgICAgICAoMCwgX2ZpbGxjYWNoZXdpdGhuZXdzdWJ0cmVlZGF0YS5maWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEpKGNhY2hlLCBleGlzdGluZ0NhY2hlLCBmbGlnaHREYXRhUGF0aCwgcHJlZmV0Y2hFbnRyeSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseS1mbGlnaHQtZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYXBwbHlGbGlnaHREYXRhIiwiX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkIiwicmVxdWlyZSIsIl9maWxsY2FjaGV3aXRobmV3c3VidHJlZWRhdGEiLCJleGlzdGluZ0NhY2hlIiwiY2FjaGUiLCJmbGlnaHREYXRhUGF0aCIsInByZWZldGNoRW50cnkiLCJ0cmVlUGF0Y2giLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJzbGljZSIsImxlbmd0aCIsInJzYyIsImxvYWRpbmciLCJwcmVmZXRjaFJzYyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///543\n");

/***/ }),

/***/ 2074:
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"applyRouterStatePatchToTree\", ({\n    enumerable: true,\n    get: function() {\n        return applyRouterStatePatchToTree;\n    }\n}));\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ 6674);\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ 9551);\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ 6363);\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */ function applyPatch(initialTree, patchTree, flightSegmentPath) {\n    const [initialSegment, initialParallelRoutes] = initialTree;\n    const [patchSegment, patchParallelRoutes] = patchTree;\n    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n    // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n    if (patchSegment === _segment.DEFAULT_SEGMENT_KEY && initialSegment !== _segment.DEFAULT_SEGMENT_KEY) {\n        return initialTree;\n    }\n    if ((0, _matchsegments.matchSegment)(initialSegment, patchSegment)) {\n        const newParallelRoutes = {};\n        for(const key in initialParallelRoutes){\n            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== \"undefined\";\n            if (isInPatchTreeParallelRoutes) {\n                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key], flightSegmentPath);\n            } else {\n                newParallelRoutes[key] = initialParallelRoutes[key];\n            }\n        }\n        for(const key in patchParallelRoutes){\n            if (newParallelRoutes[key]) {\n                continue;\n            }\n            newParallelRoutes[key] = patchParallelRoutes[key];\n        }\n        const tree = [\n            initialSegment,\n            newParallelRoutes\n        ];\n        // Copy over the existing tree\n        if (initialTree[2]) {\n            tree[2] = initialTree[2];\n        }\n        if (initialTree[3]) {\n            tree[3] = initialTree[3];\n        }\n        if (initialTree[4]) {\n            tree[4] = initialTree[4];\n        }\n        return tree;\n    }\n    return patchTree;\n}\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {\n    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = applyPatch(flightRouterState, treePatch, flightSegmentPath);\n        (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch, flightSegmentPath);\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch, path);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        {\n            ...parallelRoutes,\n            [parallelRouteKey]: parallelRoutePatch\n        },\n        url,\n        refetch\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n    return tree;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cUJBQXFCaEMsNEJBQTRCUSxrQkFBa0J5QixLQUFLLENBQUMsSUFBSVYsY0FBYyxDQUFDTyxpQkFBaUIsRUFBRVYsV0FBV0M7UUFDMUgsSUFBSVcsdUJBQXVCLE1BQU07WUFDN0IsT0FBTztRQUNYO0lBQ0o7SUFDQSxNQUFNZCxPQUFPO1FBQ1RWLGlCQUFpQixDQUFDLEVBQUU7UUFDcEI7WUFDSSxHQUFHZSxjQUFjO1lBQ2pCLENBQUNPLGlCQUFpQixFQUFFRTtRQUN4QjtRQUNBUjtRQUNBQztLQUNIO0lBQ0QscUNBQXFDO0lBQ3JDLElBQUlDLGNBQWM7UUFDZFIsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNkO0lBQ0MsSUFBR2QsaUNBQWlDd0Isd0NBQXdDLEVBQUVWLE1BQU1HO0lBQ3JGLE9BQU9IO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT3RCLFFBQVFzQyxPQUFPLEtBQUssY0FBZSxPQUFPdEMsUUFBUXNDLE9BQU8sS0FBSyxZQUFZdEMsUUFBUXNDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3RDLFFBQVFzQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLekMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRc0MsT0FBTyxFQUFFLGNBQWM7UUFBRXJDLE9BQU87SUFBSztJQUNuRUgsT0FBTzBDLE1BQU0sQ0FBQ3hDLFFBQVFzQyxPQUFPLEVBQUV0QztJQUMvQnlDLE9BQU96QyxPQUFPLEdBQUdBLFFBQVFzQyxPQUFPO0FBQ2xDLEVBRUEsNERBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUuanM/ZjdjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlO1xuICAgIH1cbn0pO1xuY29uc3QgX3NlZ21lbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50XCIpO1xuY29uc3QgX21hdGNoc2VnbWVudHMgPSByZXF1aXJlKFwiLi4vbWF0Y2gtc2VnbWVudHNcIik7XG5jb25zdCBfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyA9IHJlcXVpcmUoXCIuL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHNcIik7XG4vKipcbiAqIERlZXAgbWVyZ2Ugb2YgdGhlIHR3byByb3V0ZXIgc3RhdGVzLiBQYXJhbGxlbCByb3V0ZSBrZXlzIGFyZSBwcmVzZXJ2ZWQgaWYgdGhlIHBhdGNoIGRvZXNuJ3QgaGF2ZSB0aGVtLlxuICovIGZ1bmN0aW9uIGFwcGx5UGF0Y2goaW5pdGlhbFRyZWUsIHBhdGNoVHJlZSwgZmxpZ2h0U2VnbWVudFBhdGgpIHtcbiAgICBjb25zdCBbaW5pdGlhbFNlZ21lbnQsIGluaXRpYWxQYXJhbGxlbFJvdXRlc10gPSBpbml0aWFsVHJlZTtcbiAgICBjb25zdCBbcGF0Y2hTZWdtZW50LCBwYXRjaFBhcmFsbGVsUm91dGVzXSA9IHBhdGNoVHJlZTtcbiAgICAvLyBpZiB0aGUgYXBwbGllZCBwYXRjaCBzZWdtZW50IGlzIF9fREVGQVVMVF9fIHRoZW4gaXQgY2FuIGJlIGlnbm9yZWQgaW4gZmF2b3Igb2YgdGhlIGluaXRpYWwgdHJlZVxuICAgIC8vIHRoaXMgaXMgYmVjYXVzZSB0aGUgX19ERUZBVUxUX18gc2VnbWVudCBpcyB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgb24gbmF2aWdhdGlvblxuICAgIGlmIChwYXRjaFNlZ21lbnQgPT09IF9zZWdtZW50LkRFRkFVTFRfU0VHTUVOVF9LRVkgJiYgaW5pdGlhbFNlZ21lbnQgIT09IF9zZWdtZW50LkRFRkFVTFRfU0VHTUVOVF9LRVkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxUcmVlO1xuICAgIH1cbiAgICBpZiAoKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkoaW5pdGlhbFNlZ21lbnQsIHBhdGNoU2VnbWVudCkpIHtcbiAgICAgICAgY29uc3QgbmV3UGFyYWxsZWxSb3V0ZXMgPSB7fTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBpbml0aWFsUGFyYWxsZWxSb3V0ZXMpe1xuICAgICAgICAgICAgY29uc3QgaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzID0gdHlwZW9mIHBhdGNoUGFyYWxsZWxSb3V0ZXNba2V5XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgICAgIGlmIChpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbGxlbFJvdXRlc1trZXldID0gYXBwbHlQYXRjaChpbml0aWFsUGFyYWxsZWxSb3V0ZXNba2V5XSwgcGF0Y2hQYXJhbGxlbFJvdXRlc1trZXldLCBmbGlnaHRTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBpbml0aWFsUGFyYWxsZWxSb3V0ZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IoY29uc3Qga2V5IGluIHBhdGNoUGFyYWxsZWxSb3V0ZXMpe1xuICAgICAgICAgICAgaWYgKG5ld1BhcmFsbGVsUm91dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBwYXRjaFBhcmFsbGVsUm91dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJlZSA9IFtcbiAgICAgICAgICAgIGluaXRpYWxTZWdtZW50LFxuICAgICAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNcbiAgICAgICAgXTtcbiAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBleGlzdGluZyB0cmVlXG4gICAgICAgIGlmIChpbml0aWFsVHJlZVsyXSkge1xuICAgICAgICAgICAgdHJlZVsyXSA9IGluaXRpYWxUcmVlWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsVHJlZVszXSkge1xuICAgICAgICAgICAgdHJlZVszXSA9IGluaXRpYWxUcmVlWzNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsVHJlZVs0XSkge1xuICAgICAgICAgICAgdHJlZVs0XSA9IGluaXRpYWxUcmVlWzRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hUcmVlO1xufVxuZnVuY3Rpb24gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKGZsaWdodFNlZ21lbnRQYXRoLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgdHJlZVBhdGNoLCBwYXRoKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCB1cmwsIHJlZmV0Y2gsIGlzUm9vdExheW91dF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBSb290IHJlZnJlc2hcbiAgICBpZiAoZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBhcHBseVBhdGNoKGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gsIGZsaWdodFNlZ21lbnRQYXRoKTtcbiAgICAgICAgKDAsIF9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzLmFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMpKHRyZWUsIHBhdGgpO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIFRyZWUgcGF0aCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBtYXRjaCB1cCB3aXRoIHRoZSBjdXJyZW50IHRyZWUgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAoISgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDI7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVQYXRjaDtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gYXBwbHlQYXRjaChwYXJhbGxlbFJvdXRlc1twYXJhbGxlbFJvdXRlS2V5XSwgdHJlZVBhdGNoLCBmbGlnaHRTZWdtZW50UGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpLCBwYXJhbGxlbFJvdXRlc1twYXJhbGxlbFJvdXRlS2V5XSwgdHJlZVBhdGNoLCBwYXRoKTtcbiAgICAgICAgaWYgKHBhcmFsbGVsUm91dGVQYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJlZSA9IFtcbiAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhbMF0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC4uLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiBwYXJhbGxlbFJvdXRlUGF0Y2hcbiAgICAgICAgfSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZWZldGNoXG4gICAgXTtcbiAgICAvLyBDdXJyZW50IHNlZ21lbnQgaXMgdGhlIHJvb3QgbGF5b3V0XG4gICAgaWYgKGlzUm9vdExheW91dCkge1xuICAgICAgICB0cmVlWzRdID0gdHJ1ZTtcbiAgICB9XG4gICAgKDAsIF9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzLmFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMpKHRyZWUsIHBhdGgpO1xuICAgIHJldHVybiB0cmVlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiX3NlZ21lbnQiLCJyZXF1aXJlIiwiX21hdGNoc2VnbWVudHMiLCJfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyIsImFwcGx5UGF0Y2giLCJpbml0aWFsVHJlZSIsInBhdGNoVHJlZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiaW5pdGlhbFNlZ21lbnQiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJwYXRjaFNlZ21lbnQiLCJwYXRjaFBhcmFsbGVsUm91dGVzIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsIm1hdGNoU2VnbWVudCIsIm5ld1BhcmFsbGVsUm91dGVzIiwia2V5IiwiaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzIiwidHJlZSIsImZsaWdodFJvdXRlclN0YXRlIiwidHJlZVBhdGNoIiwicGF0aCIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsInVybCIsInJlZmV0Y2giLCJpc1Jvb3RMYXlvdXQiLCJsZW5ndGgiLCJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwiY3VycmVudFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwibGFzdFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlUGF0Y2giLCJzbGljZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2074\n");

/***/ }),

/***/ 169:
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js ***!
  \***********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"clearCacheNodeDataForSegmentPath\", ({\n    enumerable: true,\n    get: function() {\n        return clearCacheNodeDataForSegmentPath;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ 4317);\nfunction clearCacheNodeDataForSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap == null ? void 0 : existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading: null\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading: null\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes),\n            lazyDataResolved: childCacheNode.lazyDataResolved,\n            loading: childCacheNode.loading\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    return clearCacheNodeDataForSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=clear-cache-node-data-for-segment-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2xDLEVBRUEsa0VBQWtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY2xlYXItY2FjaGUtbm9kZS1kYXRhLWZvci1zZWdtZW50LXBhdGguanM/MDcyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aDtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuZnVuY3Rpb24gY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMjtcbiAgICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICBjb25zdCBjYWNoZUtleSA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnQpO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID09IG51bGwgPyB2b2lkIDAgOiBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgIGxldCBjaGlsZENhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IG9mZiB0aGUgZmV0Y2ggYXQgdGhpcyBsZXZlbCBhbmQgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhIHx8IGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICAgICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgbGF6eURhdGFSZXNvbHZlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9hZGluZzogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIFN0YXJ0IGZldGNoIGluIHRoZSBwbGFjZSB3aGVyZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lc24ndCBoYXZlIHRoZSBkYXRhIHlldC5cbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwge1xuICAgICAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgbGF6eURhdGE6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICAgICAgICBwcmVmZXRjaFJzYzogY2hpbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICAgICAgICBoZWFkOiBjaGlsZENhY2hlTm9kZS5oZWFkLFxuICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcyksXG4gICAgICAgICAgICBsYXp5RGF0YVJlc29sdmVkOiBjaGlsZENhY2hlTm9kZS5sYXp5RGF0YVJlc29sdmVkLFxuICAgICAgICAgICAgbG9hZGluZzogY2hpbGRDYWNoZU5vZGUubG9hZGluZ1xuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aChjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0U2VnbWVudFBhdGguc2xpY2UoMikpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGVhci1jYWNoZS1ub2RlLWRhdGEtZm9yLXNlZ21lbnQtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJyZXF1aXJlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsImxhenlEYXRhUmVzb2x2ZWQiLCJsb2FkaW5nIiwic2xpY2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///169\n");

/***/ }),

/***/ 9314:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    computeChangedPath: function() {\n        return computeChangedPath;\n    },\n    extractPathFromFlightRouterState: function() {\n        return extractPathFromFlightRouterState;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../server/future/helpers/interception-routes */ 8005);\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ 6674);\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ 9551);\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === \"/\" ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === \"string\") {\n        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n        if (segment === \"children\") return \"\";\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === \"\" || (0, _segment.isGroupSegment)(segment)) {\n            return acc;\n        }\n        return acc + \"/\" + segment;\n    }, \"\") || \"/\";\n}\nfunction extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return \"\";\n    const segments = [\n        segmentToPathname(segment)\n    ];\n    var _flightRouterState_;\n    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === \"children\") continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return \"\";\n    }\n    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {\n        var _extractPathFromFlightRouterState;\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : \"\";\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return segmentToPathname(segmentB) + \"/\" + changedPath;\n            }\n        }\n    }\n    return null;\n}\nfunction computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === \"/\") {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split(\"/\"));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=compute-changed-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxDQUFDMUQsUUFBUXdELE9BQU8sRUFBRXhEO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF3RCxPQUFPO0FBQ2xDLEVBRUEsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY29tcHV0ZS1jaGFuZ2VkLXBhdGguanM/NjA5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbXB1dGVDaGFuZ2VkUGF0aDogbnVsbCxcbiAgICBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBjb21wdXRlQ2hhbmdlZFBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZUNoYW5nZWRQYXRoO1xuICAgIH0sXG4gICAgZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuY29uc3QgX3NlZ21lbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50XCIpO1xuY29uc3QgX21hdGNoc2VnbWVudHMgPSByZXF1aXJlKFwiLi4vbWF0Y2gtc2VnbWVudHNcIik7XG5jb25zdCByZW1vdmVMZWFkaW5nU2xhc2ggPSAoc2VnbWVudCk9PntcbiAgICByZXR1cm4gc2VnbWVudFswXSA9PT0gXCIvXCIgPyBzZWdtZW50LnNsaWNlKDEpIDogc2VnbWVudDtcbn07XG5jb25zdCBzZWdtZW50VG9QYXRobmFtZSA9IChzZWdtZW50KT0+e1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyAnY2hpbGRyZW4nIGlzIG5vdCBhIHZhbGlkIHBhdGggLS0gaXQncyB0ZWNobmljYWxseSBhIHBhcmFsbGVsIHJvdXRlIHRoYXQgY29ycmVzcG9uZHMgd2l0aCB0aGUgY3VycmVudCBzZWdtZW50J3MgcGFnZVxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBza2lwIGl0LCB0aGVuIHRoZSBjb21wdXRlZCBwYXRobmFtZSBtaWdodCBiZSBzb21ldGhpbmcgbGlrZSBgL2NoaWxkcmVuYCB3aGljaCBkb2Vzbid0IG1ha2Ugc2Vuc2UuXG4gICAgICAgIGlmIChzZWdtZW50ID09PSBcImNoaWxkcmVuXCIpIHJldHVybiBcIlwiO1xuICAgICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ21lbnRbMV07XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudHMoc2VnbWVudHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHMucmVkdWNlKChhY2MsIHNlZ21lbnQpPT57XG4gICAgICAgIHNlZ21lbnQgPSByZW1vdmVMZWFkaW5nU2xhc2goc2VnbWVudCk7XG4gICAgICAgIGlmIChzZWdtZW50ID09PSBcIlwiIHx8ICgwLCBfc2VnbWVudC5pc0dyb3VwU2VnbWVudCkoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYyArIFwiL1wiICsgc2VnbWVudDtcbiAgICB9LCBcIlwiKSB8fCBcIi9cIjtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKGZsaWdodFJvdXRlclN0YXRlKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IEFycmF5LmlzQXJyYXkoZmxpZ2h0Um91dGVyU3RhdGVbMF0pID8gZmxpZ2h0Um91dGVyU3RhdGVbMF1bMV0gOiBmbGlnaHRSb3V0ZXJTdGF0ZVswXTtcbiAgICBpZiAoc2VnbWVudCA9PT0gX3NlZ21lbnQuREVGQVVMVF9TRUdNRU5UX0tFWSB8fCBfaW50ZXJjZXB0aW9ucm91dGVzLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUoKG0pPT5zZWdtZW50LnN0YXJ0c1dpdGgobSkpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoX3NlZ21lbnQuUEFHRV9TRUdNRU5UX0tFWSkpIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gW1xuICAgICAgICBzZWdtZW50VG9QYXRobmFtZShzZWdtZW50KVxuICAgIF07XG4gICAgdmFyIF9mbGlnaHRSb3V0ZXJTdGF0ZV87XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSAoX2ZsaWdodFJvdXRlclN0YXRlXyA9IGZsaWdodFJvdXRlclN0YXRlWzFdKSAhPSBudWxsID8gX2ZsaWdodFJvdXRlclN0YXRlXyA6IHt9O1xuICAgIGNvbnN0IGNoaWxkcmVuUGF0aCA9IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuID8gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUocGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4pIDogdW5kZWZpbmVkO1xuICAgIGlmIChjaGlsZHJlblBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKGNoaWxkcmVuUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYWxsZWxSb3V0ZXMpKXtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiY2hpbGRyZW5cIikgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2hpbGRQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGNoaWxkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNlZ21lbnRzKHNlZ21lbnRzKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUGF0aEltcGwodHJlZUEsIHRyZWVCKSB7XG4gICAgY29uc3QgW3NlZ21lbnRBLCBwYXJhbGxlbFJvdXRlc0FdID0gdHJlZUE7XG4gICAgY29uc3QgW3NlZ21lbnRCLCBwYXJhbGxlbFJvdXRlc0JdID0gdHJlZUI7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNlZ21lbnRBID0gc2VnbWVudFRvUGF0aG5hbWUoc2VnbWVudEEpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWdtZW50QiA9IHNlZ21lbnRUb1BhdGhuYW1lKHNlZ21lbnRCKTtcbiAgICBpZiAoX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5zb21lKChtKT0+bm9ybWFsaXplZFNlZ21lbnRBLnN0YXJ0c1dpdGgobSkgfHwgbm9ybWFsaXplZFNlZ21lbnRCLnN0YXJ0c1dpdGgobSkpKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBpZiAoISgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHNlZ21lbnRBLCBzZWdtZW50QikpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAgICAgLy8gb25jZSB3ZSBmaW5kIHdoZXJlIHRoZSB0cmVlIGNoYW5nZWQsIHdlIGNvbXB1dGUgdGhlIHJlc3Qgb2YgdGhlIHBhdGggYnkgdHJhdmVyc2luZyB0aGUgdHJlZVxuICAgICAgICByZXR1cm4gKF9leHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSA9IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKHRyZWVCKSkgIT0gbnVsbCA/IF9leHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSA6IFwiXCI7XG4gICAgfVxuICAgIGZvcihjb25zdCBwYXJhbGxlbFJvdXRlcktleSBpbiBwYXJhbGxlbFJvdXRlc0Epe1xuICAgICAgICBpZiAocGFyYWxsZWxSb3V0ZXNCW3BhcmFsbGVsUm91dGVyS2V5XSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZFBhdGggPSBjb21wdXRlQ2hhbmdlZFBhdGhJbXBsKHBhcmFsbGVsUm91dGVzQVtwYXJhbGxlbFJvdXRlcktleV0sIHBhcmFsbGVsUm91dGVzQltwYXJhbGxlbFJvdXRlcktleV0pO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRQYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRUb1BhdGhuYW1lKHNlZ21lbnRCKSArIFwiL1wiICsgY2hhbmdlZFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2hhbmdlZFBhdGgodHJlZUEsIHRyZWVCKSB7XG4gICAgY29uc3QgY2hhbmdlZFBhdGggPSBjb21wdXRlQ2hhbmdlZFBhdGhJbXBsKHRyZWVBLCB0cmVlQik7XG4gICAgaWYgKGNoYW5nZWRQYXRoID09IG51bGwgfHwgY2hhbmdlZFBhdGggPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkUGF0aDtcbiAgICB9XG4gICAgLy8gbGlnaHR3ZWlnaHQgbm9ybWFsaXphdGlvbiB0byByZW1vdmUgcm91dGUgZ3JvdXBzXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNlZ21lbnRzKGNoYW5nZWRQYXRoLnNwbGl0KFwiL1wiKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXB1dGUtY2hhbmdlZC1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImNvbXB1dGVDaGFuZ2VkUGF0aCIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2ludGVyY2VwdGlvbnJvdXRlcyIsInJlcXVpcmUiLCJfc2VnbWVudCIsIl9tYXRjaHNlZ21lbnRzIiwicmVtb3ZlTGVhZGluZ1NsYXNoIiwic2VnbWVudCIsInNsaWNlIiwic2VnbWVudFRvUGF0aG5hbWUiLCJub3JtYWxpemVTZWdtZW50cyIsInNlZ21lbnRzIiwicmVkdWNlIiwiYWNjIiwiaXNHcm91cFNlZ21lbnQiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIkFycmF5IiwiaXNBcnJheSIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsInNvbWUiLCJtIiwic3RhcnRzV2l0aCIsInVuZGVmaW5lZCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJfZmxpZ2h0Um91dGVyU3RhdGVfIiwicGFyYWxsZWxSb3V0ZXMiLCJjaGlsZHJlblBhdGgiLCJjaGlsZHJlbiIsInB1c2giLCJrZXkiLCJlbnRyaWVzIiwiY2hpbGRQYXRoIiwiY29tcHV0ZUNoYW5nZWRQYXRoSW1wbCIsInRyZWVBIiwidHJlZUIiLCJzZWdtZW50QSIsInBhcmFsbGVsUm91dGVzQSIsInNlZ21lbnRCIiwicGFyYWxsZWxSb3V0ZXNCIiwibm9ybWFsaXplZFNlZ21lbnRBIiwibm9ybWFsaXplZFNlZ21lbnRCIiwibWF0Y2hTZWdtZW50IiwiX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwicGFyYWxsZWxSb3V0ZXJLZXkiLCJjaGFuZ2VkUGF0aCIsInNwbGl0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9314\n");

/***/ }),

/***/ 5471:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js ***!
  \*****************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createHrefFromUrl\", ({\n    enumerable: true,\n    get: function() {\n        return createHrefFromUrl;\n    }\n}));\nfunction createHrefFromUrl(url, includeHash) {\n    if (includeHash === void 0) includeHash = true;\n    return url.pathname + url.search + (includeHash ? url.hash : \"\");\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-href-from-url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ3MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgscURBQW9EO0lBQ2hESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0Esa0JBQWtCQyxHQUFHLEVBQUVDLFdBQVc7SUFDdkMsSUFBSUEsZ0JBQWdCLEtBQUssR0FBR0EsY0FBYztJQUMxQyxPQUFPRCxJQUFJRSxRQUFRLEdBQUdGLElBQUlHLE1BQU0sR0FBSUYsQ0FBQUEsY0FBY0QsSUFBSUksSUFBSSxHQUFHLEVBQUM7QUFDbEU7QUFFQSxJQUFJLENBQUMsT0FBT1QsUUFBUVUsT0FBTyxLQUFLLGNBQWUsT0FBT1YsUUFBUVUsT0FBTyxLQUFLLFlBQVlWLFFBQVFVLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1YsUUFBUVUsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRVSxPQUFPLEVBQUUsY0FBYztRQUFFVCxPQUFPO0lBQUs7SUFDbkVILE9BQU9jLE1BQU0sQ0FBQ1osUUFBUVUsT0FBTyxFQUFFVjtJQUMvQmEsT0FBT2IsT0FBTyxHQUFHQSxRQUFRVSxPQUFPO0FBQ2xDLEVBRUEsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwuanM/YTc3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUhyZWZGcm9tVXJsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIcmVmRnJvbVVybDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUhyZWZGcm9tVXJsKHVybCwgaW5jbHVkZUhhc2gpIHtcbiAgICBpZiAoaW5jbHVkZUhhc2ggPT09IHZvaWQgMCkgaW5jbHVkZUhhc2ggPSB0cnVlO1xuICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgKGluY2x1ZGVIYXNoID8gdXJsLmhhc2ggOiBcIlwiKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWhyZWYtZnJvbS11cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidXJsIiwiaW5jbHVkZUhhc2giLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5471\n");

/***/ }),

/***/ 4432:
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createInitialRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ 5471);\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ 9839);\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ 9314);\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ 4614);\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ 744);\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ 6363);\nfunction createInitialRouterState(param) {\n    let { buildId, initialTree, initialSeedData, urlParts, initialParallelRoutes, location, initialHead, couldBeIntercepted } = param;\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = urlParts.join(\"/\");\n    const isServer = !location;\n    const rsc = initialSeedData[2];\n    const cache = {\n        lazyData: null,\n        rsc: rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: isServer ? new Map() : initialParallelRoutes,\n        lazyDataResolved: false,\n        loading: initialSeedData[3]\n    };\n    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    const prefetchCache = new Map();\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, initialTree, initialSeedData, initialHead);\n    }\n    var _ref;\n    const initialState = {\n        buildId,\n        tree: initialTree,\n        cache,\n        prefetchCache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n    if (location) {\n        // Seed the prefetch cache with this page's data.\n        // This is to prevent needlessly re-prefetching a page that is already reusable,\n        // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n        const url = new URL(\"\" + location.pathname + location.search, location.origin);\n        const initialFlightData = [\n            [\n                \"\",\n                initialTree,\n                null,\n                null\n            ]\n        ];\n        (0, _prefetchcacheutils.createPrefetchCacheEntryForInitialLoad)({\n            url,\n            kind: _routerreducertypes.PrefetchKind.AUTO,\n            data: [\n                initialFlightData,\n                undefined,\n                false,\n                couldBeIntercepted\n            ],\n            tree: initialState.tree,\n            prefetchCache: initialState.prefetchCache,\n            nextUrl: initialState.nextUrl\n        });\n    }\n    return initialState;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWVLLGFBQWFMLGFBQWE7WUFDekNnQixTQUFTWCxhQUFhVyxPQUFPO1FBQ2pDO0lBQ0o7SUFDQSxPQUFPWDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU8xQyxRQUFRa0UsT0FBTyxLQUFLLGNBQWUsT0FBT2xFLFFBQVFrRSxPQUFPLEtBQUssWUFBWWxFLFFBQVFrRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9sRSxRQUFRa0UsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3JFLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWtFLE9BQU8sRUFBRSxjQUFjO1FBQUVqRSxPQUFPO0lBQUs7SUFDbkVILE9BQU9zRSxNQUFNLENBQUNwRSxRQUFRa0UsT0FBTyxFQUFFbEU7SUFDL0JxRSxPQUFPckUsT0FBTyxHQUFHQSxRQUFRa0UsT0FBTztBQUNsQyxFQUVBLHVEQUF1RCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZS5qcz9kY2I0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGU7XG4gICAgfVxufSk7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZCA9IHJlcXVpcmUoXCIuL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkXCIpO1xuY29uc3QgX2NvbXB1dGVjaGFuZ2VkcGF0aCA9IHJlcXVpcmUoXCIuL2NvbXB1dGUtY2hhbmdlZC1wYXRoXCIpO1xuY29uc3QgX3ByZWZldGNoY2FjaGV1dGlscyA9IHJlcXVpcmUoXCIuL3ByZWZldGNoLWNhY2hlLXV0aWxzXCIpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuY29uc3QgX3JlZmV0Y2hpbmFjdGl2ZXBhcmFsbGVsc2VnbWVudHMgPSByZXF1aXJlKFwiLi9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzXCIpO1xuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlKHBhcmFtKSB7XG4gICAgbGV0IHsgYnVpbGRJZCwgaW5pdGlhbFRyZWUsIGluaXRpYWxTZWVkRGF0YSwgdXJsUGFydHMsIGluaXRpYWxQYXJhbGxlbFJvdXRlcywgbG9jYXRpb24sIGluaXRpYWxIZWFkLCBjb3VsZEJlSW50ZXJjZXB0ZWQgfSA9IHBhcmFtO1xuICAgIC8vIFdoZW4gaW5pdGlhbGl6ZWQgb24gdGhlIHNlcnZlciwgdGhlIGNhbm9uaWNhbCBVUkwgaXMgcHJvdmlkZWQgYXMgYW4gYXJyYXkgb2YgcGFydHMuXG4gICAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB3aGVuIHRoZSBSU0MgcGF5bG9hZCBzdHJlYW1lZCB0byB0aGUgY2xpZW50LCBjcmF3bGVycyBkb24ndCBpbnRlcnByZXQgaXRcbiAgICAvLyBhcyBhIFVSTCB0aGF0IHNob3VsZCBiZSBjcmF3bGVkLlxuICAgIGNvbnN0IGluaXRpYWxDYW5vbmljYWxVcmwgPSB1cmxQYXJ0cy5qb2luKFwiL1wiKTtcbiAgICBjb25zdCBpc1NlcnZlciA9ICFsb2NhdGlvbjtcbiAgICBjb25zdCByc2MgPSBpbml0aWFsU2VlZERhdGFbMl07XG4gICAgY29uc3QgY2FjaGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2M6IHJzYyxcbiAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgLy8gVGhlIGNhY2hlIGdldHMgc2VlZGVkIGR1cmluZyB0aGUgZmlyc3QgcmVuZGVyLiBgaW5pdGlhbFBhcmFsbGVsUm91dGVzYCBlbnN1cmVzIHRoZSBjYWNoZSBmcm9tIHRoZSBmaXJzdCByZW5kZXIgaXMgdGhlcmUgZHVyaW5nIHRoZSBzZWNvbmQgcmVuZGVyLlxuICAgICAgICBwYXJhbGxlbFJvdXRlczogaXNTZXJ2ZXIgPyBuZXcgTWFwKCkgOiBpbml0aWFsUGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nOiBpbml0aWFsU2VlZERhdGFbM11cbiAgICB9O1xuICAgIGNvbnN0IGNhbm9uaWNhbFVybCA9IC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgLy8gVGhpcyBpcyBzYWZlIHRvIGRvIGFzIGNhbm9uaWNhbFVybCBjYW4ndCBiZSByZW5kZXJlZCwgaXQncyBvbmx5IHVzZWQgdG8gY29udHJvbCB0aGUgaGlzdG9yeSB1cGRhdGVzIGluIHRoZSB1c2VFZmZlY3QgZnVydGhlciBkb3duIGluIHRoaXMgZmlsZS5cbiAgICBsb2NhdGlvbiA/ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKGxvY2F0aW9uKSA6IGluaXRpYWxDYW5vbmljYWxVcmw7XG4gICAgKDAsIF9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzLmFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMpKGluaXRpYWxUcmVlLCBjYW5vbmljYWxVcmwpO1xuICAgIGNvbnN0IHByZWZldGNoQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgLy8gV2hlbiB0aGUgY2FjaGUgaGFzbid0IGJlZW4gc2VlZGVkIHlldCB3ZSBmaWxsIHRoZSBjYWNoZSB3aXRoIHRoZSBoZWFkLlxuICAgIGlmIChpbml0aWFsUGFyYWxsZWxSb3V0ZXMgPT09IG51bGwgfHwgaW5pdGlhbFBhcmFsbGVsUm91dGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgKDAsIF9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZC5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCkoY2FjaGUsIHVuZGVmaW5lZCwgaW5pdGlhbFRyZWUsIGluaXRpYWxTZWVkRGF0YSwgaW5pdGlhbEhlYWQpO1xuICAgIH1cbiAgICB2YXIgLy8gdGhlIHx8IG9wZXJhdG9yIGlzIGludGVudGlvbmFsLCB0aGUgcGF0aG5hbWUgY2FuIGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgIF9yZWY7XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICBidWlsZElkLFxuICAgICAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgIHBlbmRpbmdQdXNoOiBmYWxzZSxcbiAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgLy8gRmlyc3QgcmVuZGVyIG5lZWRzIHRvIHByZXNlcnZlIHRoZSBwcmV2aW91cyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgaXQgYmVpbmcgb3ZlcndyaXR0ZW4gb24gbmF2aWdhdGlvbiBiYWNrL2ZvcndhcmQgd2l0aCBNUEEgTmF2aWdhdGlvbi5cbiAgICAgICAgICAgIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICBhcHBseTogZmFsc2UsXG4gICAgICAgICAgICBvbmx5SGFzaENoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBoYXNoRnJhZ21lbnQ6IG51bGwsXG4gICAgICAgICAgICBzZWdtZW50UGF0aHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgICAgbmV4dFVybDogKF9yZWYgPSAoMCwgX2NvbXB1dGVjaGFuZ2VkcGF0aC5leHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSkoaW5pdGlhbFRyZWUpIHx8IChsb2NhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogbG9jYXRpb24ucGF0aG5hbWUpKSAhPSBudWxsID8gX3JlZiA6IG51bGxcbiAgICB9O1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAvLyBTZWVkIHRoZSBwcmVmZXRjaCBjYWNoZSB3aXRoIHRoaXMgcGFnZSdzIGRhdGEuXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBuZWVkbGVzc2x5IHJlLXByZWZldGNoaW5nIGEgcGFnZSB0aGF0IGlzIGFscmVhZHkgcmV1c2FibGUsXG4gICAgICAgIC8vIGFuZCB3aWxsIGF2b2lkIHRyaWdnZXJpbmcgYSBsb2FkaW5nIHN0YXRlL2RhdGEgZmV0Y2ggc3RhbGwgd2hlbiBuYXZpZ2F0aW5nIGJhY2sgdG8gdGhlIHBhZ2UuXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoLCBsb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICBjb25zdCBpbml0aWFsRmxpZ2h0RGF0YSA9IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgIGluaXRpYWxUcmVlLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXVxuICAgICAgICBdO1xuICAgICAgICAoMCwgX3ByZWZldGNoY2FjaGV1dGlscy5jcmVhdGVQcmVmZXRjaENhY2hlRW50cnlGb3JJbml0aWFsTG9hZCkoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAga2luZDogX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuQVVUTyxcbiAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICBpbml0aWFsRmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgY291bGRCZUludGVyY2VwdGVkXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdHJlZTogaW5pdGlhbFN0YXRlLnRyZWUsXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBpbml0aWFsU3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgIG5leHRVcmw6IGluaXRpYWxTdGF0ZS5uZXh0VXJsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbFN0YXRlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSIsIl9jcmVhdGVocmVmZnJvbXVybCIsInJlcXVpcmUiLCJfZmlsbGxhenlpdGVtc3RpbGxsZWFmd2l0aGhlYWQiLCJfY29tcHV0ZWNoYW5nZWRwYXRoIiwiX3ByZWZldGNoY2FjaGV1dGlscyIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyIsInBhcmFtIiwiYnVpbGRJZCIsImluaXRpYWxUcmVlIiwiaW5pdGlhbFNlZWREYXRhIiwidXJsUGFydHMiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJsb2NhdGlvbiIsImluaXRpYWxIZWFkIiwiY291bGRCZUludGVyY2VwdGVkIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImpvaW4iLCJpc1NlcnZlciIsInJzYyIsImNhY2hlIiwibGF6eURhdGEiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJwYXJhbGxlbFJvdXRlcyIsIk1hcCIsImxhenlEYXRhUmVzb2x2ZWQiLCJsb2FkaW5nIiwiY2Fub25pY2FsVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwicHJlZmV0Y2hDYWNoZSIsInNpemUiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInVuZGVmaW5lZCIsIl9yZWYiLCJpbml0aWFsU3RhdGUiLCJ0cmVlIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsIm9ubHlIYXNoQ2hhbmdlIiwiaGFzaEZyYWdtZW50Iiwic2VnbWVudFBhdGhzIiwibmV4dFVybCIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwicGF0aG5hbWUiLCJ1cmwiLCJVUkwiLCJzZWFyY2giLCJvcmlnaW4iLCJpbml0aWFsRmxpZ2h0RGF0YSIsImNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeUZvckluaXRpYWxMb2FkIiwia2luZCIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJkYXRhIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4432\n");

/***/ }),

/***/ 4317:
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createRouterCacheKey\", ({\n    enumerable: true,\n    get: function() {\n        return createRouterCacheKey;\n    }\n}));\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ 6674);\nfunction createRouterCacheKey(segment, withoutSearchParameters) {\n    if (withoutSearchParameters === void 0) withoutSearchParameters = false;\n    // if the segment is an array, it means it's a dynamic segment\n    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n    if (Array.isArray(segment)) {\n        return segment[0] + \"|\" + segment[1] + \"|\" + segment[2];\n    }\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\n    // When `withoutSearchParameters` is true, we only want to return the page segment\n    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-router-cache-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMxNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsd0RBQXVEO0lBQ25ESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsV0FBV0MsbUJBQU9BLENBQUMsdUNBQTZCO0FBQ3RELFNBQVNGLHFCQUFxQkcsT0FBTyxFQUFFQyx1QkFBdUI7SUFDMUQsSUFBSUEsNEJBQTRCLEtBQUssR0FBR0EsMEJBQTBCO0lBQ2xFLDhEQUE4RDtJQUM5RCx1R0FBdUc7SUFDdkcsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxVQUFVO1FBQ3hCLE9BQU9BLE9BQU8sQ0FBQyxFQUFFLEdBQUcsTUFBTUEsT0FBTyxDQUFDLEVBQUUsR0FBRyxNQUFNQSxPQUFPLENBQUMsRUFBRTtJQUMzRDtJQUNBLGtFQUFrRTtJQUNsRSxrRkFBa0Y7SUFDbEYsSUFBSUMsMkJBQTJCRCxRQUFRSSxVQUFVLENBQUNOLFNBQVNPLGdCQUFnQixHQUFHO1FBQzFFLE9BQU9QLFNBQVNPLGdCQUFnQjtJQUNwQztJQUNBLE9BQU9MO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1AsUUFBUWEsT0FBTyxLQUFLLGNBQWUsT0FBT2IsUUFBUWEsT0FBTyxLQUFLLFlBQVliLFFBQVFhLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2IsUUFBUWEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWEsT0FBTyxFQUFFLGNBQWM7UUFBRVosT0FBTztJQUFLO0lBQ25FSCxPQUFPaUIsTUFBTSxDQUFDZixRQUFRYSxPQUFPLEVBQUViO0lBQy9CZ0IsT0FBT2hCLE9BQU8sR0FBR0EsUUFBUWEsT0FBTztBQUNsQyxFQUVBLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5LmpzP2ZlYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSb3V0ZXJDYWNoZUtleVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUm91dGVyQ2FjaGVLZXk7XG4gICAgfVxufSk7XG5jb25zdCBfc2VnbWVudCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnRcIik7XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50LCB3aXRob3V0U2VhcmNoUGFyYW1ldGVycykge1xuICAgIGlmICh3aXRob3V0U2VhcmNoUGFyYW1ldGVycyA9PT0gdm9pZCAwKSB3aXRob3V0U2VhcmNoUGFyYW1ldGVycyA9IGZhbHNlO1xuICAgIC8vIGlmIHRoZSBzZWdtZW50IGlzIGFuIGFycmF5LCBpdCBtZWFucyBpdCdzIGEgZHluYW1pYyBzZWdtZW50XG4gICAgLy8gZm9yIGV4YW1wbGUsIFsnbGFuZycsICdlbicsICdkJ10uIFdlIG5lZWQgdG8gY29udmVydCBpdCB0byBhIHN0cmluZyB0byBzdG9yZSBpdCBhcyBhIGNhY2hlIG5vZGUga2V5LlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50WzBdICsgXCJ8XCIgKyBzZWdtZW50WzFdICsgXCJ8XCIgKyBzZWdtZW50WzJdO1xuICAgIH1cbiAgICAvLyBQYWdlIHNlZ21lbnRzIG1pZ2h0IGhhdmUgc2VhcmNoIHBhcmFtZXRlcnMsIGllIF9fUEFHRV9fP2Zvbz1iYXJcbiAgICAvLyBXaGVuIGB3aXRob3V0U2VhcmNoUGFyYW1ldGVyc2AgaXMgdHJ1ZSwgd2Ugb25seSB3YW50IHRvIHJldHVybiB0aGUgcGFnZSBzZWdtZW50XG4gICAgaWYgKHdpdGhvdXRTZWFyY2hQYXJhbWV0ZXJzICYmIHNlZ21lbnQuc3RhcnRzV2l0aChfc2VnbWVudC5QQUdFX1NFR01FTlRfS0VZKSkge1xuICAgICAgICByZXR1cm4gX3NlZ21lbnQuUEFHRV9TRUdNRU5UX0tFWTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ21lbnQ7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1yb3V0ZXItY2FjaGUta2V5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsIl9zZWdtZW50IiwicmVxdWlyZSIsInNlZ21lbnQiLCJ3aXRob3V0U2VhcmNoUGFyYW1ldGVycyIsIkFycmF5IiwiaXNBcnJheSIsInN0YXJ0c1dpdGgiLCJQQUdFX1NFR01FTlRfS0VZIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4317\n");

/***/ }),

/***/ 882:
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"fetchServerResponse\", ({\n    enumerable: true,\n    get: function() {\n        return fetchServerResponse;\n    }\n}));\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ 7700);\nconst _approuter = __webpack_require__(/*! ../app-router */ 3642);\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ 689);\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ 744);\nconst _hash = __webpack_require__(/*! ../../../shared/lib/hash */ 951);\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\nconst { createFromFetch } =  true ? __webpack_require__(/*! react-server-dom-webpack/client.edge */ 5032) : 0;\nfunction doMpaNavigation(url) {\n    return [\n        (0, _approuter.urlToUrlWithoutFlightMarker)(url).toString(),\n        undefined,\n        false,\n        false\n    ];\n}\nasync function fetchServerResponse(url, flightRouterState, nextUrl, currentBuildId, prefetchKind) {\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: \"1\",\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(flightRouterState))\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = \"1\";\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    if (false) {}\n    const uniqueCacheQuery = (0, _hash.hexHash)([\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || \"0\",\n        headers[_approuterheaders.NEXT_ROUTER_STATE_TREE],\n        headers[_approuterheaders.NEXT_URL]\n    ].join(\",\"));\n    try {\n        var _res_headers_get;\n        let fetchUrl = new URL(url);\n        if (false) {}\n        // Add unique cache query to avoid caching conflicts on CDN which don't respect to Vary header\n        fetchUrl.searchParams.set(_approuterheaders.NEXT_RSC_UNION_QUERY, uniqueCacheQuery);\n        const res = await fetch(fetchUrl, {\n            // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n            credentials: \"same-origin\",\n            headers\n        });\n        const responseUrl = (0, _approuter.urlToUrlWithoutFlightMarker)(res.url);\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get(\"content-type\") || \"\";\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const interception = !!((_res_headers_get = res.headers.get(\"vary\")) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        let isFlightResponse = contentType === _approuterheaders.RSC_CONTENT_TYPE_HEADER;\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const [buildId, flightData] = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer\n        });\n        if (currentBuildId !== buildId) {\n            return doMpaNavigation(res.url);\n        }\n        return [\n            flightData,\n            canonicalUrl,\n            postponed,\n            interception\n        ];\n    } catch (err) {\n        console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return [\n            url.toString(),\n            undefined,\n            false,\n            false\n        ];\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHQSxRQUFRd0UsT0FBTztBQUNsQyxFQUVBLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZS5qcz9mYTc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZldGNoU2VydmVyUmVzcG9uc2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyUmVzcG9uc2U7XG4gICAgfVxufSk7XG5jb25zdCBfYXBwcm91dGVyaGVhZGVycyA9IHJlcXVpcmUoXCIuLi9hcHAtcm91dGVyLWhlYWRlcnNcIik7XG5jb25zdCBfYXBwcm91dGVyID0gcmVxdWlyZShcIi4uL2FwcC1yb3V0ZXJcIik7XG5jb25zdCBfYXBwY2FsbHNlcnZlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtY2FsbC1zZXJ2ZXJcIik7XG5jb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBfaGFzaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL2hhc2hcIik7XG4vLyBAdHMtaWdub3JlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4vLyBpbXBvcnQgeyBjcmVhdGVGcm9tRmV0Y2ggfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuY29uc3QgeyBjcmVhdGVGcm9tRmV0Y2ggfSA9ICEhcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID8gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQuZWRnZVwiKSA6IHJlcXVpcmUoXCJyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50XCIpO1xuZnVuY3Rpb24gZG9NcGFOYXZpZ2F0aW9uKHVybCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICgwLCBfYXBwcm91dGVyLnVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcikodXJsKS50b1N0cmluZygpLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZVxuICAgIF07XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgZmxpZ2h0Um91dGVyU3RhdGUsIG5leHRVcmwsIGN1cnJlbnRCdWlsZElkLCBwcmVmZXRjaEtpbmQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAvLyBFbmFibGUgZmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgIFtfYXBwcm91dGVyaGVhZGVycy5SU0NfSEVBREVSXTogXCIxXCIsXG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgICAgIFtfYXBwcm91dGVyaGVhZGVycy5ORVhUX1JPVVRFUl9TVEFURV9UUkVFXTogZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGZsaWdodFJvdXRlclN0YXRlKSlcbiAgICB9O1xuICAgIC8qKlxuICAgKiBUaHJlZSBjYXNlczpcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgdW5kZWZpbmVkYCwgaXQgbWVhbnMgaXQncyBhIG5vcm1hbCBuYXZpZ2F0aW9uLCBzbyB3ZSB3YW50IHRvIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgZnVsbHlcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgZnVsbGAgLSB3ZSB3YW50IHRvIHByZWZldGNoIHRoZSB3aG9sZSBwYWdlIHNvIHNhbWUgYXMgYWJvdmVcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgYXV0b2AgLSBpZiB0aGUgcGFnZSBpcyBkeW5hbWljLCBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIHBhcnRpYWxseSwgaWYgc3RhdGljIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgZnVsbHlcbiAgICovIGlmIChwcmVmZXRjaEtpbmQgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICAgICAgaGVhZGVyc1tfYXBwcm91dGVyaGVhZGVycy5ORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdID0gXCIxXCI7XG4gICAgfVxuICAgIGlmIChuZXh0VXJsKSB7XG4gICAgICAgIGhlYWRlcnNbX2FwcHJvdXRlcmhlYWRlcnMuTkVYVF9VUkxdID0gbmV4dFVybDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRCkge1xuICAgICAgICBoZWFkZXJzW1wieC1kZXBsb3ltZW50LWlkXCJdID0gcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEO1xuICAgIH1cbiAgICBjb25zdCB1bmlxdWVDYWNoZVF1ZXJ5ID0gKDAsIF9oYXNoLmhleEhhc2gpKFtcbiAgICAgICAgaGVhZGVyc1tfYXBwcm91dGVyaGVhZGVycy5ORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdIHx8IFwiMFwiLFxuICAgICAgICBoZWFkZXJzW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVdLFxuICAgICAgICBoZWFkZXJzW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfVVJMXVxuICAgIF0uam9pbihcIixcIikpO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBfcmVzX2hlYWRlcnNfZ2V0O1xuICAgICAgICBsZXQgZmV0Y2hVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gXCJleHBvcnRcIikge1xuICAgICAgICAgICAgICAgIGlmIChmZXRjaFVybC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hVcmwucGF0aG5hbWUgKz0gXCJpbmRleC50eHRcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFVybC5wYXRobmFtZSArPSBcIi50eHRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHVuaXF1ZSBjYWNoZSBxdWVyeSB0byBhdm9pZCBjYWNoaW5nIGNvbmZsaWN0cyBvbiBDRE4gd2hpY2ggZG9uJ3QgcmVzcGVjdCB0byBWYXJ5IGhlYWRlclxuICAgICAgICBmZXRjaFVybC5zZWFyY2hQYXJhbXMuc2V0KF9hcHByb3V0ZXJoZWFkZXJzLk5FWFRfUlNDX1VOSU9OX1FVRVJZLCB1bmlxdWVDYWNoZVF1ZXJ5KTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIHtcbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIG9sZGVyIGJyb3dzZXJzLiBgc2FtZS1vcmlnaW5gIGlzIHRoZSBkZWZhdWx0IGluIG1vZGVybiBicm93c2Vycy5cbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZVVybCA9ICgwLCBfYXBwcm91dGVyLnVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcikocmVzLnVybCk7XG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybCA9IHJlcy5yZWRpcmVjdGVkID8gcmVzcG9uc2VVcmwgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IHBvc3Rwb25lZCA9ICEhcmVzLmhlYWRlcnMuZ2V0KF9hcHByb3V0ZXJoZWFkZXJzLk5FWFRfRElEX1BPU1RQT05FX0hFQURFUik7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdGlvbiA9ICEhKChfcmVzX2hlYWRlcnNfZ2V0ID0gcmVzLmhlYWRlcnMuZ2V0KFwidmFyeVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXNfaGVhZGVyc19nZXQuaW5jbHVkZXMoX2FwcHJvdXRlcmhlYWRlcnMuTkVYVF9VUkwpKTtcbiAgICAgICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZSA9PT0gX2FwcHJvdXRlcmhlYWRlcnMuUlNDX0NPTlRFTlRfVFlQRV9IRUFERVI7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gXCJleHBvcnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ZsaWdodFJlc3BvbnNlID0gY29udGVudFR5cGUuc3RhcnRzV2l0aChcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGZldGNoIHJldHVybnMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGZsaWdodCByZXNwb25zZSBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgICAgIC8vIElmIHRoZSBmZXRjaCB3YXMgbm90IDIwMCwgd2UgYWxzbyBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSB8fCAhcmVzLm9rKSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvcmlnaW5hbCBVUkwgY2FtZSB3aXRoIGEgaGFzaCwgcHJlc2VydmUgaXQgYmVmb3JlIHJlZGlyZWN0aW5nIHRvIHRoZSBuZXcgVVJMXG4gICAgICAgICAgICBpZiAodXJsLmhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVVybC5oYXNoID0gdXJsLmhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlc3BvbnNlVXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgYGZldGNoYCByZWFkYWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdW53cmFwcGVkIGJ5IGBSZWFjdC51c2VgLlxuICAgICAgICBjb25zdCBbYnVpbGRJZCwgZmxpZ2h0RGF0YV0gPSBhd2FpdCBjcmVhdGVGcm9tRmV0Y2goUHJvbWlzZS5yZXNvbHZlKHJlcyksIHtcbiAgICAgICAgICAgIGNhbGxTZXJ2ZXI6IF9hcHBjYWxsc2VydmVyLmNhbGxTZXJ2ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXJyZW50QnVpbGRJZCAhPT0gYnVpbGRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvTXBhTmF2aWdhdGlvbihyZXMudXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIHBvc3Rwb25lZCxcbiAgICAgICAgICAgIGludGVyY2VwdGlvblxuICAgICAgICBdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIFJTQyBwYXlsb2FkIGZvciBcIiArIHVybCArIFwiLiBGYWxsaW5nIGJhY2sgdG8gYnJvd3NlciBuYXZpZ2F0aW9uLlwiLCBlcnIpO1xuICAgICAgICAvLyBJZiBmZXRjaCBmYWlscyBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgICAgIC8vIFRPRE8tQVBQOiBBZGQgYSB0ZXN0IGZvciB0aGUgY2FzZSB3aGVyZSBhIENPUlMgcmVxdWVzdCBmYWlscywgZS5nLiBleHRlcm5hbCB1cmwgcmVkaXJlY3QgY29taW5nIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy80MzYwNSNpc3N1ZWNvbW1lbnQtMTQ1MTYxNzUyMSBmb3IgYSByZXByb2R1Y3Rpb24uXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB1cmwudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgXTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLXNlcnZlci1yZXNwb25zZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIl9hcHByb3V0ZXJoZWFkZXJzIiwicmVxdWlyZSIsIl9hcHByb3V0ZXIiLCJfYXBwY2FsbHNlcnZlciIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJfaGFzaCIsImNyZWF0ZUZyb21GZXRjaCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJkb01wYU5hdmlnYXRpb24iLCJ1cmwiLCJ1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIiLCJ0b1N0cmluZyIsInVuZGVmaW5lZCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsImN1cnJlbnRCdWlsZElkIiwicHJlZmV0Y2hLaW5kIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1VSTCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsInVuaXF1ZUNhY2hlUXVlcnkiLCJoZXhIYXNoIiwiam9pbiIsIl9yZXNfaGVhZGVyc19nZXQiLCJmZXRjaFVybCIsIlVSTCIsIk5PREVfRU5WIiwiX19ORVhUX0NPTkZJR19PVVRQVVQiLCJwYXRobmFtZSIsImVuZHNXaXRoIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJyZXMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwicmVzcG9uc2VVcmwiLCJjYW5vbmljYWxVcmwiLCJyZWRpcmVjdGVkIiwiY29udGVudFR5cGUiLCJwb3N0cG9uZWQiLCJORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIiLCJpbnRlcmNlcHRpb24iLCJpbmNsdWRlcyIsImlzRmxpZ2h0UmVzcG9uc2UiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsInN0YXJ0c1dpdGgiLCJvayIsImhhc2giLCJidWlsZElkIiwiZmxpZ2h0RGF0YSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2FsbFNlcnZlciIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///882\n");

/***/ }),

/***/ 121:
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"fillCacheWithNewSubTreeData\", ({\n    enumerable: true,\n    get: function() {\n        return fillCacheWithNewSubTreeData;\n    }\n}));\nconst _invalidatecachebyrouterstate = __webpack_require__(/*! ./invalidate-cache-by-router-state */ 9255);\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ 9839);\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ 4317);\nfunction fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath, prefetchEntry) {\n    const isLastEntry = flightDataPath.length <= 5;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {\n            const seedData = flightDataPath[3];\n            const rsc = seedData[2];\n            const loading = seedData[3];\n            childCacheNode = {\n                lazyData: null,\n                rsc,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                loading,\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),\n                lazyDataResolved: false\n            };\n            if (existingChildCacheNode) {\n                (0, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(childCacheNode, existingChildCacheNode, flightDataPath[2], seedData, flightDataPath[4], prefetchEntry);\n            childSegmentMap.set(cacheKey, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes),\n            lazyDataResolved: false,\n            loading: childCacheNode.loading\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2), prefetchEntry);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksQ0FBQyxPQUFPWixRQUFRcUMsT0FBTyxLQUFLLGNBQWUsT0FBT3JDLFFBQVFxQyxPQUFPLEtBQUssWUFBWXJDLFFBQVFxQyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9yQyxRQUFRcUMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3hDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXFDLE9BQU8sRUFBRSxjQUFjO1FBQUVwQyxPQUFPO0lBQUs7SUFDbkVILE9BQU95QyxNQUFNLENBQUN2QyxRQUFRcUMsT0FBTyxFQUFFckM7SUFDL0J3QyxPQUFPeEMsT0FBTyxHQUFHQSxRQUFRcUMsT0FBTztBQUNsQyxFQUVBLDREQUE0RCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLmpzPzlmZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGFcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnZhbGlkYXRlY2FjaGVieXJvdXRlcnN0YXRlID0gcmVxdWlyZShcIi4vaW52YWxpZGF0ZS1jYWNoZS1ieS1yb3V0ZXItc3RhdGVcIik7XG5jb25zdCBfZmlsbGxhenlpdGVtc3RpbGxsZWFmd2l0aGhlYWQgPSByZXF1aXJlKFwiLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuZnVuY3Rpb24gZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCBmbGlnaHREYXRhUGF0aCwgcHJlZmV0Y2hFbnRyeSkge1xuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gZmxpZ2h0RGF0YVBhdGgubGVuZ3RoIDw9IDU7XG4gICAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgY29uc3QgY2FjaGVLZXkgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShzZWdtZW50KTtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgIGxldCBjaGlsZENhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFjaGlsZENhY2hlTm9kZS5sYXp5RGF0YSB8fCBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc2VlZERhdGEgPSBmbGlnaHREYXRhUGF0aFszXTtcbiAgICAgICAgICAgIGNvbnN0IHJzYyA9IHNlZWREYXRhWzJdO1xuICAgICAgICAgICAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzNdO1xuICAgICAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcnNjLFxuICAgICAgICAgICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICAgICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNlZ21lbnRzIG90aGVyIHRoYW4gdGhlIG9uZSB3ZSBnb3QgZGF0YSBmb3IgYXJlIHByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA/IG5ldyBNYXAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcykgOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgbGF6eURhdGFSZXNvbHZlZDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgICgwLCBfaW52YWxpZGF0ZWNhY2hlYnlyb3V0ZXJzdGF0ZS5pbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlKShjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGhbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIF9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZC5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCkoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoWzJdLCBzZWVkRGF0YSwgZmxpZ2h0RGF0YVBhdGhbNF0sIHByZWZldGNoRW50cnkpO1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgbGF6eURhdGE6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICAgICAgICBwcmVmZXRjaFJzYzogY2hpbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICAgICAgICBoZWFkOiBjaGlsZENhY2hlTm9kZS5oZWFkLFxuICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcyksXG4gICAgICAgICAgICBsYXp5RGF0YVJlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGxvYWRpbmc6IGNoaWxkQ2FjaGVOb2RlLmxvYWRpbmdcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgIH1cbiAgICBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoLnNsaWNlKDIpLCBwcmVmZXRjaEVudHJ5KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsbC1jYWNoZS13aXRoLW5ldy1zdWJ0cmVlLWRhdGEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSIsIl9pbnZhbGlkYXRlY2FjaGVieXJvdXRlcnN0YXRlIiwicmVxdWlyZSIsIl9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZCIsIl9jcmVhdGVyb3V0ZXJjYWNoZWtleSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodERhdGFQYXRoIiwicHJlZmV0Y2hFbnRyeSIsImlzTGFzdEVudHJ5IiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZUtleSIsInNlZ21lbnQiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAiLCJwYXJhbGxlbFJvdXRlcyIsImNoaWxkU2VnbWVudE1hcCIsIk1hcCIsInNldCIsImV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUiLCJjaGlsZENhY2hlTm9kZSIsImxhenlEYXRhIiwic2VlZERhdGEiLCJyc2MiLCJsb2FkaW5nIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwibGF6eURhdGFSZXNvbHZlZCIsImludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInNsaWNlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///121\n");

/***/ }),

/***/ 9839:
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js ***!
  \********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"fillLazyItemsTillLeafWithHead\", ({\n    enumerable: true,\n    get: function() {\n        return fillLazyItemsTillLeafWithHead;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ 4317);\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ 744);\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n        // state tree. Ideally, they would always be the same shape, but because of\n        // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n        // partial tree. That's why this node is sometimes null. Once PPR lands,\n        // loading.js will no longer have special behavior and we can traverse the\n        // data tree instead.\n        //\n        // We should also consider merging the router state tree and the data tree\n        // in the response format, so that we don't have to send the keys twice.\n        // Then the client can convert them into separate representations.\n        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined ? cacheNodeSeedData[1][key] : null;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === \"auto\" && prefetchEntry.status === _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);\n                let newCacheNode;\n                if (parallelSeedData !== null) {\n                    // New data was sent from the server.\n                    const seedNode = parallelSeedData[2];\n                    const loading = parallelSeedData[3];\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: seedNode,\n                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n                        // this path during a navigation, but until PPR is fully implemented\n                        // yet it's possible the existing node does have a non-null\n                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n                        // old behavior â€” no PPR value.\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        loading,\n                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),\n                        lazyDataResolved: false\n                    };\n                } else if (hasReusablePrefetch && existingCacheNode) {\n                    // No new data was sent from the server, but the existing cache node\n                    // was prefetched, so we should reuse that.\n                    newCacheNode = {\n                        lazyData: existingCacheNode.lazyData,\n                        rsc: existingCacheNode.rsc,\n                        // This is a PPR-only field. Unlike the previous branch, since we're\n                        // just cloning the existing cache node, we might as well keep the\n                        // PPR value, if it exists.\n                        prefetchRsc: existingCacheNode.prefetchRsc,\n                        head: existingCacheNode.head,\n                        prefetchHead: existingCacheNode.prefetchHead,\n                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n                        lazyDataResolved: existingCacheNode.lazyDataResolved,\n                        loading: existingCacheNode.loading\n                    };\n                } else {\n                    // No data available for this node. This will trigger a lazy fetch\n                    // during render.\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: null,\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),\n                        lazyDataResolved: false,\n                        loading: null\n                    };\n                }\n                // Overrides the cache key with the new cache node.\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                // Traverse deeper to apply the head / fill lazy items till the head.\n                fillLazyItemsTillLeafWithHead(newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        let newCacheNode;\n        if (parallelSeedData !== null) {\n            // New data was sent from the server.\n            const seedNode = parallelSeedData[2];\n            const loading = parallelSeedData[3];\n            newCacheNode = {\n                lazyData: null,\n                rsc: seedNode,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading\n            };\n        } else {\n            // No data available for this node. This will trigger a lazy fetch\n            // during render.\n            newCacheNode = {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading: null\n            };\n        }\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixHQUFHLENBQUNjO1FBQzNELElBQUkwQix3QkFBd0I7WUFDeEJBLHVCQUF1QkQsR0FBRyxDQUFDdEIsVUFBVWM7UUFDekMsT0FBTztZQUNIMUIsU0FBU2lCLGNBQWMsQ0FBQ2lCLEdBQUcsQ0FBQ3pCLEtBQUssSUFBSWUsSUFBSTtnQkFDckM7b0JBQ0laO29CQUNBYztpQkFDSDthQUNKO1FBQ0w7UUFDQTlCLDhCQUE4QjhCLGNBQWNYLFdBQVdMLG9CQUFvQkksa0JBQWtCVixNQUFNQztJQUN2RztBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9iLFFBQVE0QyxPQUFPLEtBQUssY0FBZSxPQUFPNUMsUUFBUTRDLE9BQU8sS0FBSyxZQUFZNUMsUUFBUTRDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzVDLFFBQVE0QyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLL0MsT0FBT0MsY0FBYyxDQUFDQyxRQUFRNEMsT0FBTyxFQUFFLGNBQWM7UUFBRTNDLE9BQU87SUFBSztJQUNuRUgsT0FBT2dELE1BQU0sQ0FBQzlDLFFBQVE0QyxPQUFPLEVBQUU1QztJQUMvQitDLE9BQU8vQyxPQUFPLEdBQUdBLFFBQVE0QyxPQUFPO0FBQ2xDLEVBRUEsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQuanM/NmM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZDtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuZnVuY3Rpb24gZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHJvdXRlclN0YXRlLCBjYWNoZU5vZGVTZWVkRGF0YSwgaGVhZCwgcHJlZmV0Y2hFbnRyeSkge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBPYmplY3Qua2V5cyhyb3V0ZXJTdGF0ZVsxXSkubGVuZ3RoID09PSAwO1xuICAgIGlmIChpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIG5ld0NhY2hlLmhlYWQgPSBoZWFkO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWdtZW50IHRoYXQgd2UgZ290IGRhdGEgZm9yIHNvIHRoYXQgaXQgaXMgZmlsbGVkIGluIGR1cmluZyByZW5kZXJpbmcgb2YgcnNjLlxuICAgIGZvcihjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pe1xuICAgICAgICBjb25zdCBwYXJhbGxlbFJvdXRlU3RhdGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldO1xuICAgICAgICBjb25zdCBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSA9IHBhcmFsbGVsUm91dGVTdGF0ZVswXTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSk7XG4gICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCB0cmF2ZXJzZSB0aGUgY2FjaGVOb2RlU2VlZERhdGEgdHJlZSBpbnN0ZWFkIG9mIHRoZSByb3V0ZXJcbiAgICAgICAgLy8gc3RhdGUgdHJlZS4gSWRlYWxseSwgdGhleSB3b3VsZCBhbHdheXMgYmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBiZWNhdXNlIG9mXG4gICAgICAgIC8vIHRoZSBsb2FkaW5nLmpzIHBhdHRlcm4sIGNhY2hlTm9kZVNlZWREYXRhIHNvbWV0aW1lcyBvbmx5IHJlcHJlc2VudHMgYVxuICAgICAgICAvLyBwYXJ0aWFsIHRyZWUuIFRoYXQncyB3aHkgdGhpcyBub2RlIGlzIHNvbWV0aW1lcyBudWxsLiBPbmNlIFBQUiBsYW5kcyxcbiAgICAgICAgLy8gbG9hZGluZy5qcyB3aWxsIG5vIGxvbmdlciBoYXZlIHNwZWNpYWwgYmVoYXZpb3IgYW5kIHdlIGNhbiB0cmF2ZXJzZSB0aGVcbiAgICAgICAgLy8gZGF0YSB0cmVlIGluc3RlYWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHNob3VsZCBhbHNvIGNvbnNpZGVyIG1lcmdpbmcgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIGFuZCB0aGUgZGF0YSB0cmVlXG4gICAgICAgIC8vIGluIHRoZSByZXNwb25zZSBmb3JtYXQsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBzZW5kIHRoZSBrZXlzIHR3aWNlLlxuICAgICAgICAvLyBUaGVuIHRoZSBjbGllbnQgY2FuIGNvbnZlcnQgdGhlbSBpbnRvIHNlcGFyYXRlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgICAgY29uc3QgcGFyYWxsZWxTZWVkRGF0YSA9IGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsICYmIGNhY2hlTm9kZVNlZWREYXRhWzFdW2tleV0gIT09IHVuZGVmaW5lZCA/IGNhY2hlTm9kZVNlZWREYXRhWzFdW2tleV0gOiBudWxsO1xuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1JldXNhYmxlUHJlZmV0Y2ggPSAocHJlZmV0Y2hFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogcHJlZmV0Y2hFbnRyeS5raW5kKSA9PT0gXCJhdXRvXCIgJiYgcHJlZmV0Y2hFbnRyeS5zdGF0dXMgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnJldXNhYmxlO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlID0gbmV3IE1hcChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0NhY2hlTm9kZSA9IHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2FjaGVOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbGxlbFNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBkYXRhIHdhcyBzZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VlZE5vZGUgPSBwYXJhbGxlbFNlZWREYXRhWzJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gcGFyYWxsZWxTZWVkRGF0YVszXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByc2M6IHNlZWROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFBQUi1vbmx5IGZpZWxkLiBXaGVuIFBQUiBpcyBlbmFibGVkLCB3ZSBzaG91bGRuJ3QgaGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHBhdGggZHVyaW5nIGEgbmF2aWdhdGlvbiwgYnV0IHVudGlsIFBQUiBpcyBmdWxseSBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geWV0IGl0J3MgcG9zc2libGUgdGhlIGV4aXN0aW5nIG5vZGUgZG9lcyBoYXZlIGEgbm9uLW51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBwcmVmZXRjaFJzY2AuIEFzIGFuIGluY3JlbWVudGFsIHN0ZXAsIHdlJ2xsIGp1c3QgZGUtb3B0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIOKAlCBubyBQUFIgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNSZXVzYWJsZVByZWZldGNoICYmIGV4aXN0aW5nQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIG5ldyBkYXRhIHdhcyBzZW50IGZyb20gdGhlIHNlcnZlciwgYnV0IHRoZSBleGlzdGluZyBjYWNoZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcyBwcmVmZXRjaGVkLCBzbyB3ZSBzaG91bGQgcmV1c2UgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF6eURhdGE6IGV4aXN0aW5nQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnNjOiBleGlzdGluZ0NhY2hlTm9kZS5yc2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgUFBSLW9ubHkgZmllbGQuIFVubGlrZSB0aGUgcHJldmlvdXMgYnJhbmNoLCBzaW5jZSB3ZSdyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBjbG9uaW5nIHRoZSBleGlzdGluZyBjYWNoZSBub2RlLCB3ZSBtaWdodCBhcyB3ZWxsIGtlZXAgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgdmFsdWUsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoUnNjOiBleGlzdGluZ0NhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQ6IGV4aXN0aW5nQ2FjaGVOb2RlLmhlYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IGV4aXN0aW5nQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGV4aXN0aW5nQ2FjaGVOb2RlLmxhenlEYXRhUmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBleGlzdGluZ0NhY2hlTm9kZS5sb2FkaW5nXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gZGF0YSBhdmFpbGFibGUgZm9yIHRoaXMgbm9kZS4gVGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1cmluZyByZW5kZXIuXG4gICAgICAgICAgICAgICAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgdGhlIGNhY2hlIGtleSB3aXRoIHRoZSBuZXcgY2FjaGUgbm9kZS5cbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLnNldChjYWNoZUtleSwgbmV3Q2FjaGVOb2RlKTtcbiAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBkZWVwZXIgdG8gYXBwbHkgdGhlIGhlYWQgLyBmaWxsIGxhenkgaXRlbXMgdGlsbCB0aGUgaGVhZC5cbiAgICAgICAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChuZXdDYWNoZU5vZGUsIGV4aXN0aW5nQ2FjaGVOb2RlLCBwYXJhbGxlbFJvdXRlU3RhdGUsIHBhcmFsbGVsU2VlZERhdGEgPyBwYXJhbGxlbFNlZWREYXRhIDogbnVsbCwgaGVhZCwgcHJlZmV0Y2hFbnRyeSk7XG4gICAgICAgICAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0NhY2hlTm9kZTtcbiAgICAgICAgaWYgKHBhcmFsbGVsU2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE5ldyBkYXRhIHdhcyBzZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICAgIGNvbnN0IHNlZWROb2RlID0gcGFyYWxsZWxTZWVkRGF0YVsyXTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSBwYXJhbGxlbFNlZWREYXRhWzNdO1xuICAgICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHJzYzogc2VlZE5vZGUsXG4gICAgICAgICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICBsYXp5RGF0YVJlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSBhdmFpbGFibGUgZm9yIHRoaXMgbm9kZS4gVGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoXG4gICAgICAgICAgICAvLyBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlcykge1xuICAgICAgICAgICAgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcy5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBuZXcgTWFwKFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICBuZXdDYWNoZU5vZGVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGVOb2RlLCB1bmRlZmluZWQsIHBhcmFsbGVsUm91dGVTdGF0ZSwgcGFyYWxsZWxTZWVkRGF0YSwgaGVhZCwgcHJlZmV0Y2hFbnRyeSk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJyZXF1aXJlIiwiX3JvdXRlcnJlZHVjZXJ0eXBlcyIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJoZWFkIiwicHJlZmV0Y2hFbnRyeSIsImlzTGFzdFNlZ21lbnQiLCJrZXlzIiwibGVuZ3RoIiwia2V5IiwicGFyYWxsZWxSb3V0ZVN0YXRlIiwic2VnbWVudEZvclBhcmFsbGVsUm91dGUiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwicGFyYWxsZWxTZWVkRGF0YSIsInVuZGVmaW5lZCIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImhhc1JldXNhYmxlUHJlZmV0Y2giLCJraW5kIiwic3RhdHVzIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwicmV1c2FibGUiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZXhpc3RpbmdDYWNoZU5vZGUiLCJuZXdDYWNoZU5vZGUiLCJzZWVkTm9kZSIsImxvYWRpbmciLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwicHJlZmV0Y2hIZWFkIiwibGF6eURhdGFSZXNvbHZlZCIsInNldCIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9839\n");

/***/ }),

/***/ 7138:
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/handle-mutable.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleMutable\", ({\n    enumerable: true,\n    get: function() {\n        return handleMutable;\n    }\n}));\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ 9314);\nfunction isNotUndefined(value) {\n    return typeof value !== \"undefined\";\n}\nfunction handleMutable(state, mutable) {\n    var _mutable_canonicalUrl;\n    var _mutable_shouldScroll;\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = (_mutable_shouldScroll = mutable.shouldScroll) != null ? _mutable_shouldScroll : true;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    var _mutable_scrollableSegments;\n    return {\n        buildId: state.buildId,\n        // Set href.\n        canonicalUrl: isNotUndefined(mutable.canonicalUrl) ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable == null ? void 0 : mutable.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: !!mutable.hashFragment && state.canonicalUrl.split(\"#\", 1)[0] === ((_mutable_canonicalUrl = mutable.canonicalUrl) == null ? void 0 : _mutable_canonicalUrl.split(\"#\", 1)[0]),\n            hashFragment: shouldScroll ? mutable.hashFragment && mutable.hashFragment !== \"\" ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? (_mutable_scrollableSegments = mutable == null ? void 0 : mutable.scrollableSegments) != null ? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-mutable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEzOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyxrQ0FBd0I7QUFDNUQsU0FBU0MsZUFBZU4sS0FBSztJQUN6QixPQUFPLE9BQU9BLFVBQVU7QUFDNUI7QUFDQSxTQUFTRyxjQUFjSSxLQUFLLEVBQUVDLE9BQU87SUFDakMsSUFBSUM7SUFDSixJQUFJQztJQUNKLDBEQUEwRDtJQUMxRCxNQUFNQyxlQUFlLENBQUNELHdCQUF3QkYsUUFBUUcsWUFBWSxLQUFLLE9BQU9ELHdCQUF3QjtJQUN0RyxJQUFJRSxVQUFVTCxNQUFNSyxPQUFPO0lBQzNCLElBQUlOLGVBQWVFLFFBQVFLLFdBQVcsR0FBRztRQUNyQyxzRUFBc0U7UUFDdEUsTUFBTUMsY0FBYyxDQUFDLEdBQUdWLG9CQUFvQlcsa0JBQWtCLEVBQUVSLE1BQU1TLElBQUksRUFBRVIsUUFBUUssV0FBVztRQUMvRixJQUFJQyxhQUFhO1lBQ2IscURBQXFEO1lBQ3JERixVQUFVRTtRQUNkLE9BQU8sSUFBSSxDQUFDRixTQUFTO1lBQ2pCLDZIQUE2SDtZQUM3SEEsVUFBVUwsTUFBTVUsWUFBWTtRQUNoQztJQUNKLDBFQUEwRTtJQUMxRTtJQUNBLElBQUlDO0lBQ0osT0FBTztRQUNIQyxTQUFTWixNQUFNWSxPQUFPO1FBQ3RCLFlBQVk7UUFDWkYsY0FBY1gsZUFBZUUsUUFBUVMsWUFBWSxJQUFJVCxRQUFRUyxZQUFZLEtBQUtWLE1BQU1VLFlBQVksR0FBR1YsTUFBTVUsWUFBWSxHQUFHVCxRQUFRUyxZQUFZLEdBQUdWLE1BQU1VLFlBQVk7UUFDaktHLFNBQVM7WUFDTEMsYUFBYWYsZUFBZUUsUUFBUWEsV0FBVyxJQUFJYixRQUFRYSxXQUFXLEdBQUdkLE1BQU1hLE9BQU8sQ0FBQ0MsV0FBVztZQUNsR0MsZUFBZWhCLGVBQWVFLFFBQVFjLGFBQWEsSUFBSWQsUUFBUWMsYUFBYSxHQUFHZixNQUFNYSxPQUFPLENBQUNFLGFBQWE7WUFDMUdDLDRCQUE0QmpCLGVBQWVFLFFBQVFlLDBCQUEwQixJQUFJZixRQUFRZSwwQkFBMEIsR0FBR2hCLE1BQU1hLE9BQU8sQ0FBQ0csMEJBQTBCO1FBQ2xLO1FBQ0Esa0VBQWtFO1FBQ2xFQyxtQkFBbUI7WUFDZkMsT0FBT2QsZUFBZUwsZUFBZUUsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUWtCLGtCQUFrQixJQUFJLE9BQU9uQixNQUFNaUIsaUJBQWlCLENBQUNDLEtBQUssR0FBRztZQUNySUUsZ0JBQWdCLENBQUMsQ0FBQ25CLFFBQVFvQixZQUFZLElBQUlyQixNQUFNVSxZQUFZLENBQUNZLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQU0sRUFBQ3BCLHdCQUF3QkQsUUFBUVMsWUFBWSxLQUFLLE9BQU8sS0FBSyxJQUFJUixzQkFBc0JvQixLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUMzTEQsY0FBY2pCLGVBQ2RILFFBQVFvQixZQUFZLElBQUlwQixRQUFRb0IsWUFBWSxLQUFLLEtBQUtFLG1CQUFtQnRCLFFBQVFvQixZQUFZLENBQUNHLEtBQUssQ0FBQyxNQUFNeEIsTUFBTWlCLGlCQUFpQixDQUFDSSxZQUFZLEdBQUc7WUFDakpJLGNBQWNyQixlQUFlLENBQUNPLDhCQUE4QlYsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUWtCLGtCQUFrQixLQUFLLE9BQU9SLDhCQUE4QlgsTUFBTWlCLGlCQUFpQixDQUFDUSxZQUFZLEdBQUcsRUFBRTtRQUN4TTtRQUNBLGVBQWU7UUFDZkMsT0FBT3pCLFFBQVF5QixLQUFLLEdBQUd6QixRQUFReUIsS0FBSyxHQUFHMUIsTUFBTTBCLEtBQUs7UUFDbERDLGVBQWUxQixRQUFRMEIsYUFBYSxHQUFHMUIsUUFBUTBCLGFBQWEsR0FBRzNCLE1BQU0yQixhQUFhO1FBQ2xGLDhCQUE4QjtRQUM5QmxCLE1BQU1WLGVBQWVFLFFBQVFLLFdBQVcsSUFBSUwsUUFBUUssV0FBVyxHQUFHTixNQUFNUyxJQUFJO1FBQzVFSjtJQUNKO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2IsUUFBUW9DLE9BQU8sS0FBSyxjQUFlLE9BQU9wQyxRQUFRb0MsT0FBTyxLQUFLLFlBQVlwQyxRQUFRb0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPcEMsUUFBUW9DLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt2QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFvQyxPQUFPLEVBQUUsY0FBYztRQUFFbkMsT0FBTztJQUFLO0lBQ25FSCxPQUFPd0MsTUFBTSxDQUFDdEMsUUFBUW9DLE9BQU8sRUFBRXBDO0lBQy9CdUMsT0FBT3ZDLE9BQU8sR0FBR0EsUUFBUW9DLE9BQU87QUFDbEMsRUFFQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9oYW5kbGUtbXV0YWJsZS5qcz80MmYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFuZGxlTXV0YWJsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZTtcbiAgICB9XG59KTtcbmNvbnN0IF9jb21wdXRlY2hhbmdlZHBhdGggPSByZXF1aXJlKFwiLi9jb21wdXRlLWNoYW5nZWQtcGF0aFwiKTtcbmZ1bmN0aW9uIGlzTm90VW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpIHtcbiAgICB2YXIgX211dGFibGVfY2Fub25pY2FsVXJsO1xuICAgIHZhciBfbXV0YWJsZV9zaG91bGRTY3JvbGw7XG4gICAgLy8gc2hvdWxkU2Nyb2xsIGlzIHRydWUgYnkgZGVmYXVsdCwgY2FuIG92ZXJyaWRlIHRvIGZhbHNlLlxuICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfbXV0YWJsZV9zaG91bGRTY3JvbGwgPSBtdXRhYmxlLnNob3VsZFNjcm9sbCkgIT0gbnVsbCA/IF9tdXRhYmxlX3Nob3VsZFNjcm9sbCA6IHRydWU7XG4gICAgbGV0IG5leHRVcmwgPSBzdGF0ZS5uZXh0VXJsO1xuICAgIGlmIChpc05vdFVuZGVmaW5lZChtdXRhYmxlLnBhdGNoZWRUcmVlKSkge1xuICAgICAgICAvLyBJZiB3ZSByZWNlaXZlZCBhIHBhdGNoZWQgdHJlZSwgd2UgbmVlZCB0byBjb21wdXRlIHRoZSBjaGFuZ2VkIHBhdGguXG4gICAgICAgIGNvbnN0IGNoYW5nZWRQYXRoID0gKDAsIF9jb21wdXRlY2hhbmdlZHBhdGguY29tcHV0ZUNoYW5nZWRQYXRoKShzdGF0ZS50cmVlLCBtdXRhYmxlLnBhdGNoZWRUcmVlKTtcbiAgICAgICAgaWYgKGNoYW5nZWRQYXRoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJlZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbmV4dFVybFxuICAgICAgICAgICAgbmV4dFVybCA9IGNoYW5nZWRQYXRoO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXh0VXJsKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgdHJlZSBlbmRzIHVwIGJlaW5nIHRoZSBzYW1lIChpZSwgbm8gY2hhbmdlZCBwYXRoKSwgYW5kIHdlIGRvbid0IGhhdmUgYSBuZXh0VXJsLCB0aGVuIHdlIHNob3VsZCB1c2UgdGhlIGNhbm9uaWNhbFVybFxuICAgICAgICAgICAgbmV4dFVybCA9IHN0YXRlLmNhbm9uaWNhbFVybDtcbiAgICAgICAgfVxuICAgIC8vIG90aGVyd2lzZSB0aGlzIHdpbGwgYmUgYSBuby1vcCBhbmQgY29udGludWUgdG8gdXNlIHRoZSBleGlzdGluZyBuZXh0VXJsXG4gICAgfVxuICAgIHZhciBfbXV0YWJsZV9zY3JvbGxhYmxlU2VnbWVudHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVpbGRJZDogc3RhdGUuYnVpbGRJZCxcbiAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgIGNhbm9uaWNhbFVybDogaXNOb3RVbmRlZmluZWQobXV0YWJsZS5jYW5vbmljYWxVcmwpID8gbXV0YWJsZS5jYW5vbmljYWxVcmwgPT09IHN0YXRlLmNhbm9uaWNhbFVybCA/IHN0YXRlLmNhbm9uaWNhbFVybCA6IG11dGFibGUuY2Fub25pY2FsVXJsIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICBwZW5kaW5nUHVzaDogaXNOb3RVbmRlZmluZWQobXV0YWJsZS5wZW5kaW5nUHVzaCkgPyBtdXRhYmxlLnBlbmRpbmdQdXNoIDogc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCxcbiAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGlzTm90VW5kZWZpbmVkKG11dGFibGUubXBhTmF2aWdhdGlvbikgPyBtdXRhYmxlLm1wYU5hdmlnYXRpb24gOiBzdGF0ZS5wdXNoUmVmLm1wYU5hdmlnYXRpb24sXG4gICAgICAgICAgICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZTogaXNOb3RVbmRlZmluZWQobXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSkgPyBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIDogc3RhdGUucHVzaFJlZi5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZVxuICAgICAgICB9LFxuICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgIGFwcGx5OiBzaG91bGRTY3JvbGwgPyBpc05vdFVuZGVmaW5lZChtdXRhYmxlID09IG51bGwgPyB2b2lkIDAgOiBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cykgPyB0cnVlIDogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgOiBmYWxzZSxcbiAgICAgICAgICAgIG9ubHlIYXNoQ2hhbmdlOiAhIW11dGFibGUuaGFzaEZyYWdtZW50ICYmIHN0YXRlLmNhbm9uaWNhbFVybC5zcGxpdChcIiNcIiwgMSlbMF0gPT09ICgoX211dGFibGVfY2Fub25pY2FsVXJsID0gbXV0YWJsZS5jYW5vbmljYWxVcmwpID09IG51bGwgPyB2b2lkIDAgOiBfbXV0YWJsZV9jYW5vbmljYWxVcmwuc3BsaXQoXCIjXCIsIDEpWzBdKSxcbiAgICAgICAgICAgIGhhc2hGcmFnbWVudDogc2hvdWxkU2Nyb2xsID8gLy8gI3RvcCBpcyBoYW5kbGVkIGluIGxheW91dC1yb3V0ZXIuXG4gICAgICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCAmJiBtdXRhYmxlLmhhc2hGcmFnbWVudCAhPT0gXCJcIiA/IGRlY29kZVVSSUNvbXBvbmVudChtdXRhYmxlLmhhc2hGcmFnbWVudC5zbGljZSgxKSkgOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZi5oYXNoRnJhZ21lbnQgOiBudWxsLFxuICAgICAgICAgICAgc2VnbWVudFBhdGhzOiBzaG91bGRTY3JvbGwgPyAoX211dGFibGVfc2Nyb2xsYWJsZVNlZ21lbnRzID0gbXV0YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMpICE9IG51bGwgPyBfbXV0YWJsZV9zY3JvbGxhYmxlU2VnbWVudHMgOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZi5zZWdtZW50UGF0aHMgOiBbXVxuICAgICAgICB9LFxuICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgY2FjaGU6IG11dGFibGUuY2FjaGUgPyBtdXRhYmxlLmNhY2hlIDogc3RhdGUuY2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGU6IG11dGFibGUucHJlZmV0Y2hDYWNoZSA/IG11dGFibGUucHJlZmV0Y2hDYWNoZSA6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICB0cmVlOiBpc05vdFVuZGVmaW5lZChtdXRhYmxlLnBhdGNoZWRUcmVlKSA/IG11dGFibGUucGF0Y2hlZFRyZWUgOiBzdGF0ZS50cmVlLFxuICAgICAgICBuZXh0VXJsXG4gICAgfTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFuZGxlLW11dGFibGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImhhbmRsZU11dGFibGUiLCJfY29tcHV0ZWNoYW5nZWRwYXRoIiwicmVxdWlyZSIsImlzTm90VW5kZWZpbmVkIiwic3RhdGUiLCJtdXRhYmxlIiwiX211dGFibGVfY2Fub25pY2FsVXJsIiwiX211dGFibGVfc2hvdWxkU2Nyb2xsIiwic2hvdWxkU2Nyb2xsIiwibmV4dFVybCIsInBhdGNoZWRUcmVlIiwiY2hhbmdlZFBhdGgiLCJjb21wdXRlQ2hhbmdlZFBhdGgiLCJ0cmVlIiwiY2Fub25pY2FsVXJsIiwiX211dGFibGVfc2Nyb2xsYWJsZVNlZ21lbnRzIiwiYnVpbGRJZCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiYXBwbHkiLCJzY3JvbGxhYmxlU2VnbWVudHMiLCJvbmx5SGFzaENoYW5nZSIsImhhc2hGcmFnbWVudCIsInNwbGl0IiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2xpY2UiLCJzZWdtZW50UGF0aHMiLCJjYWNoZSIsInByZWZldGNoQ2FjaGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7138\n");

/***/ }),

/***/ 1514:
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSegmentMismatch\", ({\n    enumerable: true,\n    get: function() {\n        return handleSegmentMismatch;\n    }\n}));\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ 7447);\nfunction handleSegmentMismatch(state, action, treePatch) {\n    if (true) {\n        console.warn(\"Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n\" + \"Reason: Segment mismatch\\n\" + (\"Last Action: \" + action.type + \"\\n\\n\") + (\"Current Tree: \" + JSON.stringify(state.tree) + \"\\n\\n\") + (\"Tree Patch Payload: \" + JSON.stringify(treePatch)));\n    }\n    return (0, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, true);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-segment-mismatch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUxNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgseURBQXdEO0lBQ3BESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsbUJBQW1CQyxtQkFBT0EsQ0FBQyx1Q0FBNkI7QUFDOUQsU0FBU0Ysc0JBQXNCRyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsU0FBUztJQUNuRCxJQUFJQyxJQUFzQyxFQUFFO1FBQ3hDRyxRQUFRQyxJQUFJLENBQUMsc0pBQXNKLCtCQUFnQyxtQkFBa0JOLE9BQU9PLElBQUksR0FBRyxNQUFLLElBQU0sb0JBQW1CQyxLQUFLQyxTQUFTLENBQUNWLE1BQU1XLElBQUksSUFBSSxNQUFLLElBQU0sMEJBQXlCRixLQUFLQyxTQUFTLENBQUNSLFVBQVM7SUFDOVY7SUFDQSxPQUFPLENBQUMsR0FBR0osaUJBQWlCYyxpQkFBaUIsRUFBRVosT0FBTyxDQUFDLEdBQUdBLE1BQU1hLFlBQVksRUFBRTtBQUNsRjtBQUVBLElBQUksQ0FBQyxPQUFPcEIsUUFBUXFCLE9BQU8sS0FBSyxjQUFlLE9BQU9yQixRQUFRcUIsT0FBTyxLQUFLLFlBQVlyQixRQUFRcUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPckIsUUFBUXFCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt4QixPQUFPQyxjQUFjLENBQUNDLFFBQVFxQixPQUFPLEVBQUUsY0FBYztRQUFFcEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPeUIsTUFBTSxDQUFDdkIsUUFBUXFCLE9BQU8sRUFBRXJCO0lBQy9Cd0IsT0FBT3hCLE9BQU8sR0FBR0EsUUFBUXFCLE9BQU87QUFDbEMsRUFFQSxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9oYW5kbGUtc2VnbWVudC1taXNtYXRjaC5qcz9hZDIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFuZGxlU2VnbWVudE1pc21hdGNoXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTZWdtZW50TWlzbWF0Y2g7XG4gICAgfVxufSk7XG5jb25zdCBfbmF2aWdhdGVyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlclwiKTtcbmZ1bmN0aW9uIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJQZXJmb3JtaW5nIGhhcmQgbmF2aWdhdGlvbiBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gZXhwZXJpZW5jZWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvci4gSWYgdGhpcyBrZWVwcyBvY2N1cnJpbmcsIHBsZWFzZSBmaWxlIGEgTmV4dC5qcyBpc3N1ZS5cXG5cXG5cIiArIFwiUmVhc29uOiBTZWdtZW50IG1pc21hdGNoXFxuXCIgKyAoXCJMYXN0IEFjdGlvbjogXCIgKyBhY3Rpb24udHlwZSArIFwiXFxuXFxuXCIpICsgKFwiQ3VycmVudCBUcmVlOiBcIiArIEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpICsgXCJcXG5cXG5cIikgKyAoXCJUcmVlIFBhdGNoIFBheWxvYWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodHJlZVBhdGNoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCB7fSwgc3RhdGUuY2Fub25pY2FsVXJsLCB0cnVlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsIl9uYXZpZ2F0ZXJlZHVjZXIiLCJyZXF1aXJlIiwic3RhdGUiLCJhY3Rpb24iLCJ0cmVlUGF0Y2giLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwid2FybiIsInR5cGUiLCJKU09OIiwic3RyaW5naWZ5IiwidHJlZSIsImhhbmRsZUV4dGVybmFsVXJsIiwiY2Fub25pY2FsVXJsIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1514\n");

/***/ }),

/***/ 7273:
/*!**************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js ***!
  \**************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"invalidateCacheBelowFlightSegmentPath\", ({\n    enumerable: true,\n    get: function() {\n        return invalidateCacheBelowFlightSegmentPath;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ 4317);\nfunction invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(cacheKey);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes),\n            lazyDataResolved: childCacheNode.lazyDataResolved\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI3My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgseUVBQXdFO0lBQ3BFSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyxxQ0FBMkI7QUFDakUsU0FBU0Ysc0NBQXNDRyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsaUJBQWlCO0lBQ3JGLE1BQU1DLGNBQWNELGtCQUFrQkUsTUFBTSxJQUFJO0lBQ2hELE1BQU0sQ0FBQ0Msa0JBQWtCQyxRQUFRLEdBQUdKO0lBQ3BDLE1BQU1LLFdBQVcsQ0FBQyxHQUFHVCxzQkFBc0JVLG9CQUFvQixFQUFFRjtJQUNqRSxNQUFNRywwQkFBMEJSLGNBQWNTLGNBQWMsQ0FBQ2QsR0FBRyxDQUFDUztJQUNqRSxJQUFJLENBQUNJLHlCQUF5QjtRQUMxQiw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0o7SUFDQSxJQUFJRSxrQkFBa0JYLFNBQVNVLGNBQWMsQ0FBQ2QsR0FBRyxDQUFDUztJQUNsRCxJQUFJLENBQUNNLG1CQUFtQkEsb0JBQW9CRix5QkFBeUI7UUFDakVFLGtCQUFrQixJQUFJQyxJQUFJSDtRQUMxQlQsU0FBU1UsY0FBYyxDQUFDRyxHQUFHLENBQUNSLGtCQUFrQk07SUFDbEQ7SUFDQSxpREFBaUQ7SUFDakQsSUFBSVIsYUFBYTtRQUNiUSxnQkFBZ0JHLE1BQU0sQ0FBQ1A7UUFDdkI7SUFDSjtJQUNBLE1BQU1RLHlCQUF5Qk4sd0JBQXdCYixHQUFHLENBQUNXO0lBQzNELElBQUlTLGlCQUFpQkwsZ0JBQWdCZixHQUFHLENBQUNXO0lBQ3pDLElBQUksQ0FBQ1Msa0JBQWtCLENBQUNELHdCQUF3QjtRQUM1Qyw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0o7SUFDQSxJQUFJQyxtQkFBbUJELHdCQUF3QjtRQUMzQ0MsaUJBQWlCO1lBQ2JDLFVBQVVELGVBQWVDLFFBQVE7WUFDakNDLEtBQUtGLGVBQWVFLEdBQUc7WUFDdkJDLGFBQWFILGVBQWVHLFdBQVc7WUFDdkNDLE1BQU1KLGVBQWVJLElBQUk7WUFDekJDLGNBQWNMLGVBQWVLLFlBQVk7WUFDekNYLGdCQUFnQixJQUFJRSxJQUFJSSxlQUFlTixjQUFjO1lBQ3JEWSxrQkFBa0JOLGVBQWVNLGdCQUFnQjtRQUNyRDtRQUNBWCxnQkFBZ0JFLEdBQUcsQ0FBQ04sVUFBVVM7SUFDbEM7SUFDQW5CLHNDQUFzQ21CLGdCQUFnQkQsd0JBQXdCYixrQkFBa0JxQixLQUFLLENBQUM7QUFDMUc7QUFFQSxJQUFJLENBQUMsT0FBTzlCLFFBQVErQixPQUFPLEtBQUssY0FBZSxPQUFPL0IsUUFBUStCLE9BQU8sS0FBSyxZQUFZL0IsUUFBUStCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTy9CLFFBQVErQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRK0IsT0FBTyxFQUFFLGNBQWM7UUFBRTlCLE9BQU87SUFBSztJQUNuRUgsT0FBT21DLE1BQU0sQ0FBQ2pDLFFBQVErQixPQUFPLEVBQUUvQjtJQUMvQmtDLE9BQU9sQyxPQUFPLEdBQUdBLFFBQVErQixPQUFPO0FBQ2xDLEVBRUEscUVBQXFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaW52YWxpZGF0ZS1jYWNoZS1iZWxvdy1mbGlnaHQtc2VnbWVudHBhdGguanM/OGZlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGhcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGg7XG4gICAgfVxufSk7XG5jb25zdCBfY3JlYXRlcm91dGVyY2FjaGVrZXkgPSByZXF1aXJlKFwiLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleVwiKTtcbmZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMjtcbiAgICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICBjb25zdCBjYWNoZUtleSA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnQpO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgLy8gSW4gY2FzZSBvZiBsYXN0IGVudHJ5IGRvbid0IGNvcHkgZnVydGhlciBkb3duLlxuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBsYXp5RGF0YTogY2hpbGRDYWNoZU5vZGUubGF6eURhdGEsXG4gICAgICAgICAgICByc2M6IGNoaWxkQ2FjaGVOb2RlLnJzYyxcbiAgICAgICAgICAgIHByZWZldGNoUnNjOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgICAgICAgIGhlYWQ6IGNoaWxkQ2FjaGVOb2RlLmhlYWQsXG4gICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IGNoaWxkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhUmVzb2x2ZWRcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwiX2NyZWF0ZXJvdXRlcmNhY2hla2V5IiwicmVxdWlyZSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiaXNMYXN0RW50cnkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZGVsZXRlIiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJsYXp5RGF0YVJlc29sdmVkIiwic2xpY2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7273\n");

/***/ }),

/***/ 9255:
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"invalidateCacheByRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return invalidateCacheByRouterState;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ 4317);\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-by-router-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI1NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsZ0VBQStEO0lBQzNESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyxxQ0FBMkI7QUFDakUsU0FBU0YsNkJBQTZCRyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsV0FBVztJQUN0RSx1RkFBdUY7SUFDdkYsSUFBSSxNQUFNQyxPQUFPRCxXQUFXLENBQUMsRUFBRSxDQUFDO1FBQzVCLE1BQU1FLDBCQUEwQkYsV0FBVyxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDLEVBQUU7UUFDdEQsTUFBTUUsV0FBVyxDQUFDLEdBQUdQLHNCQUFzQlEsb0JBQW9CLEVBQUVGO1FBQ2pFLE1BQU1HLGtDQUFrQ04sY0FBY08sY0FBYyxDQUFDWixHQUFHLENBQUNPO1FBQ3pFLElBQUlJLGlDQUFpQztZQUNqQyxJQUFJRSx5QkFBeUIsSUFBSUMsSUFBSUg7WUFDckNFLHVCQUF1QkUsTUFBTSxDQUFDTjtZQUM5QkwsU0FBU1EsY0FBYyxDQUFDSSxHQUFHLENBQUNULEtBQUtNO1FBQ3JDO0lBQ0o7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPaEIsUUFBUW9CLE9BQU8sS0FBSyxjQUFlLE9BQU9wQixRQUFRb0IsT0FBTyxLQUFLLFlBQVlwQixRQUFRb0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPcEIsUUFBUW9CLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt2QixPQUFPQyxjQUFjLENBQUNDLFFBQVFvQixPQUFPLEVBQUUsY0FBYztRQUFFbkIsT0FBTztJQUFLO0lBQ25FSCxPQUFPd0IsTUFBTSxDQUFDdEIsUUFBUW9CLE9BQU8sRUFBRXBCO0lBQy9CdUIsT0FBT3ZCLE9BQU8sR0FBR0EsUUFBUW9CLE9BQU87QUFDbEMsRUFFQSw0REFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJ5LXJvdXRlci1zdGF0ZS5qcz8wNjc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZTtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgcm91dGVyU3RhdGUpIHtcbiAgICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHJzYy5cbiAgICBmb3IoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKXtcbiAgICAgICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldWzBdO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSk7XG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW52YWxpZGF0ZS1jYWNoZS1ieS1yb3V0ZXItc3RhdGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJyZXF1aXJlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJrZXkiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlIiwicGFyYWxsZWxSb3V0ZXMiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZGVsZXRlIiwic2V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9255\n");

/***/ }),

/***/ 1619:
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isNavigatingToNewRootLayout\", ({\n    enumerable: true,\n    get: function() {\n        return isNavigatingToNewRootLayout;\n    }\n}));\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYxOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0RBQThEO0lBQzFESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsNEJBQTRCQyxXQUFXLEVBQUVDLFFBQVE7SUFDdEQsbUJBQW1CO0lBQ25CLE1BQU1DLHFCQUFxQkYsV0FBVyxDQUFDLEVBQUU7SUFDekMsTUFBTUcsa0JBQWtCRixRQUFRLENBQUMsRUFBRTtJQUNuQywyRkFBMkY7SUFDM0YsNERBQTREO0lBQzVELHVJQUF1STtJQUN2SSxJQUFJRyxNQUFNQyxPQUFPLENBQUNILHVCQUF1QkUsTUFBTUMsT0FBTyxDQUFDRixrQkFBa0I7UUFDckUsc0hBQXNIO1FBQ3RILHVHQUF1RztRQUN2RyxJQUFJRCxrQkFBa0IsQ0FBQyxFQUFFLEtBQUtDLGVBQWUsQ0FBQyxFQUFFLElBQUlELGtCQUFrQixDQUFDLEVBQUUsS0FBS0MsZUFBZSxDQUFDLEVBQUUsRUFBRTtZQUM5RixPQUFPO1FBQ1g7SUFDSixPQUFPLElBQUlELHVCQUF1QkMsaUJBQWlCO1FBQy9DLE9BQU87SUFDWDtJQUNBLGlDQUFpQztJQUNqQyxJQUFJSCxXQUFXLENBQUMsRUFBRSxFQUFFO1FBQ2hCLDRFQUE0RTtRQUM1RSxPQUFPLENBQUNDLFFBQVEsQ0FBQyxFQUFFO0lBQ3ZCO0lBQ0EscUVBQXFFO0lBQ3JFLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEVBQUU7UUFDYixPQUFPO0lBQ1g7SUFDQSw0R0FBNEc7SUFDNUcsMkZBQTJGO0lBQzNGLG1EQUFtRDtJQUNuRCxNQUFNSyxtQkFBbUJiLE9BQU9jLE1BQU0sQ0FBQ1AsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDekQsTUFBTVEsZ0JBQWdCZixPQUFPYyxNQUFNLENBQUNOLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0lBQ25ELElBQUksQ0FBQ0ssb0JBQW9CLENBQUNFLGVBQWUsT0FBTztJQUNoRCxPQUFPVCw0QkFBNEJPLGtCQUFrQkU7QUFDekQ7QUFFQSxJQUFJLENBQUMsT0FBT2IsUUFBUWMsT0FBTyxLQUFLLGNBQWUsT0FBT2QsUUFBUWMsT0FBTyxLQUFLLFlBQVlkLFFBQVFjLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2QsUUFBUWMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWMsT0FBTyxFQUFFLGNBQWM7UUFBRWIsT0FBTztJQUFLO0lBQ25FSCxPQUFPa0IsTUFBTSxDQUFDaEIsUUFBUWMsT0FBTyxFQUFFZDtJQUMvQmlCLE9BQU9qQixPQUFPLEdBQUdBLFFBQVFjLE9BQU87QUFDbEMsRUFFQSw0REFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dC5qcz9jYzU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQ7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5leHRUcmVlKSB7XG4gICAgLy8gQ29tcGFyZSBzZWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlU2VnbWVudCA9IGN1cnJlbnRUcmVlWzBdO1xuICAgIGNvbnN0IG5leHRUcmVlU2VnbWVudCA9IG5leHRUcmVlWzBdO1xuICAgIC8vIElmIGFueSBzZWdtZW50IGlzIGRpZmZlcmVudCBiZWZvcmUgd2UgZmluZCB0aGUgcm9vdCBsYXlvdXQsIHRoZSByb290IGxheW91dCBoYXMgY2hhbmdlZC5cbiAgICAvLyBFLmcuIC9zYW1lLyhncm91cDEpL2xheW91dC5qcyAtPiAvc2FtZS8oZ3JvdXAyKS9sYXlvdXQuanNcbiAgICAvLyBGaXJzdCBzZWdtZW50IGlzICdzYW1lJyBmb3IgYm90aCwga2VlcCBsb29raW5nLiAoZ3JvdXAxKSBjaGFuZ2VkIHRvIChncm91cDIpIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgd2FzIGZvdW5kLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VHJlZVNlZ21lbnQpICYmIEFycmF5LmlzQXJyYXkobmV4dFRyZWVTZWdtZW50KSkge1xuICAgICAgICAvLyBDb21wYXJlIGR5bmFtaWMgcGFyYW0gbmFtZSBhbmQgdHlwZSBidXQgaWdub3JlIHRoZSB2YWx1ZSwgZGlmZmVyZW50IHZhbHVlcyB3b3VsZCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHJvb3QgbGF5b3V0XG4gICAgICAgIC8vIC9bbmFtZV0gLSAvc2x1ZzEgYW5kIC9zbHVnMiwgYm90aCB2YWx1ZXMgKHNsdWcxICYgc2x1ZzIpIHN0aWxsIGhhcyB0aGUgc2FtZSBsYXlvdXQgL1tuYW1lXS9sYXlvdXQuanNcbiAgICAgICAgaWYgKGN1cnJlbnRUcmVlU2VnbWVudFswXSAhPT0gbmV4dFRyZWVTZWdtZW50WzBdIHx8IGN1cnJlbnRUcmVlU2VnbWVudFsyXSAhPT0gbmV4dFRyZWVTZWdtZW50WzJdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudFRyZWVTZWdtZW50ICE9PSBuZXh0VHJlZVNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSByb290IGxheW91dCBmb3VuZFxuICAgIGlmIChjdXJyZW50VHJlZVs0XSkge1xuICAgICAgICAvLyBJZiB0aGUgbmV4dCB0cmVlIGRvZXNuJ3QgaGF2ZSB0aGUgcm9vdCBsYXlvdXQgZmxhZywgaXQgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgICAgIHJldHVybiAhbmV4dFRyZWVbNF07XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSAgZGlkbid0IGhhdmUgaXRzIHJvb3QgbGF5b3V0IGhlcmUsIG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgIGlmIChuZXh0VHJlZVs0XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gV2UgY2FuJ3QgYXNzdW1lIGl0J3MgYHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuYCBoZXJlIGluIGNhc2UgdGhlIHJvb3QgbGF5b3V0IGlzIGBhcHAvQHNvbWV0aGluZy9sYXlvdXQuanNgXG4gICAgLy8gQnV0IGl0J3Mgbm90IHBvc3NpYmxlIHRvIGJlIG1vcmUgdGhhbiBvbmUgcGFyYWxsZWxSb3V0ZXMgYmVmb3JlIHRoZSByb290IGxheW91dCBpcyBmb3VuZFxuICAgIC8vIFRPRE8tQVBQOiBjaGFuZ2UgdG8gdHJhdmVyc2UgYWxsIHBhcmFsbGVsIHJvdXRlc1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKGN1cnJlbnRUcmVlWzFdKVswXTtcbiAgICBjb25zdCBuZXh0VHJlZUNoaWxkID0gT2JqZWN0LnZhbHVlcyhuZXh0VHJlZVsxXSlbMF07XG4gICAgaWYgKCFjdXJyZW50VHJlZUNoaWxkIHx8ICFuZXh0VHJlZUNoaWxkKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlQ2hpbGQsIG5leHRUcmVlQ2hpbGQpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3VycmVudFRyZWUiLCJuZXh0VHJlZSIsImN1cnJlbnRUcmVlU2VnbWVudCIsIm5leHRUcmVlU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImN1cnJlbnRUcmVlQ2hpbGQiLCJ2YWx1ZXMiLCJuZXh0VHJlZUNoaWxkIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1619\n");

/***/ }),

/***/ 3176:
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    updateCacheNodeOnNavigation: function() {\n        return updateCacheNodeOnNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ 6674);\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ 9551);\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ 4317);\nfunction updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server â€” for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren[parallelRouteKey];\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.PAGE_SEGMENT_KEY) {\n            // This is a leaf segment â€” a page, not a shared layout. We always apply\n            // its data.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        } else if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment â€” a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation â€” but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else if (oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees.\n                if (prefetchDataChild !== undefined && prefetchDataChild !== null) {\n                    // Recursively update the children.\n                    taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, prefetchDataChild, prefetchHead);\n                } else {\n                    // The server didn't send any prefetch data for this segment. This\n                    // shouldn't happen because the Route Tree and the Seed Data tree\n                    // should always be the same shape, but until we unify those types\n                    // it's still possible. For now we're going to deopt and trigger a\n                    // lazy fetch during render.\n                    taskChild = spawnTaskForMissingData(newRouterStateChild);\n                }\n            } else {\n                // Either there's no existing Cache Node for this segment, or this\n                // segment doesn't exist in the old Router State tree. Switch to the\n                // \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        }\n        if (taskChild !== null) {\n            // Something changed in the child tree. Keep track of the child task.\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            patchedRouterStateChildren[parallelRouteKey] = taskChild.route;\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        lazyDataResolved: false\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(routerState, prefetchData, prefetchHead) {\n    // Create a task that will later be fulfilled by data from the server.\n    const pendingCacheNode = createPendingCacheNode(routerState, prefetchData, prefetchHead);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        children: null\n    };\n}\nfunction spawnTaskForMissingData(routerState) {\n    // Create a task for a new subtree that wasn't prefetched by the server.\n    // This shouldn't really ever happen but it's here just in case the Seed Data\n    // Tree and the Router State Tree disagree unexpectedly.\n    const pendingCacheNode = createPendingCacheNode(routerState, null, null);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((response)=>{\n        const flightData = response[0];\n        for (const flightDataPath of flightData){\n            const segmentPath = flightDataPath.slice(0, -3);\n            const serverRouterState = flightDataPath[flightDataPath.length - 3];\n            const dynamicData = flightDataPath[flightDataPath.length - 2];\n            const dynamicHead = flightDataPath[flightDataPath.length - 1];\n            if (typeof segmentPath === \"string\") {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Null this out to indicate that the task is complete.\n            task.node = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[1];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(routerState, prefetchData, prefetchHead) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : null,\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        lazyDataResolved: false\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety â€” it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[1];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[2];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Null this out to indicate that the task is complete.\n    task.node = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch  data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === \"pending\";\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: shouldUsePrefetch ? oldCacheNode.loading : null,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        lazyDataResolved: false\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = \"pending\";\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === \"pending\") {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = \"fulfilled\";\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === \"pending\") {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = \"rejected\";\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO1lBQ3JCUyxZQUFZQyxNQUFNLEdBQUdwRDtZQUNyQnVDLE9BQU92QztRQUNYO0lBQ0o7SUFDQThDLFdBQVdELEdBQUcsR0FBR0Y7SUFDakIsT0FBT0c7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPakksUUFBUXdJLE9BQU8sS0FBSyxjQUFlLE9BQU94SSxRQUFRd0ksT0FBTyxLQUFLLFlBQVl4SSxRQUFRd0ksT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPeEksUUFBUXdJLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckszSSxPQUFPQyxjQUFjLENBQUNDLFFBQVF3SSxPQUFPLEVBQUUsY0FBYztRQUFFdkksT0FBTztJQUFLO0lBQ25FSCxPQUFPNEksTUFBTSxDQUFDMUksUUFBUXdJLE9BQU8sRUFBRXhJO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF3SSxPQUFPO0FBQ2xDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHByLW5hdmlnYXRpb25zLmpzPzY4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhYm9ydFRhc2s6IG51bGwsXG4gICAgbGlzdGVuRm9yRHluYW1pY1JlcXVlc3Q6IG51bGwsXG4gICAgdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uOiBudWxsLFxuICAgIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBhYm9ydFRhc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWJvcnRUYXNrO1xuICAgIH0sXG4gICAgbGlzdGVuRm9yRHluYW1pY1JlcXVlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3Q7XG4gICAgfSxcbiAgICB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uO1xuICAgIH0sXG4gICAgdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbjtcbiAgICB9XG59KTtcbmNvbnN0IF9zZWdtZW50ID0gcmVxdWlyZShcIi4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudFwiKTtcbmNvbnN0IF9tYXRjaHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL21hdGNoLXNlZ21lbnRzXCIpO1xuY29uc3QgX2NyZWF0ZXJvdXRlcmNhY2hla2V5ID0gcmVxdWlyZShcIi4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXlcIik7XG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24ob2xkQ2FjaGVOb2RlLCBvbGRSb3V0ZXJTdGF0ZSwgbmV3Um91dGVyU3RhdGUsIHByZWZldGNoRGF0YSwgcHJlZmV0Y2hIZWFkKSB7XG4gICAgLy8gRGlmZiB0aGUgb2xkIGFuZCBuZXcgdHJlZXMgdG8gcmV1c2UgdGhlIHNoYXJlZCBsYXlvdXRzLlxuICAgIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSBvbGRSb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gbmV3Um91dGVyU3RhdGVbMV07XG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGFbMV07XG4gICAgY29uc3Qgb2xkUGFyYWxsZWxSb3V0ZXMgPSBvbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXM7XG4gICAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgc2V0IG9mIHNlZ21lbnQgY2hpbGRyZW4sIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWN0aXZlIGluXG4gICAgLy8gdGhlIG5ldyB0cmVlLlxuICAgIC8vIFRPRE86IFdlIGN1cnJlbnRseSByZXRhaW4gYWxsIHRoZSBpbmFjdGl2ZSBzZWdtZW50cyBpbmRlZmluaXRlbHksIHVudGlsXG4gICAgLy8gdGhlcmUncyBhbiBleHBsaWNpdCByZWZyZXNoLCBvciBhIHBhcmVudCBsYXlvdXQgaXMgbGF6aWx5IHJlZnJlc2hlZC4gV2VcbiAgICAvLyByZWx5IG9uIHRoaXMgZm9yIHBvcHN0YXRlIG5hdmlnYXRpb25zLCB3aGljaCB1cGRhdGUgdGhlIFJvdXRlciBTdGF0ZSBUcmVlXG4gICAgLy8gYnV0IGRvIG5vdCBlYWdlcmx5IHBlcmZvcm0gYSBkYXRhIGZldGNoLCBiZWNhdXNlIHRoZXkgZXhwZWN0IHRoZSBzZWdtZW50XG4gICAgLy8gZGF0YSB0byBhbHJlYWR5IGJlIGluIHRoZSBDYWNoZSBOb2RlIHRyZWUuIEZvciBoaWdobHkgc3RhdGljIHNpdGVzIHRoYXRcbiAgICAvLyBhcmUgbW9zdGx5IHJlYWQtb25seSwgdGhpcyBtYXkgaGFwcGVuIG9ubHkgcmFyZWx5LCBjYXVzaW5nIG1lbW9yeSB0b1xuICAgIC8vIGxlYWsuIFdlIHNob3VsZCBmaWd1cmUgb3V0IGEgYmV0dGVyIG1vZGVsIGZvciB0aGUgbGlmZXRpbWUgb2YgaW5hY3RpdmVcbiAgICAvLyBzZWdtZW50cywgc28gd2UgY2FuIG1haW50YWluIGluc3RhbnQgYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdpdGhvdXRcbiAgICAvLyBsZWFraW5nIG1lbW9yeSBpbmRlZmluaXRlbHkuXG4gICAgY29uc3QgcHJlZmV0Y2hQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpO1xuICAgIC8vIEFzIHdlIGRpZmYgdGhlIHRyZWVzLCB3ZSBtYXkgc29tZXRpbWVzIG1vZGlmeSAoY29weS1vbi13cml0ZSwgbm90IG11dGF0ZSlcbiAgICAvLyB0aGUgUm91dGUgVHJlZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgc2VydmVyIOKAlCBmb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAvLyBvZiBkZWZhdWx0IHBhcmFsbGVsIHJvdXRlcywgd2UgcHJlc2VydmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudC4gVG9cbiAgICAvLyBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgdHJlZSwgd2UgY2xvbmUgdGhlIHJvdXRlciBzdGF0ZSBjaGlsZHJlbiBhbG9uZ1xuICAgIC8vIHRoZSByZXR1cm4gcGF0aC5cbiAgICBsZXQgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSB7fTtcbiAgICBsZXQgdGFza0NoaWxkcmVuID0gbnVsbDtcbiAgICBmb3IobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gbmV3Um91dGVyU3RhdGVDaGlsZHJlbil7XG4gICAgICAgIGNvbnN0IG5ld1JvdXRlclN0YXRlQ2hpbGQgPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBvbGRSb3V0ZXJTdGF0ZUNoaWxkID0gb2xkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgb2xkU2VnbWVudE1hcENoaWxkID0gb2xkUGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgICAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZCA9IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50Q2hpbGQgPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkWzBdO1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShuZXdTZWdtZW50Q2hpbGQpO1xuICAgICAgICBjb25zdCBvbGRTZWdtZW50Q2hpbGQgPSBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgPyBvbGRSb3V0ZXJTdGF0ZUNoaWxkWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvbGRDYWNoZU5vZGVDaGlsZCA9IG9sZFNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkID8gb2xkU2VnbWVudE1hcENoaWxkLmdldChuZXdTZWdtZW50S2V5Q2hpbGQpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdGFza0NoaWxkO1xuICAgICAgICBpZiAobmV3U2VnbWVudENoaWxkID09PSBfc2VnbWVudC5QQUdFX1NFR01FTlRfS0VZKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbGVhZiBzZWdtZW50IOKAlCBhIHBhZ2UsIG5vdCBhIHNoYXJlZCBsYXlvdXQuIFdlIGFsd2F5cyBhcHBseVxuICAgICAgICAgICAgLy8gaXRzIGRhdGEuXG4gICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blBlbmRpbmdUYXNrKG5ld1JvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmV3U2VnbWVudENoaWxkID09PSBfc2VnbWVudC5ERUZBVUxUX1NFR01FTlRfS0VZKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFub3RoZXIga2luZCBvZiBsZWFmIHNlZ21lbnQg4oCUIGEgZGVmYXVsdCByb3V0ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHJvdXRlcyBoYXZlIHNwZWNpYWwgYmVoYXZpb3IuIFdoZW4gdGhlcmUncyBubyBtYXRjaGluZyBzZWdtZW50XG4gICAgICAgICAgICAvLyBmb3IgYSBwYXJhbGxlbCByb3V0ZSwgTmV4dC5qcyBwcmVzZXJ2ZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudFxuICAgICAgICAgICAgLy8gZHVyaW5nIGEgY2xpZW50IG5hdmlnYXRpb24g4oCUIGJ1dCBub3QgZm9yIGluaXRpYWwgcmVuZGVyLiBUaGUgc2VydmVyXG4gICAgICAgICAgICAvLyBsZWF2ZXMgaXQgdG8gdGhlIGNsaWVudCB0byBhY2NvdW50IGZvciB0aGlzLiBTbyB3ZSBuZWVkIHRvIGhhbmRsZVxuICAgICAgICAgICAgLy8gaXQgaGVyZS5cbiAgICAgICAgICAgIGlmIChvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSB0aGUgZXhpc3RpbmcgUm91dGVyIFN0YXRlIGZvciB0aGlzIHNlZ21lbnQuIFdlIHNwYXduIGEgXCJ0YXNrXCJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgcm91dGVyIHN0YXRlOyB1bmxpa2UgbW9zdCwgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZnVsZmlsbGVkIGFuZCB3b24ndCBiZSBhZmZlY3RlZCBieSB0aGUgZHluYW1pYyByZXNwb25zZS5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blJldXNlZFRhc2sob2xkUm91dGVyU3RhdGVDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gY3VycmVudGx5IGFjdGl2ZSBzZWdtZW50LiBTd2l0Y2ggdG8gdGhlIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blBlbmRpbmdUYXNrKG5ld1JvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2xkU2VnbWVudENoaWxkICE9PSB1bmRlZmluZWQgJiYgKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkobmV3U2VnbWVudENoaWxkLCBvbGRTZWdtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAob2xkQ2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJiBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNlZ21lbnQgZXhpc3RzIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHRyZWVzLlxuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkICYmIHByZWZldGNoRGF0YUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgICAgIHRhc2tDaGlsZCA9IHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihvbGRDYWNoZU5vZGVDaGlsZCwgb2xkUm91dGVyU3RhdGVDaGlsZCwgbmV3Um91dGVyU3RhdGVDaGlsZCwgcHJlZmV0Y2hEYXRhQ2hpbGQsIHByZWZldGNoSGVhZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlcnZlciBkaWRuJ3Qgc2VuZCBhbnkgcHJlZmV0Y2ggZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUaGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGUgUm91dGUgVHJlZSBhbmQgdGhlIFNlZWQgRGF0YSB0cmVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHdheXMgYmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCB1bnRpbCB3ZSB1bmlmeSB0aG9zZSB0eXBlc1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHN0aWxsIHBvc3NpYmxlLiBGb3Igbm93IHdlJ3JlIGdvaW5nIHRvIGRlb3B0IGFuZCB0cmlnZ2VyIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blRhc2tGb3JNaXNzaW5nRGF0YShuZXdSb3V0ZXJTdGF0ZUNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB0aGVyZSdzIG5vIGV4aXN0aW5nIENhY2hlIE5vZGUgZm9yIHRoaXMgc2VnbWVudCwgb3IgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgb2xkIFJvdXRlciBTdGF0ZSB0cmVlLiBTd2l0Y2ggdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICAgICAgICAgIHRhc2tDaGlsZCA9IHNwYXduUGVuZGluZ1Rhc2sobmV3Um91dGVyU3RhdGVDaGlsZCwgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCwgcHJlZmV0Y2hIZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgdHJlZS4gU3dpdGNoIHRvIHRoZSBcImNyZWF0ZVwiIHBhdGguXG4gICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blBlbmRpbmdUYXNrKG5ld1JvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhc2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGNoYW5nZWQgaW4gdGhlIGNoaWxkIHRyZWUuIEtlZXAgdHJhY2sgb2YgdGhlIGNoaWxkIHRhc2suXG4gICAgICAgICAgICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFza0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza0NoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCB0YXNrQ2hpbGQpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB0YXNrQ2hpbGQubm9kZTtcbiAgICAgICAgICAgIGlmIChuZXdDYWNoZU5vZGVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KG5ld1NlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIHByZWZldGNoUGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY2hpbGQgdHJlZSdzIHJvdXRlIHN0YXRlIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcHJlZmV0Y2hlZFxuICAgICAgICAgICAgLy8gcm91dGUgc2VudCBieSB0aGUgc2VydmVyLiBXZSBuZWVkIHRvIGNsb25lIGl0IGFzIHdlIHRyYXZlcnNlIGJhY2sgdXBcbiAgICAgICAgICAgIC8vIHRoZSB0cmVlLlxuICAgICAgICAgICAgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSB0YXNrQ2hpbGQucm91dGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgY2hpbGQgZGlkbid0IGNoYW5nZS4gV2UgY2FuIHVzZSB0aGUgcHJlZmV0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IG5ld1JvdXRlclN0YXRlQ2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBObyBuZXcgdGFza3Mgd2VyZSBzcGF3bmVkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBvbGRDYWNoZU5vZGUucnNjLFxuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGFyZW4ndCB1cGRhdGluZyB0aGUgcHJlZmV0Y2hSc2MgZmllbGQsIHNpbmNlIHRoaXMgbm9kZVxuICAgICAgICAvLyBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIGN1cnJlbnQgdHJlZSwgYmVjYXVzZSBpdCB3b3VsZCBiZSB3ZWlyZCBmb3JcbiAgICAgICAgLy8gcHJlZmV0Y2ggZGF0YSB0byBiZSBuZXdlciB0aGFuIHRoZSBmaW5hbCBkYXRhLiBJdCBwcm9iYWJseSB3b24ndCBldmVyIGJlXG4gICAgICAgIC8vIG9ic2VydmFibGUgYW55d2F5LCBidXQgaXQgY291bGQgaGFwcGVuIGlmIHRoZSBzZWdtZW50IGlzIHVubW91bnRlZCB0aGVuXG4gICAgICAgIC8vIG1vdW50ZWQgYWdhaW4sIGJlY2F1c2UgTGF5b3V0Um91dGVyIHdpbGwgbW9tZW50YXJpbHkgc3dpdGNoIHRvIHJlbmRlcmluZ1xuICAgICAgICAvLyBwcmVmZXRjaFJzYywgdmlhIHVzZURlZmVycmVkVmFsdWUuXG4gICAgICAgIHByZWZldGNoUnNjOiBvbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICAgIGhlYWQ6IG9sZENhY2hlTm9kZS5oZWFkLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICAgIGxvYWRpbmc6IG9sZENhY2hlTm9kZS5sb2FkaW5nLFxuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIGNsb25lZCBleGNlcHQgZm9yIHRoZSBjaGlsZHJlbiwgd2hpY2ggd2UgY29tcHV0ZWQgYWJvdmUuXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBwcmVmZXRjaFBhcmFsbGVsUm91dGVzLFxuICAgICAgICBsYXp5RGF0YVJlc29sdmVkOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgY2xvbmVkIGNvcHkgb2YgdGhlIHJvdXRlciBzdGF0ZSB3aXRoIHVwZGF0ZWQgY2hpbGRyZW4uXG4gICAgICAgIHJvdXRlOiBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKG5ld1JvdXRlclN0YXRlLCBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbiksXG4gICAgICAgIG5vZGU6IG5ld0NhY2hlTm9kZSxcbiAgICAgICAgY2hpbGRyZW46IHRhc2tDaGlsZHJlblxuICAgIH07XG59XG5mdW5jdGlvbiBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKGJhc2VSb3V0ZXJTdGF0ZSwgbmV3Q2hpbGRyZW4pIHtcbiAgICBjb25zdCBjbG9uZSA9IFtcbiAgICAgICAgYmFzZVJvdXRlclN0YXRlWzBdLFxuICAgICAgICBuZXdDaGlsZHJlblxuICAgIF07XG4gICAgLy8gQmFzZWQgb24gZXF1aXZhbGVudCBsb2dpYyBpbiBhcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSwgYnV0IHNob3VsZFxuICAgIC8vIGNvbmZpcm0gd2hldGhlciB3ZSBuZWVkIHRvIGNvcHkgYWxsIG9mIHRoZXNlIGZpZWxkcy4gTm90IHN1cmUgdGhlIHNlcnZlclxuICAgIC8vIGV2ZXIgc2VuZHMsIGUuZy4gdGhlIHJlZmV0Y2ggbWFya2VyLlxuICAgIGlmICgyIGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgICAgICBjbG9uZVsyXSA9IGJhc2VSb3V0ZXJTdGF0ZVsyXTtcbiAgICB9XG4gICAgaWYgKDMgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgICAgIGNsb25lWzNdID0gYmFzZVJvdXRlclN0YXRlWzNdO1xuICAgIH1cbiAgICBpZiAoNCBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICAgICAgY2xvbmVbNF0gPSBiYXNlUm91dGVyU3RhdGVbNF07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIHNwYXduUGVuZGluZ1Rhc2socm91dGVyU3RhdGUsIHByZWZldGNoRGF0YSwgcHJlZmV0Y2hIZWFkKSB7XG4gICAgLy8gQ3JlYXRlIGEgdGFzayB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgIGNvbnN0IHBlbmRpbmdDYWNoZU5vZGUgPSBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHByZWZldGNoSGVhZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm91dGU6IHJvdXRlclN0YXRlLFxuICAgICAgICBub2RlOiBwZW5kaW5nQ2FjaGVOb2RlLFxuICAgICAgICBjaGlsZHJlbjogbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBzcGF3blJldXNlZFRhc2socmV1c2VkUm91dGVyU3RhdGUpIHtcbiAgICAvLyBDcmVhdGUgYSB0YXNrIHRoYXQgcmV1c2VzIGFuIGV4aXN0aW5nIHNlZ21lbnQsIGUuZy4gd2hlbiByZXVzaW5nXG4gICAgLy8gdGhlIGN1cnJlbnQgYWN0aXZlIHNlZ21lbnQgaW4gcGxhY2Ugb2YgYSBkZWZhdWx0IHJvdXRlLlxuICAgIHJldHVybiB7XG4gICAgICAgIHJvdXRlOiByZXVzZWRSb3V0ZXJTdGF0ZSxcbiAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3Bhd25UYXNrRm9yTWlzc2luZ0RhdGEocm91dGVyU3RhdGUpIHtcbiAgICAvLyBDcmVhdGUgYSB0YXNrIGZvciBhIG5ldyBzdWJ0cmVlIHRoYXQgd2Fzbid0IHByZWZldGNoZWQgYnkgdGhlIHNlcnZlci5cbiAgICAvLyBUaGlzIHNob3VsZG4ndCByZWFsbHkgZXZlciBoYXBwZW4gYnV0IGl0J3MgaGVyZSBqdXN0IGluIGNhc2UgdGhlIFNlZWQgRGF0YVxuICAgIC8vIFRyZWUgYW5kIHRoZSBSb3V0ZXIgU3RhdGUgVHJlZSBkaXNhZ3JlZSB1bmV4cGVjdGVkbHkuXG4gICAgY29uc3QgcGVuZGluZ0NhY2hlTm9kZSA9IGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUocm91dGVyU3RhdGUsIG51bGwsIG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcbiAgICAgICAgbm9kZTogcGVuZGluZ0NhY2hlTm9kZSxcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QodGFzaywgcmVzcG9uc2VQcm9taXNlKSB7XG4gICAgcmVzcG9uc2VQcm9taXNlLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICBjb25zdCBmbGlnaHREYXRhID0gcmVzcG9uc2VbMF07XG4gICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclJvdXRlclN0YXRlID0gZmxpZ2h0RGF0YVBhdGhbZmxpZ2h0RGF0YVBhdGgubGVuZ3RoIC0gM107XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRGF0YSA9IGZsaWdodERhdGFQYXRoW2ZsaWdodERhdGFQYXRoLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0hlYWQgPSBmbGlnaHREYXRhUGF0aFtmbGlnaHREYXRhUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudFBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2sodGFzaywgc2VnbWVudFBhdGgsIHNlcnZlclJvdXRlclN0YXRlLCBkeW5hbWljRGF0YSwgZHluYW1pY0hlYWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIGV4aGF1c3RlZCBhbGwgdGhlIGRhdGEgd2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55IHJlbWFpbmluZyBwZW5kaW5nIHRhc2tzIGluIHRoZSB0cmVlLCBhYm9ydCB0aGVtIG5vdy5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbnkgbWlzc2luZyBkYXRhLCBpdCB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoLlxuICAgICAgICBhYm9ydFRhc2sodGFzaywgbnVsbCk7XG4gICAgfSwgKGVycm9yKT0+e1xuICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBkdXJpbmcgcmVuZGVyXG4gICAgICAgIGFib3J0VGFzayh0YXNrLCBlcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKHJvb3RUYXNrLCBzZWdtZW50UGF0aCwgc2VydmVyUm91dGVyU3RhdGUsIGR5bmFtaWNEYXRhLCBkeW5hbWljSGVhZCkge1xuICAgIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlIG5lZWRcbiAgICAvLyB0byBmaW5kIHRoZSBwYXJ0IG9mIHRoZSB0YXNrIHRyZWUgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgcmVzcG9uc2UsIGFuZFxuICAgIC8vIGZ1bGZpbGwgaXQgdXNpbmcgdGhlIGR5bmFtaWMgZGF0YS5cbiAgICAvL1xuICAgIC8vIHNlZ21lbnRQYXRoIHJlcHJlc2VudHMgdGhlIHBhcmVudCBwYXRoIG9mIHN1YnRyZWUuIEl0J3MgYSByZXBlYXRpbmcgcGF0dGVyblxuICAgIC8vIG9mIHBhcmFsbGVsIHJvdXRlIGtleSBhbmQgc2VnbWVudDpcbiAgICAvL1xuICAgIC8vICAgW3N0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCBzdHJpbmcsIFNlZ21lbnQsIC4uLl1cbiAgICAvL1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGF0aCBhbmQgZmluaXNoIGFueSB0YXNrcyB0aGF0IG1hdGNoIHRoaXMgcGF5bG9hZC5cbiAgICBsZXQgdGFzayA9IHJvb3RUYXNrO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzZWdtZW50UGF0aC5sZW5ndGg7IGkgKz0gMil7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXkgPSBzZWdtZW50UGF0aFtpXTtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRQYXRoW2kgKyAxXTtcbiAgICAgICAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHRhc2tDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tTZWdtZW50ID0gdGFza0NoaWxkLnJvdXRlWzBdO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShzZWdtZW50LCB0YXNrU2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYSBtYXRjaCBmb3IgdGhpcyB0YXNrLiBLZWVwIHRyYXZlcnNpbmcgZG93biB0aGUgdGFzayB0cmVlLlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gdGFza0NoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZGlkbid0IGZpbmQgYSBjaGlsZCB0YXNrIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIGRhdGEuIEV4aXQuIFdlIHdvbid0XG4gICAgICAgIC8vIGFib3J0IHRoZSB0YXNrLCB0aG91Z2gsIGJlY2F1c2UgYSBkaWZmZXJlbnQgRmxpZ2h0RGF0YVBhdGggbWF5IGJlIGFibGUgdG9cbiAgICAgICAgLy8gZnVsZmlsbCBpdCAoc2VlIGxvb3AgaW4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QpLiBXZSBvbmx5IGFib3J0IHRhc2tzXG4gICAgICAgIC8vIG9uY2Ugd2UndmUgcnVuIG91dCBvZiBkYXRhLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCh0YXNrLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCh0YXNrLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKSB7XG4gICAgLy8gZHluYW1pY0RhdGEgbWF5IHJlcHJlc2VudCBhIGxhcmdlciBzdWJ0cmVlIHRoYW4gdGhlIHRhc2suIEJlZm9yZSB3ZSBjYW5cbiAgICAvLyBmaW5pc2ggdGhlIHRhc2ssIHdlIG5lZWQgdG8gbGluZSB0aGVtIHVwLlxuICAgIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW47XG4gICAgY29uc3QgdGFza05vZGUgPSB0YXNrLm5vZGU7XG4gICAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBsZWFmIG5vZGUgb2YgdGhlIHBlbmRpbmcgdGFzay4gVGhlIHNlcnZlciBkYXRhIHRyZWVcbiAgICAgICAgLy8gbGluZXMgdXAgdGhlIHBlbmRpbmcgQ2FjaGUgTm9kZSB0cmVlLiBXZSBjYW4gbm93IHN3aXRjaCB0byB0aGVcbiAgICAgICAgLy8gbm9ybWFsIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKHRhc2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlKHRhc2tOb2RlLCB0YXNrLnJvdXRlLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKTtcbiAgICAgICAgICAgIC8vIE51bGwgdGhpcyBvdXQgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdGFzayBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgIHRhc2subm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGUgc2VydmVyIHJldHVybmVkIG1vcmUgZGF0YSB0aGFuIHdlIG5lZWQgdG8gZmluaXNoIHRoZSB0YXNrLiBTa2lwIG92ZXJcbiAgICAvLyB0aGUgZXh0cmEgc2VnbWVudHMgdW50aWwgd2UgcmVhY2ggdGhlIGxlYWYgdGFzayBub2RlLlxuICAgIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gc2VydmVyUm91dGVyU3RhdGVbMV07XG4gICAgY29uc3QgZHluYW1pY0RhdGFDaGlsZHJlbiA9IGR5bmFtaWNEYXRhWzFdO1xuICAgIGZvcihjb25zdCBwYXJhbGxlbFJvdXRlS2V5IGluIHNlcnZlclJvdXRlclN0YXRlKXtcbiAgICAgICAgY29uc3Qgc2VydmVyUm91dGVyU3RhdGVDaGlsZCA9IHNlcnZlckNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBkeW5hbWljRGF0YUNoaWxkID0gZHluYW1pY0RhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgaWYgKHRhc2tDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrU2VnbWVudCA9IHRhc2tDaGlsZC5yb3V0ZVswXTtcbiAgICAgICAgICAgIGlmICgoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkWzBdLCB0YXNrU2VnbWVudCkgJiYgZHluYW1pY0RhdGFDaGlsZCAhPT0gbnVsbCAmJiBkeW5hbWljRGF0YUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoIGZvciB0aGlzIHRhc2suIEtlZXAgdHJhdmVyc2luZyBkb3duIHRoZSB0YXNrIHRyZWUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCh0YXNrQ2hpbGQsIHNlcnZlclJvdXRlclN0YXRlQ2hpbGQsIGR5bmFtaWNEYXRhQ2hpbGQsIGR5bmFtaWNIZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIFdlIGRpZG4ndCBmaW5kIGEgY2hpbGQgdGFzayB0aGF0IG1hdGNoZXMgdGhlIHNlcnZlciBkYXRhLiBXZSB3b24ndCBhYm9ydFxuICAgIC8vIHRoZSB0YXNrLCB0aG91Z2gsIGJlY2F1c2UgYSBkaWZmZXJlbnQgRmxpZ2h0RGF0YVBhdGggbWF5IGJlIGFibGUgdG9cbiAgICAvLyBmdWxmaWxsIGl0IChzZWUgbG9vcCBpbiBsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCkuIFdlIG9ubHkgYWJvcnQgdGFza3NcbiAgICAvLyBvbmNlIHdlJ3ZlIHJ1biBvdXQgb2YgZGF0YS5cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHByZWZldGNoSGVhZCkge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZHJlbiA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsxXSA6IG51bGw7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pe1xuICAgICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkID0gcm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQgPSBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbCA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXTtcbiAgICAgICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gKDAsIF9jcmVhdGVyb3V0ZXJjYWNoZWtleS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkoc2VnbWVudENoaWxkKTtcbiAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlQ2hpbGQsIHByZWZldGNoRGF0YUNoaWxkID09PSB1bmRlZmluZWQgPyBudWxsIDogcHJlZmV0Y2hEYXRhQ2hpbGQsIHByZWZldGNoSGVhZCk7XG4gICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKTtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZCk7XG4gICAgfVxuICAgIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgICAvLyBvbiBjb3JyZXNwb25kaW5nIGxvZ2ljIGluIGZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzXG4gICAgY29uc3QgaXNMZWFmU2VnbWVudCA9IHBhcmFsbGVsUm91dGVzLnNpemUgPT09IDA7XG4gICAgY29uc3QgbWF5YmVQcmVmZXRjaFJzYyA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsyXSA6IG51bGw7XG4gICAgY29uc3QgbWF5YmVQcmVmZXRjaExvYWRpbmcgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbM10gOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogcGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgIHByZWZldGNoUnNjOiBtYXliZVByZWZldGNoUnNjICE9PSB1bmRlZmluZWQgPyBtYXliZVByZWZldGNoUnNjIDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBpc0xlYWZTZWdtZW50ID8gcHJlZmV0Y2hIZWFkIDogbnVsbCxcbiAgICAgICAgbG9hZGluZzogbWF5YmVQcmVmZXRjaExvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hMb2FkaW5nIDogbnVsbCxcbiAgICAgICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgcHJvbWlzZS4gVGhpcyB3aWxsIGJlIGZ1bGZpbGxlZCBvbmNlIHRoZSBkeW5hbWljXG4gICAgICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgcnNjOiBjcmVhdGVEZWZlcnJlZFJzYygpLFxuICAgICAgICBoZWFkOiBpc0xlYWZTZWdtZW50ID8gY3JlYXRlRGVmZXJyZWRSc2MoKSA6IG51bGwsXG4gICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoY2FjaGVOb2RlLCB0YXNrU3RhdGUsIHNlcnZlclN0YXRlLCBkeW5hbWljRGF0YSwgZHluYW1pY0hlYWQpIHtcbiAgICAvLyBXcml0ZXMgYSBkeW5hbWljIHJlc3BvbnNlIGludG8gYW4gZXhpc3RpbmcgQ2FjaGUgTm9kZSB0cmVlLiBUaGlzIGRvZXMgX25vdF9cbiAgICAvLyBjcmVhdGUgYSBuZXcgdHJlZSwgaXQgdXBkYXRlcyB0aGUgZXhpc3RpbmcgdHJlZSBpbi1wbGFjZS4gU28gaXQgbXVzdCBmb2xsb3dcbiAgICAvLyB0aGUgU3VzcGVuc2UgcnVsZXMgb2YgY2FjaGUgc2FmZXR5IOKAlCBpdCBjYW4gcmVzb2x2ZSBwZW5kaW5nIHByb21pc2VzLCBidXRcbiAgICAvLyBpdCBjYW5ub3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGRhdGEuIEl0IGNhbiBhZGQgc2VnbWVudHMgdG8gdGhlIHRyZWUgKGJlY2F1c2VcbiAgICAvLyBhIG1pc3Npbmcgc2VnbWVudCB3aWxsIGNhdXNlIHRoZSBsYXlvdXQgcm91dGVyIHRvIHN1c3BlbmQpLlxuICAgIC8vIGJ1dCBpdCBjYW5ub3QgZGVsZXRlIHRoZW0uXG4gICAgLy9cbiAgICAvLyBXZSBtdXN0IHJlc29sdmUgZXZlcnkgcHJvbWlzZSBpbiB0aGUgdHJlZSwgb3IgZWxzZSBpdCB3aWxsIHN1c3BlbmRcbiAgICAvLyBpbmRlZmluaXRlbHkuIElmIHdlIGRpZCBub3QgcmVjZWl2ZSBkYXRhIGZvciBhIHNlZ21lbnQsIHdlIHdpbGwgcmVzb2x2ZSBpdHNcbiAgICAvLyBkYXRhIHByb21pc2UgdG8gYG51bGxgIHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgY29uc3QgdGFza1N0YXRlQ2hpbGRyZW4gPSB0YXNrU3RhdGVbMV07XG4gICAgY29uc3Qgc2VydmVyU3RhdGVDaGlsZHJlbiA9IHNlcnZlclN0YXRlWzFdO1xuICAgIGNvbnN0IGRhdGFDaGlsZHJlbiA9IGR5bmFtaWNEYXRhWzFdO1xuICAgIC8vIFRoZSByb3V0ZXIgc3RhdGUgdGhhdCB3ZSB0cmF2ZXJzZSB0aGUgdHJlZSB3aXRoICh0YXNrU3RhdGUpIGlzIHRoZSBzYW1lIG9uZVxuICAgIC8vIHRoYXQgd2UgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHBlbmRpbmcgQ2FjaGUgTm9kZSB0cmVlLiBUaGF0IHdheSB3ZSdyZSBzdXJlXG4gICAgLy8gdG8gcmVzb2x2ZSBhbGwgdGhlIHBlbmRpbmcgcHJvbWlzZXMuXG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBjYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXM7XG4gICAgZm9yKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHRhc2tTdGF0ZUNoaWxkcmVuKXtcbiAgICAgICAgY29uc3QgdGFza1N0YXRlQ2hpbGQgPSB0YXNrU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgc2VydmVyU3RhdGVDaGlsZCA9IHNlcnZlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IGRhdGFDaGlsZCA9IGRhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgc2VnbWVudE1hcENoaWxkID0gcGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgICAgICBjb25zdCB0YXNrU2VnbWVudENoaWxkID0gdGFza1N0YXRlQ2hpbGRbMF07XG4gICAgICAgIGNvbnN0IHRhc2tTZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KSh0YXNrU2VnbWVudENoaWxkKTtcbiAgICAgICAgY29uc3QgY2FjaGVOb2RlQ2hpbGQgPSBzZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHNlZ21lbnRNYXBDaGlsZC5nZXQodGFza1NlZ21lbnRLZXlDaGlsZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc2VydmVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkICYmICgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHRhc2tTZWdtZW50Q2hpbGQsIHNlcnZlclN0YXRlQ2hpbGRbMF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFDaGlsZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBoYXBweSBwYXRoLiBSZWN1cnNpdmVseSB1cGRhdGUgYWxsIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUGVuZGluZ0NhY2hlTm9kZShjYWNoZU5vZGVDaGlsZCwgdGFza1N0YXRlQ2hpbGQsIHNlcnZlclN0YXRlQ2hpbGQsIGRhdGFDaGlsZCwgZHluYW1pY0hlYWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgbmV2ZXIgcmV0dXJuZWQgZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUcmlnZ2VyIGEgbGF6eVxuICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaCBkdXJpbmcgcmVuZGVyLiBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGUgUm91dGUgVHJlZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIFNlZWQgRGF0YSB0cmVlIHNlbnQgYnkgdGhlIHNlcnZlciBzaG91bGQgYWx3YXlzIGJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIHNoYXBlIHdoZW4gcGFydCBvZiB0aGUgc2FtZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrU3RhdGVDaGlsZCwgY2FjaGVOb2RlQ2hpbGQsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlcnZlciBuZXZlciByZXR1cm5lZCBkYXRhIGZvciB0aGlzIHNlZ21lbnQuIFRyaWdnZXIgYSBsYXp5XG4gICAgICAgICAgICAgICAgLy8gZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgICAgICAgICAgICBhYm9ydFBlbmRpbmdDYWNoZU5vZGUodGFza1N0YXRlQ2hpbGQsIGNhY2hlTm9kZUNoaWxkLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciByZXNwb25zZSBtYXRjaGVzIHdoYXQgd2FzIGV4cGVjdGVkIHRvIHJlY2VpdmUsIGJ1dCB0aGVyZSdzXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIENhY2hlIE5vZGUgaW4gdGhlIHRhc2sgdHJlZS4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGVcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBjcmVhdGVkIGEgbm9kZSBmb3IgZXZlcnlcbiAgICAgICAgLy8gc2VnbWVudCBpbiB0aGUgdHJlZSB0aGF0J3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGFzay5cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgdGhlIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdG8gZnVsZmlsbCB0aGUgZGVmZXJyZWQgUlNDIHByb21pc2VcbiAgICAvLyBvbiB0aGUgQ2FjaGUgTm9kZS5cbiAgICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjO1xuICAgIGNvbnN0IGR5bmFtaWNTZWdtZW50RGF0YSA9IGR5bmFtaWNEYXRhWzJdO1xuICAgIGlmIChyc2MgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxhenkgY2FjaGUgbm9kZS4gV2UgY2FuIG92ZXJ3cml0ZSBpdC4gVGhpcyBpcyBvbmx5IHNhZmVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBrbm93IHRoYXQgdGhlIExheW91dFJvdXRlciBzdXNwZW5kcyBpZiBgcnNjYCBpcyBgbnVsbGAuXG4gICAgICAgIGNhY2hlTm9kZS5yc2MgPSBkeW5hbWljU2VnbWVudERhdGE7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRlZmVycmVkIFJTQyBwcm9taXNlLiBXZSBjYW4gZnVsZmlsbCBpdCB3aXRoIHRoZSBkYXRhIHdlIGp1c3RcbiAgICAgICAgLy8gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLiBJZiBpdCB3YXMgYWxyZWFkeSByZXNvbHZlZCBieSBhIGRpZmZlcmVudFxuICAgICAgICAvLyBuYXZpZ2F0aW9uLCB0aGVuIHRoaXMgZG9lcyBub3RoaW5nIGJlY2F1c2Ugd2UgY2FuJ3Qgb3ZlcndyaXRlIGRhdGEuXG4gICAgICAgIHJzYy5yZXNvbHZlKGR5bmFtaWNTZWdtZW50RGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhIGRlZmVycmVkIFJTQyBwcm9taXNlLCBub3IgaXMgaXQgZW1wdHksIHNvIGl0IG11c3QgaGF2ZVxuICAgIC8vIGJlZW4gcG9wdWxhdGVkIGJ5IGEgZGlmZmVyZW50IG5hdmlnYXRpb24uIFdlIG11c3Qgbm90IG92ZXJ3cml0ZSBpdC5cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudC4gSWYgc28sIGl0IHdpbGwgaGF2ZSBhIGBoZWFkYCBwcm9wZXJ0eSB3aXRoXG4gICAgLy8gYSBwZW5kaW5nIHByb21pc2UgdGhhdCBuZWVkcyB0byBiZSByZXNvbHZlZCB3aXRoIHRoZSBkeW5hbWljIGhlYWQgZnJvbVxuICAgIC8vIHRoZSBzZXJ2ZXIuXG4gICAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkO1xuICAgIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgICAgIGhlYWQucmVzb2x2ZShkeW5hbWljSGVhZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIGVycm9yKSB7XG4gICAgY29uc3QgY2FjaGVOb2RlID0gdGFzay5ub2RlO1xuICAgIGlmIChjYWNoZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpbmRpY2F0ZXMgdGhlIHRhc2sgaXMgYWxyZWFkeSBjb21wbGV0ZS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXNrQ2hpbGRyZW4gPSB0YXNrLmNoaWxkcmVuO1xuICAgIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgLy8gUmVhY2hlZCB0aGUgbGVhZiB0YXNrIG5vZGUuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSBwZW5kaW5nIGNhY2hlXG4gICAgICAgIC8vIG5vZGUgdHJlZS5cbiAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2sucm91dGUsIGNhY2hlTm9kZSwgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXRlIHRhc2sgbm9kZS4gS2VlcCB0cmF2ZXJzaW5nIHVudGlsIHdlIHJlYWNoIGFcbiAgICAgICAgLy8gdGFzayBub2RlIHdpdGggbm8gY2hpbGRyZW4uIFRoYXQgd2lsbCBiZSB0aGUgcm9vdCBvZiB0aGUgY2FjaGUgbm9kZSB0cmVlXG4gICAgICAgIC8vIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICAgIGZvciAoY29uc3QgdGFza0NoaWxkIG9mIHRhc2tDaGlsZHJlbi52YWx1ZXMoKSl7XG4gICAgICAgICAgICBhYm9ydFRhc2sodGFza0NoaWxkLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTnVsbCB0aGlzIG91dCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YXNrIGlzIGNvbXBsZXRlLlxuICAgIHRhc2subm9kZSA9IG51bGw7XG59XG5mdW5jdGlvbiBhYm9ydFBlbmRpbmdDYWNoZU5vZGUocm91dGVyU3RhdGUsIGNhY2hlTm9kZSwgZXJyb3IpIHtcbiAgICAvLyBGb3IgZXZlcnkgcGVuZGluZyBzZWdtZW50IGluIHRoZSB0cmVlLCByZXNvbHZlIGl0cyBgcnNjYCBwcm9taXNlIHRvIGBudWxsYFxuICAgIC8vIHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgLy9cbiAgICAvLyBPciwgaWYgYW4gZXJyb3Igb2JqZWN0IGlzIHByb3ZpZGVkLCBpdCB3aWxsIGVycm9yIGluc3RlYWQuXG4gICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdO1xuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gY2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzO1xuICAgIGZvcihsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKXtcbiAgICAgICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRNYXBDaGlsZCA9IHBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgaWYgKHNlZ21lbnRNYXBDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdO1xuICAgICAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShzZWdtZW50Q2hpbGQpO1xuICAgICAgICBjb25zdCBjYWNoZU5vZGVDaGlsZCA9IHNlZ21lbnRNYXBDaGlsZC5nZXQoc2VnbWVudEtleUNoaWxkKTtcbiAgICAgICAgaWYgKGNhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZShyb3V0ZXJTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB3ZSdyZSB0cmF2ZXJzaW5nIHRoZSBzYW1lIHRyZWUgdGhhdCB3YXNcbiAgICAgICAgLy8gdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNhY2hlIG5vZGVzIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjO1xuICAgIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgICAgICAgIHJzYy5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgZHVyaW5nIHJlbmRlcmluZy5cbiAgICAgICAgICAgIHJzYy5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQuIElmIHNvLCBpdCB3aWxsIGhhdmUgYSBgaGVhZGAgcHJvcGVydHkgd2l0aFxuICAgIC8vIGEgcGVuZGluZyBwcm9taXNlIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQuIElmIGFuIGVycm9yIHdhcyBwcm92aWRlZCwgd2VcbiAgICAvLyB3aWxsIG5vdCByZXNvbHZlIGl0IHdpdGggYW4gZXJyb3IsIHNpbmNlIHRoaXMgaXMgcmVuZGVyZWQgYXQgdGhlIHJvb3Qgb2ZcbiAgICAvLyB0aGUgYXBwLiBXZSB3YW50IHRoZSBzZWdtZW50IHRvIGVycm9yLCBub3QgdGhlIGVudGlyZSBhcHAuXG4gICAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkO1xuICAgIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgICAgIGhlYWQucmVzb2x2ZShudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24ob2xkQ2FjaGVOb2RlLCByb3V0ZXJTdGF0ZSkge1xuICAgIC8vIEEgcG9wc3RhdGUgbmF2aWdhdGlvbiByZWFkcyBkYXRhIGZyb20gdGhlIGxvY2FsIGNhY2hlLiBJdCBkb2VzIG5vdCBpc3N1ZVxuICAgIC8vIG5ldyBuZXR3b3JrIHJlcXVlc3RzICh1bmxlc3MgdGhlIGNhY2hlIGVudHJpZXMgaGF2ZSBiZWVuIGV2aWN0ZWQpLiBTbywgd2VcbiAgICAvLyB1cGRhdGUgdGhlIGNhY2hlIHRvIGRyb3AgdGhlIHByZWZldGNoICBkYXRhIGZvciBhbnkgc2VnbWVudCB3aG9zZSBkeW5hbWljXG4gICAgLy8gZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpcyBwcmV2ZW50cyBhbiB1bm5lY2Vzc2FyeSBmbGFzaCBiYWNrIHRvIFBQUlxuICAgIC8vIHN0YXRlIGR1cmluZyBhIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uLlxuICAgIC8vXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBjbG9uZXMgdGhlIGVudGlyZSBjYWNoZSBub2RlIHRyZWUgYW5kIHNldHMgdGhlIGBwcmVmZXRjaFJzY2BcbiAgICAvLyBmaWVsZCB0byBgbnVsbGAgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkLiBXZSBjYW4ndCBtdXRhdGUgdGhlIG5vZGVcbiAgICAvLyBpbiBwbGFjZSBiZWNhdXNlIHRoaXMgaXMgYSBjb25jdXJyZW50IGRhdGEgc3RydWN0dXJlLlxuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBvbGRQYXJhbGxlbFJvdXRlcyA9IG9sZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcztcbiAgICBjb25zdCBuZXdQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpO1xuICAgIGZvcihsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKXtcbiAgICAgICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnRDaGlsZCk7XG4gICAgICAgIGNvbnN0IG9sZFNlZ21lbnRNYXBDaGlsZCA9IG9sZFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgaWYgKG9sZFNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRDYWNoZU5vZGVDaGlsZCA9IG9sZFNlZ21lbnRNYXBDaGlsZC5nZXQoc2VnbWVudEtleUNoaWxkKTtcbiAgICAgICAgICAgIGlmIChvbGRDYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24ob2xkQ2FjaGVOb2RlQ2hpbGQsIHJvdXRlclN0YXRlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KHNlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG5ld1BhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBuZXdTZWdtZW50TWFwQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE9ubHkgc2hvdyBwcmVmZXRjaGVkIGRhdGEgaWYgdGhlIGR5bmFtaWMgZGF0YSBpcyBzdGlsbCBwZW5kaW5nLlxuICAgIC8vXG4gICAgLy8gVGVobmljYWxseSwgd2hhdCB3ZSdyZSBhY3R1YWxseSBjaGVja2luZyBpcyB3aGV0aGVyIHRoZSBkeW5hbWljIG5ldHdvcmtcbiAgICAvLyByZXNwb25zZSB3YXMgcmVjZWl2ZWQuIEJ1dCBzaW5jZSBpdCdzIGEgc3RyZWFtaW5nIHJlc3BvbnNlLCB0aGlzIGRvZXMgbm90XG4gICAgLy8gbWVhbiB0aGF0IGFsbCB0aGUgZHluYW1pYyBkYXRhIGhhcyBmdWxseSBzdHJlYW1lZCBpbi4gSXQganVzdCBtZWFucyB0aGF0XG4gICAgLy8gX3NvbWVfIG9mIHRoZSBkeW5hbWljIGRhdGEgd2FzIHJlY2VpdmVkLiBCdXQgYXMgYSBoZXVyaXN0aWMsIHdlIGFzc3VtZSB0aGF0XG4gICAgLy8gdGhlIHJlc3QgZHluYW1pYyBkYXRhIHdpbGwgc3RyZWFtIGluIHF1aWNrbHksIHNvIGl0J3Mgc3RpbGwgYmV0dGVyIHRvIHNraXBcbiAgICAvLyB0aGUgcHJlZmV0Y2ggc3RhdGUuXG4gICAgY29uc3QgcnNjID0gb2xkQ2FjaGVOb2RlLnJzYztcbiAgICBjb25zdCBzaG91bGRVc2VQcmVmZXRjaCA9IGlzRGVmZXJyZWRSc2MocnNjKSAmJiByc2Muc3RhdHVzID09PSBcInBlbmRpbmdcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjLFxuICAgICAgICBoZWFkOiBvbGRDYWNoZU5vZGUuaGVhZCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogc2hvdWxkVXNlUHJlZmV0Y2ggPyBvbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MgOiBudWxsLFxuICAgICAgICBsb2FkaW5nOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5sb2FkaW5nIDogbnVsbCxcbiAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBjbG9uZWQgY2hpbGRyZW4gd2UgY29tcHV0ZWQgYWJvdmVcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ld1BhcmFsbGVsUm91dGVzLFxuICAgICAgICBsYXp5RGF0YVJlc29sdmVkOiBmYWxzZVxuICAgIH07XG59XG5jb25zdCBERUZFUlJFRCA9IFN5bWJvbCgpO1xuLy8gVGhpcyB0eXBlIGV4aXN0cyB0byBkaXN0aW5ndWlzaCBhIERlZmVycmVkUnNjIGZyb20gYSBGbGlnaHQgcHJvbWlzZS4gSXQncyBhXG4vLyBjb21wcm9taXNlIHRvIGF2b2lkIGFkZGluZyBhbiBleHRyYSBmaWVsZCBvbiBldmVyeSBDYWNoZSBOb2RlLCB3aGljaCB3b3VsZCBiZVxuLy8gYXdrd2FyZCBiZWNhdXNlIHRoZSBwcmUtUFBSIHBhcnRzIG9mIGNvZGViYXNlIHdvdWxkIG5lZWQgdG8gYWNjb3VudCBmb3IgaXQsXG4vLyB0b28uIFdlIGNhbiByZW1vdmUgaXQgb25jZSB0eXBlIENhY2hlIE5vZGUgdHlwZSBpcyBtb3JlIHNldHRsZWQuXG5mdW5jdGlvbiBpc0RlZmVycmVkUnNjKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRhZyA9PT0gREVGRVJSRUQ7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZFJzYygpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHBlbmRpbmdSc2MgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopPT57XG4gICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgIHJlamVjdCA9IHJlajtcbiAgICB9KTtcbiAgICBwZW5kaW5nUnNjLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHBlbmRpbmdSc2MucmVzb2x2ZSA9ICh2YWx1ZSk9PntcbiAgICAgICAgaWYgKHBlbmRpbmdSc2Muc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZnVsZmlsbGVkUnNjID0gcGVuZGluZ1JzYztcbiAgICAgICAgICAgIGZ1bGZpbGxlZFJzYy5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgZnVsZmlsbGVkUnNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcGVuZGluZ1JzYy5yZWplY3QgPSAoZXJyb3IpPT57XG4gICAgICAgIGlmIChwZW5kaW5nUnNjLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdGVkUnNjID0gcGVuZGluZ1JzYztcbiAgICAgICAgICAgIHJlamVjdGVkUnNjLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgIHJlamVjdGVkUnNjLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcGVuZGluZ1JzYy50YWcgPSBERUZFUlJFRDtcbiAgICByZXR1cm4gcGVuZGluZ1JzYztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHByLW5hdmlnYXRpb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImFib3J0VGFzayIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwidXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3NlZ21lbnQiLCJyZXF1aXJlIiwiX21hdGNoc2VnbWVudHMiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJvbGRDYWNoZU5vZGUiLCJvbGRSb3V0ZXJTdGF0ZSIsIm5ld1JvdXRlclN0YXRlIiwicHJlZmV0Y2hEYXRhIiwicHJlZmV0Y2hIZWFkIiwib2xkUm91dGVyU3RhdGVDaGlsZHJlbiIsIm5ld1JvdXRlclN0YXRlQ2hpbGRyZW4iLCJwcmVmZXRjaERhdGFDaGlsZHJlbiIsIm9sZFBhcmFsbGVsUm91dGVzIiwicGFyYWxsZWxSb3V0ZXMiLCJwcmVmZXRjaFBhcmFsbGVsUm91dGVzIiwiTWFwIiwicGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4iLCJ0YXNrQ2hpbGRyZW4iLCJwYXJhbGxlbFJvdXRlS2V5IiwibmV3Um91dGVyU3RhdGVDaGlsZCIsIm9sZFJvdXRlclN0YXRlQ2hpbGQiLCJvbGRTZWdtZW50TWFwQ2hpbGQiLCJwcmVmZXRjaERhdGFDaGlsZCIsIm5ld1NlZ21lbnRDaGlsZCIsIm5ld1NlZ21lbnRLZXlDaGlsZCIsImNyZWF0ZVJvdXRlckNhY2hlS2V5Iiwib2xkU2VnbWVudENoaWxkIiwidW5kZWZpbmVkIiwib2xkQ2FjaGVOb2RlQ2hpbGQiLCJ0YXNrQ2hpbGQiLCJQQUdFX1NFR01FTlRfS0VZIiwic3Bhd25QZW5kaW5nVGFzayIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJzcGF3blJldXNlZFRhc2siLCJtYXRjaFNlZ21lbnQiLCJzcGF3blRhc2tGb3JNaXNzaW5nRGF0YSIsInNldCIsIm5ld0NhY2hlTm9kZUNoaWxkIiwibm9kZSIsIm5ld1NlZ21lbnRNYXBDaGlsZCIsInJvdXRlIiwibmV3Q2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJsb2FkaW5nIiwibGF6eURhdGFSZXNvbHZlZCIsInBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4iLCJjaGlsZHJlbiIsImJhc2VSb3V0ZXJTdGF0ZSIsIm5ld0NoaWxkcmVuIiwiY2xvbmUiLCJyb3V0ZXJTdGF0ZSIsInBlbmRpbmdDYWNoZU5vZGUiLCJjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlIiwicmV1c2VkUm91dGVyU3RhdGUiLCJ0YXNrIiwicmVzcG9uc2VQcm9taXNlIiwidGhlbiIsInJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsImZsaWdodERhdGFQYXRoIiwic2VnbWVudFBhdGgiLCJzbGljZSIsInNlcnZlclJvdXRlclN0YXRlIiwibGVuZ3RoIiwiZHluYW1pY0RhdGEiLCJkeW5hbWljSGVhZCIsIndyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2siLCJlcnJvciIsInJvb3RUYXNrIiwiaSIsInNlZ21lbnQiLCJ0YXNrU2VnbWVudCIsImZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCIsInRhc2tOb2RlIiwiZmluaXNoUGVuZGluZ0NhY2hlTm9kZSIsInNlcnZlckNoaWxkcmVuIiwiZHluYW1pY0RhdGFDaGlsZHJlbiIsInNlcnZlclJvdXRlclN0YXRlQ2hpbGQiLCJkeW5hbWljRGF0YUNoaWxkIiwicm91dGVyU3RhdGVDaGlsZHJlbiIsInJvdXRlclN0YXRlQ2hpbGQiLCJzZWdtZW50Q2hpbGQiLCJzZWdtZW50S2V5Q2hpbGQiLCJpc0xlYWZTZWdtZW50Iiwic2l6ZSIsIm1heWJlUHJlZmV0Y2hSc2MiLCJtYXliZVByZWZldGNoTG9hZGluZyIsImNyZWF0ZURlZmVycmVkUnNjIiwiY2FjaGVOb2RlIiwidGFza1N0YXRlIiwic2VydmVyU3RhdGUiLCJ0YXNrU3RhdGVDaGlsZHJlbiIsInNlcnZlclN0YXRlQ2hpbGRyZW4iLCJkYXRhQ2hpbGRyZW4iLCJ0YXNrU3RhdGVDaGlsZCIsInNlcnZlclN0YXRlQ2hpbGQiLCJkYXRhQ2hpbGQiLCJzZWdtZW50TWFwQ2hpbGQiLCJ0YXNrU2VnbWVudENoaWxkIiwidGFza1NlZ21lbnRLZXlDaGlsZCIsImNhY2hlTm9kZUNoaWxkIiwiYWJvcnRQZW5kaW5nQ2FjaGVOb2RlIiwiZHluYW1pY1NlZ21lbnREYXRhIiwiaXNEZWZlcnJlZFJzYyIsInJlc29sdmUiLCJ2YWx1ZXMiLCJyZWplY3QiLCJuZXdQYXJhbGxlbFJvdXRlcyIsInNob3VsZFVzZVByZWZldGNoIiwic3RhdHVzIiwiREVGRVJSRUQiLCJTeW1ib2wiLCJ0YWciLCJwZW5kaW5nUnNjIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsImZ1bGZpbGxlZFJzYyIsInJlamVjdGVkUnNjIiwicmVhc29uIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3176\n");

/***/ }),

/***/ 4614:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchCacheEntryForInitialLoad: function() {\n        return createPrefetchCacheEntryForInitialLoad;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ 5471);\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ 882);\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ 744);\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ 7990);\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKey(url, nextUrl) {\n    const pathnameFromUrl = (0, _createhreffromurl.createHrefFromUrl)(url, false);\n    // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header\n    if (nextUrl) {\n        return nextUrl + \"%\" + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, buildId, prefetchCache, kind } = param;\n    let existingCacheEntry = undefined;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl);\n    const interceptionData = prefetchCache.get(interceptionCacheKey);\n    if (interceptionData) {\n        existingCacheEntry = interceptionData;\n    } else {\n        // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry\n        const prefetchCacheKey = createPrefetchCacheKey(url);\n        const prefetchData = prefetchCache.get(prefetchCacheKey);\n        if (prefetchData) {\n            existingCacheEntry = prefetchData;\n        }\n    }\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            return createLazyPrefetchEntry({\n                tree,\n                url,\n                buildId,\n                nextUrl,\n                prefetchCache,\n                // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                // rather than assuming the same intent as the previous entry, to be consistent with how we\n                // lazily create prefetch entries when intent is left unspecified.\n                kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        buildId,\n        nextUrl,\n        prefetchCache,\n        kind: kind || // in dev, there's never gonna be a prefetch entry so we want to prefetch here\n        ( true ? _routerreducertypes.PrefetchKind.AUTO : 0)\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache } = param;\n    const existingCacheKey = createPrefetchCacheKey(url);\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, nextUrl);\n    prefetchCache.set(newCacheKey, existingCacheEntry);\n    prefetchCache.delete(existingCacheKey);\n}\nfunction createPrefetchCacheEntryForInitialLoad(param) {\n    let { nextUrl, tree, prefetchCache, url, kind, data } = param;\n    const [, , , intercept] = data;\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = intercept ? createPrefetchCacheKey(url, nextUrl) : createPrefetchCacheKey(url);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, buildId, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, tree, nextUrl, buildId, kind).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            const [, , , intercepted] = prefetchResponse;\n            if (intercepted) {\n                prefixExistingPrefetchCacheEntry({\n                    url,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 30 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number(\"30\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime } = param;\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === \"auto\") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === \"full\") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBS0MsR0FBRyxLQUFLLENBQUNDLGdCQUFnQixPQUFPQSxlQUFlSCxZQUFXLElBQUtnQixzQkFBc0I7UUFDMUYsT0FBT2IsZUFBZTNDLG9CQUFvQjZDLHdCQUF3QixDQUFDZ0IsUUFBUSxHQUFHN0Qsb0JBQW9CNkMsd0JBQXdCLENBQUNDLEtBQUs7SUFDcEk7SUFDQSxzR0FBc0c7SUFDdEcsNEVBQTRFO0lBQzVFLHNEQUFzRDtJQUN0RCxJQUFJbkMsU0FBUyxRQUFRO1FBQ2pCLElBQUk4QixLQUFLQyxHQUFHLEtBQUtGLGVBQWVtQixxQkFBcUI7WUFDakQsT0FBTzNELG9CQUFvQjZDLHdCQUF3QixDQUFDaUIsS0FBSztRQUM3RDtJQUNKO0lBQ0EsaUdBQWlHO0lBQ2pHLElBQUluRCxTQUFTLFFBQVE7UUFDakIsSUFBSThCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZW1CLHFCQUFxQjtZQUNqRCxPQUFPM0Qsb0JBQW9CNkMsd0JBQXdCLENBQUNnQixRQUFRO1FBQ2hFO0lBQ0o7SUFDQSxPQUFPN0Qsb0JBQW9CNkMsd0JBQXdCLENBQUNVLE9BQU87QUFDL0Q7QUFFQSxJQUFJLENBQUMsT0FBT3RFLFFBQVE4RSxPQUFPLEtBQUssY0FBZSxPQUFPOUUsUUFBUThFLE9BQU8sS0FBSyxZQUFZOUUsUUFBUThFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzlFLFFBQVE4RSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakYsT0FBT0MsY0FBYyxDQUFDQyxRQUFROEUsT0FBTyxFQUFFLGNBQWM7UUFBRTdFLE9BQU87SUFBSztJQUNuRUgsT0FBT2tGLE1BQU0sQ0FBQ2hGLFFBQVE4RSxPQUFPLEVBQUU5RTtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFROEUsT0FBTztBQUNsQyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLmpzP2QwNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVQcmVmZXRjaENhY2hlRW50cnlGb3JJbml0aWFsTG9hZDogbnVsbCxcbiAgICBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeTogbnVsbCxcbiAgICBwcnVuZVByZWZldGNoQ2FjaGU6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5Rm9ySW5pdGlhbExvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5Rm9ySW5pdGlhbExvYWQ7XG4gICAgfSxcbiAgICBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeTtcbiAgICB9LFxuICAgIHBydW5lUHJlZmV0Y2hDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwcnVuZVByZWZldGNoQ2FjaGU7XG4gICAgfVxufSk7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuY29uc3QgX3ByZWZldGNocmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXJcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBjYWNoZSBrZXkgZm9yIHRoZSByb3V0ZXIgcHJlZmV0Y2ggY2FjaGVcbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBiZWluZyBuYXZpZ2F0ZWQgdG9cbiAqIEBwYXJhbSBuZXh0VXJsIC0gYW4gaW50ZXJuYWwgVVJMLCBwcmltYXJpbHkgdXNlZCBmb3IgaGFuZGxpbmcgcmV3cml0ZXMuIERlZmF1bHRzIHRvICcvJy5cbiAqIEByZXR1cm4gVGhlIGdlbmVyYXRlZCBwcmVmZXRjaCBjYWNoZSBrZXkuXG4gKi8gZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIG5leHRVcmwpIHtcbiAgICBjb25zdCBwYXRobmFtZUZyb21VcmwgPSAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKSh1cmwsIC8vIEVuc3VyZXMgdGhlIGhhc2ggaXMgbm90IHBhcnQgb2YgdGhlIGNhY2hlIGtleSBhcyBpdCBkb2VzIG5vdCBpbXBhY3QgdGhlIHNlcnZlciBmZXRjaFxuICAgIGZhbHNlKTtcbiAgICAvLyBuZXh0VXJsIGlzIHVzZWQgYXMgYSBjYWNoZSBrZXkgZGVsaW1pdGVyIHNpbmNlIGVudHJpZXMgY2FuIHZhcnkgYmFzZWQgb24gdGhlIE5leHQtVVJMIGhlYWRlclxuICAgIGlmIChuZXh0VXJsKSB7XG4gICAgICAgIHJldHVybiBuZXh0VXJsICsgXCIlXCIgKyBwYXRobmFtZUZyb21Vcmw7XG4gICAgfVxuICAgIHJldHVybiBwYXRobmFtZUZyb21Vcmw7XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeShwYXJhbSkge1xuICAgIGxldCB7IHVybCwgbmV4dFVybCwgdHJlZSwgYnVpbGRJZCwgcHJlZmV0Y2hDYWNoZSwga2luZCB9ID0gcGFyYW07XG4gICAgbGV0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHVuZGVmaW5lZDtcbiAgICAvLyBXZSBmaXJzdCBjaGVjayBpZiB0aGVyZSdzIGEgbW9yZSBzcGVjaWZpYyBpbnRlcmNlcHRpb24gcm91dGUgcHJlZmV0Y2ggZW50cnlcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2hlbiB3ZSBkZXRlY3QgYSBwcmVmZXRjaCB0aGF0IGNvcnJlc3BvbmRzIHdpdGggYW4gaW50ZXJjZXB0aW9uIHJvdXRlLCB3ZSBwcmVmaXggaXQgd2l0aCBuZXh0VXJsIChzZWUgYGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlgKVxuICAgIC8vIHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBhZ2VzIHRoYXQgbWF5IGhhdmUgdGhlIHNhbWUgVVJMIGJ1dCByZW5kZXIgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIGBOZXh0LVVSTGAgaGVhZGVyLlxuICAgIGNvbnN0IGludGVyY2VwdGlvbkNhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIG5leHRVcmwpO1xuICAgIGNvbnN0IGludGVyY2VwdGlvbkRhdGEgPSBwcmVmZXRjaENhY2hlLmdldChpbnRlcmNlcHRpb25DYWNoZUtleSk7XG4gICAgaWYgKGludGVyY2VwdGlvbkRhdGEpIHtcbiAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5ID0gaW50ZXJjZXB0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBkb250IGZpbmQgYSBtb3JlIHNwZWNpZmljIGludGVyY2VwdGlvbiByb3V0ZSBwcmVmZXRjaCBlbnRyeSwgd2UgY2hlY2sgZm9yIGEgcmVndWxhciBwcmVmZXRjaCBlbnRyeVxuICAgICAgICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwpO1xuICAgICAgICBjb25zdCBwcmVmZXRjaERhdGEgPSBwcmVmZXRjaENhY2hlLmdldChwcmVmZXRjaENhY2hlS2V5KTtcbiAgICAgICAgaWYgKHByZWZldGNoRGF0YSkge1xuICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hEYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAgICAgLy8gR3JhYiB0aGUgbGF0ZXN0IHN0YXR1cyBvZiB0aGUgY2FjaGUgZW50cnkgYW5kIHVwZGF0ZSBpdFxuICAgICAgICBleGlzdGluZ0NhY2hlRW50cnkuc3RhdHVzID0gZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKGV4aXN0aW5nQ2FjaGVFbnRyeSk7XG4gICAgICAgIC8vIHdoZW4gYGtpbmRgIGlzIHByb3ZpZGVkLCBhbiBleHBsaWNpdCBwcmVmZXRjaCB3YXMgcmVxdWVzdGVkLlxuICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdGVkIHByZWZldGNoIGlzIFwiZnVsbFwiIGFuZCB0aGUgY3VycmVudCBjYWNoZSBlbnRyeSB3YXNuJ3QsIHdlIHdhbnQgdG8gcmUtcHJlZmV0Y2ggd2l0aCB0aGUgbmV3IGludGVudFxuICAgICAgICBjb25zdCBzd2l0Y2hlZFRvRnVsbFByZWZldGNoID0gZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgIT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkZVTEwgJiYga2luZCA9PT0gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuRlVMTDtcbiAgICAgICAgaWYgKHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYnVpbGRJZCxcbiAgICAgICAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBleHBsaWNpdCBwcmVmZXRjaCBraW5kLCB3ZSB3YW50IHRvIHNldCBhIHRlbXBvcmFyeSBraW5kXG4gICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYXNzdW1pbmcgdGhlIHNhbWUgaW50ZW50IGFzIHRoZSBwcmV2aW91cyBlbnRyeSwgdG8gYmUgY29uc2lzdGVudCB3aXRoIGhvdyB3ZVxuICAgICAgICAgICAgICAgIC8vIGxhemlseSBjcmVhdGUgcHJlZmV0Y2ggZW50cmllcyB3aGVuIGludGVudCBpcyBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQgIT0gbnVsbCA/IGtpbmQgOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5URU1QT1JBUllcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB3YXMgbWFya2VkIGFzIHRlbXBvcmFyeSwgaXQgbWVhbnMgaXQgd2FzIGxhemlseSBjcmVhdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBnZXQgYW4gZW50cnksXG4gICAgICAgIC8vIHdoZXJlIHdlIGRpZG4ndCBoYXZlIHRoZSBwcmVmZXRjaCBpbnRlbnQuIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGludGVudCAoaW4gYGtpbmRgKSwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGVudHJ5IHRvIHRoZSBtb3JlIGFjY3VyYXRlIGtpbmQuXG4gICAgICAgIGlmIChraW5kICYmIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID09PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5URU1QT1JBUlkpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgdGhlIGV4aXN0aW5nIGVudHJ5IHdlIGZvdW5kIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSByZXR1cm4gaXQuXG4gICAgICAgIHJldHVybiBleGlzdGluZ0NhY2hlRW50cnk7XG4gICAgfVxuICAgIC8vIElmIHdlIGRpZG4ndCByZXR1cm4gYW4gZW50cnksIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICAgICAgdHJlZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBidWlsZElkLFxuICAgICAgICBuZXh0VXJsLFxuICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICBraW5kOiBraW5kIHx8IC8vIGluIGRldiwgdGhlcmUncyBuZXZlciBnb25uYSBiZSBhIHByZWZldGNoIGVudHJ5IHNvIHdlIHdhbnQgdG8gcHJlZmV0Y2ggaGVyZVxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE8gOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5URU1QT1JBUlkpXG4gICAgfSk7XG59XG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqLyBmdW5jdGlvbiBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeShwYXJhbSkge1xuICAgIGxldCB7IHVybCwgbmV4dFVybCwgcHJlZmV0Y2hDYWNoZSB9ID0gcGFyYW07XG4gICAgY29uc3QgZXhpc3RpbmdDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsKTtcbiAgICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChleGlzdGluZ0NhY2hlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgICAgICAvLyBuby1vcCAtLSB0aGVyZSB3YXNuJ3QgYW4gZW50cnkgdG8gbW92ZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0NhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIG5leHRVcmwpO1xuICAgIHByZWZldGNoQ2FjaGUuc2V0KG5ld0NhY2hlS2V5LCBleGlzdGluZ0NhY2hlRW50cnkpO1xuICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGV4aXN0aW5nQ2FjaGVLZXkpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5Rm9ySW5pdGlhbExvYWQocGFyYW0pIHtcbiAgICBsZXQgeyBuZXh0VXJsLCB0cmVlLCBwcmVmZXRjaENhY2hlLCB1cmwsIGtpbmQsIGRhdGEgfSA9IHBhcmFtO1xuICAgIGNvbnN0IFssICwgLCBpbnRlcmNlcHRdID0gZGF0YTtcbiAgICAvLyBpZiB0aGUgcHJlZmV0Y2ggY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHVzZSB0aGUgbmV4dFVybCB0byBwcmVmaXggdGhlIGNhY2hlIGtleVxuICAgIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBpbnRlcmNlcHQgPyBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwgbmV4dFVybCkgOiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCk7XG4gICAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgICAgIGRhdGE6IFByb21pc2UucmVzb2x2ZShkYXRhKSxcbiAgICAgICAga2luZCxcbiAgICAgICAgcHJlZmV0Y2hUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBsYXN0VXNlZFRpbWU6IERhdGUubm93KCksXG4gICAgICAgIGtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgc3RhdHVzOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaFxuICAgIH07XG4gICAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSk7XG4gICAgcmV0dXJuIHByZWZldGNoRW50cnk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovIGZ1bmN0aW9uIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsLCBraW5kLCB0cmVlLCBuZXh0VXJsLCBidWlsZElkLCBwcmVmZXRjaENhY2hlIH0gPSBwYXJhbTtcbiAgICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwpO1xuICAgIC8vIGluaXRpYXRlcyB0aGUgZmV0Y2ggcmVxdWVzdCBmb3IgdGhlIHByZWZldGNoIGFuZCBhdHRhY2hlcyBhIGxpc3RlbmVyXG4gICAgLy8gdG8gdGhlIHByb21pc2UgdG8gdXBkYXRlIHRoZSBwcmVmZXRjaCBjYWNoZSBlbnRyeSB3aGVuIHRoZSBwcm9taXNlIHJlc29sdmVzIChpZiBuZWNlc3NhcnkpXG4gICAgY29uc3QgZGF0YSA9IF9wcmVmZXRjaHJlZHVjZXIucHJlZmV0Y2hRdWV1ZS5lbnF1ZXVlKCgpPT4oMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkodXJsLCB0cmVlLCBuZXh0VXJsLCBidWlsZElkLCBraW5kKS50aGVuKChwcmVmZXRjaFJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgLy8gVE9ETzogYGZldGNoU2VydmVyUmVzcG9uc2VgIHNob3VsZCBiZSBtb3JlIHRpZ2hseSBjb3VwbGVkIHRvIHRoZXNlIHByZWZldGNoIGNhY2hlIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIGRyaWZ0IGJldHdlZW4gdGhpcyBjYWNoZSBrZXkgcHJlZml4aW5nIGxvZ2ljXG4gICAgICAgICAgICAvLyAod2hpY2ggaXMgY3VycmVudGx5IGRpcmVjdGx5IGluZmx1ZW5jZWQgYnkgdGhlIHNlcnZlciByZXNwb25zZSlcbiAgICAgICAgICAgIGNvbnN0IFssICwgLCBpbnRlcmNlcHRlZF0gPSBwcmVmZXRjaFJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKGludGVyY2VwdGVkKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmVmZXRjaFJlc3BvbnNlO1xuICAgICAgICB9KSk7XG4gICAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGtpbmQsXG4gICAgICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgbGFzdFVzZWRUaW1lOiBudWxsLFxuICAgICAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgICAgIHN0YXR1czogX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgICB9O1xuICAgIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpO1xuICAgIHJldHVybiBwcmVmZXRjaEVudHJ5O1xufVxuZnVuY3Rpb24gcHJ1bmVQcmVmZXRjaENhY2hlKHByZWZldGNoQ2FjaGUpIHtcbiAgICBmb3IgKGNvbnN0IFtocmVmLCBwcmVmZXRjaENhY2hlRW50cnldIG9mIHByZWZldGNoQ2FjaGUpe1xuICAgICAgICBpZiAoZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHByZWZldGNoQ2FjaGVFbnRyeSkgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWQpIHtcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGhyZWYpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlc2UgdmFsdWVzIGFyZSBzZXQgYnkgYGRlZmluZS1lbnYtcGx1Z2luYCAoYmFzZWQgb24gYG5leHRDb25maWcuZXhwZXJpbWVudGFsLnN0YWxlVGltZXNgKVxuLy8gYW5kIGRlZmF1bHQgdG8gNSBtaW51dGVzIChzdGF0aWMpIC8gMzAgc2Vjb25kcyAoZHluYW1pYylcbmNvbnN0IERZTkFNSUNfU1RBTEVUSU1FX01TID0gTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FKSAqIDEwMDA7XG5jb25zdCBTVEFUSUNfU1RBTEVUSU1FX01TID0gTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUpICogMTAwMDtcbmZ1bmN0aW9uIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwYXJhbSkge1xuICAgIGxldCB7IGtpbmQsIHByZWZldGNoVGltZSwgbGFzdFVzZWRUaW1lIH0gPSBwYXJhbTtcbiAgICAvLyBXZSB3aWxsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gdGhlIGBkeW5hbWljYCBzdGFsZXRpbWUgd2luZG93LlxuICAgIGlmIChEYXRlLm5vdygpIDwgKGxhc3RVc2VkVGltZSAhPSBudWxsID8gbGFzdFVzZWRUaW1lIDogcHJlZmV0Y2hUaW1lKSArIERZTkFNSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICAgIHJldHVybiBsYXN0VXNlZFRpbWUgPyBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZSA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoO1xuICAgIH1cbiAgICAvLyBGb3IgXCJhdXRvXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSBvbmx5IHRoZSBsb2FkaW5nIGJvdW5kYXJ5IGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAgIC8vIEEgc3RhbGUgZW50cnkgd2lsbCBvbmx5IHJlLXVzZSB0aGUgYGxvYWRpbmdgIGJvdW5kYXJ5LCBub3QgdGhlIGZ1bGwgZGF0YS5cbiAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIFwibGF6eSBmZXRjaFwiIGZvciB0aGUgZnVsbCBkYXRhLlxuICAgIGlmIChraW5kID09PSBcImF1dG9cIikge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3IgXCJmdWxsXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gYHN0YXRpY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgICBpZiAoa2luZCA9PT0gXCJmdWxsXCIpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWQ7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZldGNoLWNhY2hlLXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeUZvckluaXRpYWxMb2FkIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfY3JlYXRlaHJlZmZyb211cmwiLCJyZXF1aXJlIiwiX2ZldGNoc2VydmVycmVzcG9uc2UiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwiX3ByZWZldGNocmVkdWNlciIsImNyZWF0ZVByZWZldGNoQ2FjaGVLZXkiLCJ1cmwiLCJuZXh0VXJsIiwicGF0aG5hbWVGcm9tVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwYXJhbSIsInRyZWUiLCJidWlsZElkIiwicHJlZmV0Y2hDYWNoZSIsImtpbmQiLCJleGlzdGluZ0NhY2hlRW50cnkiLCJ1bmRlZmluZWQiLCJpbnRlcmNlcHRpb25DYWNoZUtleSIsImludGVyY2VwdGlvbkRhdGEiLCJwcmVmZXRjaENhY2hlS2V5IiwicHJlZmV0Y2hEYXRhIiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSIsIlRFTVBPUkFSWSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkFVVE8iLCJwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSIsImV4aXN0aW5nQ2FjaGVLZXkiLCJuZXdDYWNoZUtleSIsInNldCIsImRlbGV0ZSIsImRhdGEiLCJpbnRlcmNlcHQiLCJwcmVmZXRjaEVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInByZWZldGNoVGltZSIsIkRhdGUiLCJub3ciLCJsYXN0VXNlZFRpbWUiLCJrZXkiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJmcmVzaCIsInByZWZldGNoUXVldWUiLCJlbnF1ZXVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsInRoZW4iLCJwcmVmZXRjaFJlc3BvbnNlIiwiaW50ZXJjZXB0ZWQiLCJocmVmIiwicHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhwaXJlZCIsIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiTnVtYmVyIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUiLCJTVEFUSUNfU1RBTEVUSU1FX01TIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSIsInJldXNhYmxlIiwic3RhbGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4614\n");

/***/ }),

/***/ 1768:
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"fastRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return fastRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ 882);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 5471);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 2074);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 1619);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 7447);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 7138);\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ 543);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 3642);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 1514);\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ 6708);\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction fastRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        state.tree[0],\n        state.tree[1],\n        state.tree[2],\n        \"refetch\"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log(\"REFRESH FAILED\");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                \"\"\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction fastRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst fastRefreshReducer =  false ? 0 : fastRefreshReducerImpl;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fast-refresh-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmFzdC1yZWZyZXNoLXJlZHVjZXIuanM/MTNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZhc3RSZWZyZXNoUmVkdWNlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFzdFJlZnJlc2hSZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX2NyZWF0ZWhyZWZmcm9tdXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xuY29uc3QgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSA9IHJlcXVpcmUoXCIuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZVwiKTtcbmNvbnN0IF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQgPSByZXF1aXJlKFwiLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXRcIik7XG5jb25zdCBfbmF2aWdhdGVyZWR1Y2VyID0gcmVxdWlyZShcIi4vbmF2aWdhdGUtcmVkdWNlclwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2FwcGx5ZmxpZ2h0ZGF0YSA9IHJlcXVpcmUoXCIuLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9hcHByb3V0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlclwiKTtcbmNvbnN0IF9oYW5kbGVzZWdtZW50bWlzbWF0Y2ggPSByZXF1aXJlKFwiLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2hcIik7XG5jb25zdCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlID0gcmVxdWlyZShcIi4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWVcIik7XG4vLyBBIHZlcnNpb24gb2YgcmVmcmVzaCByZWR1Y2VyIHRoYXQga2VlcHMgdGhlIGNhY2hlIGFyb3VuZCBpbnN0ZWFkIG9mIHdpcGluZyBhbGwgb2YgaXQuXG5mdW5jdGlvbiBmYXN0UmVmcmVzaFJlZHVjZXJJbXBsKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IG9yaWdpbiB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IG11dGFibGUgPSB7fTtcbiAgICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsO1xuICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICAgIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gKDAsIF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUuaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKShzdGF0ZS50cmVlKTtcbiAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gICAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgIGNhY2hlLmxhenlEYXRhID0gKDAsIF9mZXRjaHNlcnZlcnJlc3BvbnNlLmZldGNoU2VydmVyUmVzcG9uc2UpKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwgW1xuICAgICAgICBzdGF0ZS50cmVlWzBdLFxuICAgICAgICBzdGF0ZS50cmVlWzFdLFxuICAgICAgICBzdGF0ZS50cmVlWzJdLFxuICAgICAgICBcInJlZmV0Y2hcIlxuICAgIF0sIGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsIHN0YXRlLmJ1aWxkSWQpO1xuICAgIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgbGV0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSBwYXJhbTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVyZWR1Y2VyLmhhbmRsZUV4dGVybmFsVXJsKShzdGF0ZSwgbXV0YWJsZSwgZmxpZ2h0RGF0YSwgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgICAgICBmb3IgKGNvbnN0IGZsaWdodERhdGFQYXRoIG9mIGZsaWdodERhdGEpe1xuICAgICAgICAgICAgLy8gRmxpZ2h0RGF0YVBhdGggd2l0aCBtb3JlIHRoYW4gdHdvIGl0ZW1zIG1lYW5zIHVuZXhwZWN0ZWQgRmxpZ2h0IGRhdGEgd2FzIHJldHVybmVkXG4gICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSRUZSRVNIIEZBSUxFRFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgcnNjIGZvciB0aGUgcm9vdC5cbiAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgXSwgY3VycmVudFRyZWUsIHRyZWVQYXRjaCwgc3RhdGUuY2Fub25pY2FsVXJsKTtcbiAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlc2VnbWVudG1pc21hdGNoLmhhbmRsZVNlZ21lbnRNaXNtYXRjaCkoc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dC5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5oYW5kbGVFeHRlcm5hbFVybCkoc3RhdGUsIG11dGFibGUsIGhyZWYsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKShjYW5vbmljYWxVcmxPdmVycmlkZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwcGxpZWQgPSAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKGN1cnJlbnRDYWNoZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgIGlmIChhcHBsaWVkKSB7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWY7XG4gICAgICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKCk9PnN0YXRlKTtcbn1cbmZ1bmN0aW9uIGZhc3RSZWZyZXNoUmVkdWNlck5vb3Aoc3RhdGUsIF9hY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBmYXN0UmVmcmVzaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmYXN0UmVmcmVzaFJlZHVjZXJOb29wIDogZmFzdFJlZnJlc2hSZWR1Y2VySW1wbDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFzdC1yZWZyZXNoLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImZhc3RSZWZyZXNoUmVkdWNlciIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwicmVxdWlyZSIsIl9jcmVhdGVocmVmZnJvbXVybCIsIl9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX25hdmlnYXRlcmVkdWNlciIsIl9oYW5kbGVtdXRhYmxlIiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsIl9hcHByb3V0ZXIiLCJfaGFuZGxlc2VnbWVudG1pc21hdGNoIiwiX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSIsImZhc3RSZWZyZXNoUmVkdWNlckltcGwiLCJzdGF0ZSIsImFjdGlvbiIsIm9yaWdpbiIsIm11dGFibGUiLCJocmVmIiwiY2Fub25pY2FsVXJsIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiaW5jbHVkZU5leHRVcmwiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJ0cmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibmV4dFVybCIsImJ1aWxkSWQiLCJ0aGVuIiwicGFyYW0iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImZhc3RSZWZyZXNoUmVkdWNlck5vb3AiLCJfYWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1768\n");

/***/ }),

/***/ 8723:
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findHeadInCache\", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ 4317);\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, \"\");\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + \"/\" + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcyMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyxzQ0FBNEI7QUFDbEUsU0FBU0YsZ0JBQWdCRyxLQUFLLEVBQUVDLGNBQWM7SUFDMUMsT0FBT0Msb0JBQW9CRixPQUFPQyxnQkFBZ0I7QUFDdEQ7QUFDQSxTQUFTQyxvQkFBb0JGLEtBQUssRUFBRUMsY0FBYyxFQUFFRSxTQUFTO0lBQ3pELE1BQU1DLGFBQWFiLE9BQU9jLElBQUksQ0FBQ0osZ0JBQWdCSyxNQUFNLEtBQUs7SUFDMUQsSUFBSUYsWUFBWTtRQUNaLDBFQUEwRTtRQUMxRSxPQUFPO1lBQ0hKO1lBQ0FHO1NBQ0g7SUFDTDtJQUNBLElBQUksTUFBTUksT0FBT04sZUFBZTtRQUM1QixNQUFNLENBQUNPLFNBQVNDLG9CQUFvQixHQUFHUixjQUFjLENBQUNNLElBQUk7UUFDMUQsTUFBTUcsa0JBQWtCVixNQUFNQyxjQUFjLENBQUNMLEdBQUcsQ0FBQ1c7UUFDakQsSUFBSSxDQUFDRyxpQkFBaUI7WUFDbEI7UUFDSjtRQUNBLE1BQU1DLFdBQVcsQ0FBQyxHQUFHYixzQkFBc0JjLG9CQUFvQixFQUFFSjtRQUNqRSxNQUFNSyxZQUFZSCxnQkFBZ0JkLEdBQUcsQ0FBQ2U7UUFDdEMsSUFBSSxDQUFDRSxXQUFXO1lBQ1o7UUFDSjtRQUNBLE1BQU1DLE9BQU9aLG9CQUFvQlcsV0FBV0oscUJBQXFCTixZQUFZLE1BQU1RO1FBQ25GLElBQUlHLE1BQU07WUFDTixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT3JCLFFBQVFzQixPQUFPLEtBQUssY0FBZSxPQUFPdEIsUUFBUXNCLE9BQU8sS0FBSyxZQUFZdEIsUUFBUXNCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3RCLFFBQVFzQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLekIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRc0IsT0FBTyxFQUFFLGNBQWM7UUFBRXJCLE9BQU87SUFBSztJQUNuRUgsT0FBTzBCLE1BQU0sQ0FBQ3hCLFFBQVFzQixPQUFPLEVBQUV0QjtJQUMvQnlCLE9BQU96QixPQUFPLEdBQUdBLFFBQVFzQixPQUFPO0FBQ2xDLEVBRUEsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlLmpzPzc1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmaW5kSGVhZEluQ2FjaGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZTtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleVwiKTtcbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICByZXR1cm4gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsIFwiXCIpO1xufVxuZnVuY3Rpb24gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsIGtleVByZWZpeCkge1xuICAgIGNvbnN0IGlzTGFzdEl0ZW0gPSBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwO1xuICAgIGlmIChpc0xhc3RJdGVtKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGVudGlyZSBDYWNoZSBOb2RlIG9mIHRoZSBzZWdtZW50IHdob3NlIGhlYWQgd2Ugd2lsbCByZW5kZXIuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGtleVByZWZpeFxuICAgICAgICBdO1xuICAgIH1cbiAgICBmb3IoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKXtcbiAgICAgICAgY29uc3QgW3NlZ21lbnQsIGNoaWxkUGFyYWxsZWxSb3V0ZXNdID0gcGFyYWxsZWxSb3V0ZXNba2V5XTtcbiAgICAgICAgY29uc3QgY2hpbGRTZWdtZW50TWFwID0gY2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICghY2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnQpO1xuICAgICAgICBjb25zdCBjYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFjYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBmaW5kSGVhZEluQ2FjaGVJbXBsKGNhY2hlTm9kZSwgY2hpbGRQYXJhbGxlbFJvdXRlcywga2V5UHJlZml4ICsgXCIvXCIgKyBjYWNoZUtleSk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC1oZWFkLWluLWNhY2hlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJmaW5kSGVhZEluQ2FjaGUiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJyZXF1aXJlIiwiY2FjaGUiLCJwYXJhbGxlbFJvdXRlcyIsImZpbmRIZWFkSW5DYWNoZUltcGwiLCJrZXlQcmVmaXgiLCJpc0xhc3RJdGVtIiwia2V5cyIsImxlbmd0aCIsImtleSIsInNlZ21lbnQiLCJjaGlsZFBhcmFsbGVsUm91dGVzIiwiY2hpbGRTZWdtZW50TWFwIiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImNhY2hlTm9kZSIsIml0ZW0iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8723\n");

/***/ }),

/***/ 5819:
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js ***!
  \***********************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSegmentValue\", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgxOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsZ0JBQWdCQyxPQUFPO0lBQzVCLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBV0EsT0FBTyxDQUFDLEVBQUUsR0FBR0E7QUFDakQ7QUFFQSxJQUFJLENBQUMsT0FBT0wsUUFBUVEsT0FBTyxLQUFLLGNBQWUsT0FBT1IsUUFBUVEsT0FBTyxLQUFLLFlBQVlSLFFBQVFRLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1IsUUFBUVEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1gsT0FBT0MsY0FBYyxDQUFDQyxRQUFRUSxPQUFPLEVBQUUsY0FBYztRQUFFUCxPQUFPO0lBQUs7SUFDbkVILE9BQU9ZLE1BQU0sQ0FBQ1YsUUFBUVEsT0FBTyxFQUFFUjtJQUMvQlcsT0FBT1gsT0FBTyxHQUFHQSxRQUFRUSxPQUFPO0FBQ2xDLEVBRUEsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWUuanM/NGU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNlZ21lbnRWYWx1ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U2VnbWVudFZhbHVlO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZ2V0U2VnbWVudFZhbHVlKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtc2VnbWVudC12YWx1ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0U2VnbWVudFZhbHVlIiwic2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5819\n");

/***/ }),

/***/ 6708:
/*!********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js ***!
  \********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ 8005);\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === \"di\" || segment[2] === \"ci\")) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === \"string\" && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcwOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgscUVBQW9FO0lBQ2hFSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyxpRUFBdUQ7QUFDM0YsU0FBU0Ysa0NBQWtDRyxLQUFLO0lBQzVDLElBQUksQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNoQyx3R0FBd0c7SUFDeEcsSUFBSUcsTUFBTUMsT0FBTyxDQUFDSCxZQUFhQSxDQUFBQSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVFBLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1FBQ3hFLE9BQU87SUFDWDtJQUNBLG9FQUFvRTtJQUNwRSxJQUFJLE9BQU9BLFlBQVksWUFBWSxDQUFDLEdBQUdILG9CQUFvQk8sMEJBQTBCLEVBQUVKLFVBQVU7UUFDN0YsT0FBTztJQUNYO0lBQ0EsK0NBQStDO0lBQy9DLElBQUlDLGdCQUFnQjtRQUNoQixJQUFJLE1BQU1JLE9BQU9KLGVBQWU7WUFDNUIsSUFBSUwsa0NBQWtDSyxjQUFjLENBQUNJLElBQUksR0FBRztnQkFDeEQsT0FBTztZQUNYO1FBQ0o7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPYixRQUFRYyxPQUFPLEtBQUssY0FBZSxPQUFPZCxRQUFRYyxPQUFPLEtBQUssWUFBWWQsUUFBUWMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPZCxRQUFRYyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRYyxPQUFPLEVBQUUsY0FBYztRQUFFYixPQUFPO0lBQUs7SUFDbkVILE9BQU9rQixNQUFNLENBQUNoQixRQUFRYyxPQUFPLEVBQUVkO0lBQy9CaUIsT0FBT2pCLE9BQU8sR0FBR0EsUUFBUWMsT0FBTztBQUNsQyxFQUVBLGtFQUFrRSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLmpzPzEwYzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcmNlcHRpb25yb3V0ZXMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2VydmVyL2Z1dHVyZS9oZWxwZXJzL2ludGVyY2VwdGlvbi1yb3V0ZXNcIik7XG5mdW5jdGlvbiBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUocGFyYW0pIHtcbiAgICBsZXQgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzXSA9IHBhcmFtO1xuICAgIC8vIElmIHdlIGhhdmUgYSBkeW5hbWljIHNlZ21lbnQsIGl0J3MgbWFya2VkIGFzIGFuIGludGVyY2VwdGlvbiByb3V0ZSBieSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGBpYCBzdWZmaXguXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkgJiYgKHNlZ21lbnRbMl0gPT09IFwiZGlcIiB8fCBzZWdtZW50WzJdID09PSBcImNpXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJZiBzZWdtZW50IGlzIG5vdCBhbiBhcnJheSwgYXBwbHkgdGhlIGV4aXN0aW5nIHN0cmluZy1iYXNlZCBjaGVja1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIiAmJiAoMCwgX2ludGVyY2VwdGlvbnJvdXRlcy5pc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCkoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBwYXJhbGxlbFJvdXRlcyBpZiB0aGV5IGV4aXN0XG4gICAgaWYgKHBhcmFsbGVsUm91dGVzKSB7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpe1xuICAgICAgICAgICAgaWYgKGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShwYXJhbGxlbFJvdXRlc1trZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsIl9pbnRlcmNlcHRpb25yb3V0ZXMiLCJyZXF1aXJlIiwicGFyYW0iLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImtleSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6708\n");

/***/ }),

/***/ 7447:
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ 882);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 5471);\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ 7273);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 2074);\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ 1510);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 1619);\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ 744);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 7138);\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ 543);\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ 7990);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 3642);\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ 6674);\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ 3176);\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ 4614);\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ 169);\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === \"\") {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nconst navigateReducer =  false ? 0 : navigateReducer_noPPR;\n// This is the implementation when PPR is disabled. We can assume its behavior\n// is relatively stable because it's been running in production for a while.\nfunction navigateReducer_noPPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === \"push\";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById(\"__next-page-redirect\")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                \"\",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                let applied = false;\n                if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                    // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                    // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                    // while copying over the `loading` for the segment that contains the page data.\n                    // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                    applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                    // since we re-used the stale cache's loading state & refreshed the data,\n                    // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                    prefetchValues.lastUsedTime = Date.now();\n                } else {\n                    applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                }\n                const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                if (hardNavigate) {\n                    // Copy rsc for the root node of the cache.\n                    cache.rsc = currentCache.rsc;\n                    cache.prefetchRsc = currentCache.prefetchRsc;\n                    (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                    // Ensure the existing cache value is used when the cache was not invalidated.\n                    mutable.cache = cache;\n                } else if (applied) {\n                    mutable.cache = cache;\n                    // If we applied the cache, we update the \"current cache\" value so any other\n                    // segments in the FlightDataPath will be able to reference the updated cache.\n                    currentCache = cache;\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\n// This is the experimental PPR implementation. It's closer to the behavior we\n// want, but is likelier to include accidental regressions because it rewrites\n// existing functionality.\nfunction navigateReducer_PPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === \"push\";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride, _postponed] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById(\"__next-page-redirect\")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        // TODO: In practice, this is always a single item array. We probably\n        // aren't going to every send multiple segments, at least not in this\n        // format. So we could remove the extra wrapper for now until\n        // that settles.\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                \"\",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                if (// will always send back a static response that's rendered from\n                // the root. If for some reason it doesn't, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via updateCacheNodeOnNavigation. The current structure is just\n                // an incremental step.\n                flightDataPath.length === 3) {\n                    const prefetchedTree = flightDataPath[0];\n                    const seedData = flightDataPath[1];\n                    const head = flightDataPath[2];\n                    const task = (0, _pprnavigations.updateCacheNodeOnNavigation)(currentCache, currentTree, prefetchedTree, seedData, head);\n                    if (task !== null && task.node !== null) {\n                        // We've created a new Cache Node tree that contains a prefetched\n                        // version of the next page. This can be rendered instantly.\n                        // Use the tree computed by updateCacheNodeOnNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        // The prefetched tree has dynamic holes in it. We initiate a\n                        // dynamic request to fill them in.\n                        //\n                        // Do not block on the result. We'll immediately render the Cache\n                        // Node tree and suspend on the dynamic parts. When the request\n                        // comes in, we'll fill in missing data and ping React to\n                        // re-render. Unlike the lazy fetching model in the non-PPR\n                        // implementation, this is modeled as a single React update +\n                        // streaming, rather than multiple top-level updates. (However,\n                        // even in the new model, we'll still need to sometimes update the\n                        // root multiple times per navigation, like if the server sends us\n                        // a different response than we expected. For now, we revert back\n                        // to the lazy fetching mechanism in that case.)\n                        (0, _pprnavigations.listenForDynamicRequest)(task, (0, _fetchserverresponse.fetchServerResponse)(url, currentTree, state.nextUrl, state.buildId));\n                        mutable.cache = newCache;\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = prefetchedTree;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there's no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache's loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = Date.now();\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the \"current cache\" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQ3ZCM0MsUUFBUTBDLFlBQVksR0FBR0E7UUFDdkIsT0FBTyxDQUFDLEdBQUduRCxlQUFlZ0IsYUFBYSxFQUFFUixPQUFPQztJQUNwRCxHQUFHLElBQUlEO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBTzNCLFFBQVFrSSxPQUFPLEtBQUssY0FBZSxPQUFPbEksUUFBUWtJLE9BQU8sS0FBSyxZQUFZbEksUUFBUWtJLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xJLFFBQVFrSSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckksT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0ksT0FBTyxFQUFFLGNBQWM7UUFBRWpJLE9BQU87SUFBSztJQUNuRUgsT0FBT3NJLE1BQU0sQ0FBQ3BJLFFBQVFrSSxPQUFPLEVBQUVsSTtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRa0ksT0FBTztBQUNsQyxFQUVBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXIuanM/ZDgxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGhhbmRsZUV4dGVybmFsVXJsOiBudWxsLFxuICAgIG5hdmlnYXRlUmVkdWNlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBoYW5kbGVFeHRlcm5hbFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybDtcbiAgICB9LFxuICAgIG5hdmlnYXRlUmVkdWNlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0ZVJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfZmV0Y2hzZXJ2ZXJyZXNwb25zZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG5jb25zdCBfaW52YWxpZGF0ZWNhY2hlYmVsb3dmbGlnaHRzZWdtZW50cGF0aCA9IHJlcXVpcmUoXCIuLi9pbnZhbGlkYXRlLWNhY2hlLWJlbG93LWZsaWdodC1zZWdtZW50cGF0aFwiKTtcbmNvbnN0IF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG5jb25zdCBfc2hvdWxkaGFyZG5hdmlnYXRlID0gcmVxdWlyZShcIi4uL3Nob3VsZC1oYXJkLW5hdmlnYXRlXCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbmNvbnN0IF9yb3V0ZXJyZWR1Y2VydHlwZXMgPSByZXF1aXJlKFwiLi4vcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBfaGFuZGxlbXV0YWJsZSA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtbXV0YWJsZVwiKTtcbmNvbnN0IF9hcHBseWZsaWdodGRhdGEgPSByZXF1aXJlKFwiLi4vYXBwbHktZmxpZ2h0LWRhdGFcIik7XG5jb25zdCBfcHJlZmV0Y2hyZWR1Y2VyID0gcmVxdWlyZShcIi4vcHJlZmV0Y2gtcmVkdWNlclwiKTtcbmNvbnN0IF9hcHByb3V0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlclwiKTtcbmNvbnN0IF9zZWdtZW50ID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudFwiKTtcbmNvbnN0IF9wcHJuYXZpZ2F0aW9ucyA9IHJlcXVpcmUoXCIuLi9wcHItbmF2aWdhdGlvbnNcIik7XG5jb25zdCBfcHJlZmV0Y2hjYWNoZXV0aWxzID0gcmVxdWlyZShcIi4uL3ByZWZldGNoLWNhY2hlLXV0aWxzXCIpO1xuY29uc3QgX2NsZWFyY2FjaGVub2RlZGF0YWZvcnNlZ21lbnRwYXRoID0gcmVxdWlyZShcIi4uL2NsZWFyLWNhY2hlLW5vZGUtZGF0YS1mb3Itc2VnbWVudC1wYXRoXCIpO1xuZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIHVybCwgcGVuZGluZ1B1c2gpIHtcbiAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSB0cnVlO1xuICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXJsO1xuICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaDtcbiAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKDAsIF9oYW5kbGVtdXRhYmxlLmhhbmRsZU11dGFibGUpKHN0YXRlLCBtdXRhYmxlKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2goZmxpZ2h0Um91dGVyUGF0Y2gpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJQYXRjaDtcbiAgICBpZiAoT2JqZWN0LmtleXMocGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHNlZ21lbnRcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgcGFyYWxsZWxSb3V0ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYWxsZWxSb3V0ZXMpKXtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZFNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaChwYXJhbGxlbFJvdXRlKSl7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VnbWVudCBpcyBlbXB0eSwgaXQgbWVhbnMgd2UgYXJlIGF0IHRoZSByb290IG9mIHRoZSB0cmVlXG4gICAgICAgICAgICBpZiAoc2VnbWVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZFNlZ21lbnRcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkU2VnbWVudFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50cztcbn1cbmZ1bmN0aW9uIHRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMobmV3Q2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWVQYXRjaCkge1xuICAgIGxldCBhcHBsaWVkUGF0Y2ggPSBmYWxzZTtcbiAgICBuZXdDYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjO1xuICAgIG5ld0NhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjO1xuICAgIG5ld0NhY2hlLmxvYWRpbmcgPSBjdXJyZW50Q2FjaGUubG9hZGluZztcbiAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoY3VycmVudENhY2hlLnBhcmFsbGVsUm91dGVzKTtcbiAgICBjb25zdCBzZWdtZW50UGF0aHNUb0ZpbGwgPSBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHRyZWVQYXRjaCkubWFwKChzZWdtZW50KT0+W1xuICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAuLi5zZWdtZW50XG4gICAgICAgIF0pO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudFBhdGhzIG9mIHNlZ21lbnRQYXRoc1RvRmlsbCl7XG4gICAgICAgICgwLCBfY2xlYXJjYWNoZW5vZGVkYXRhZm9yc2VnbWVudHBhdGguY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgpKG5ld0NhY2hlLCBjdXJyZW50Q2FjaGUsIHNlZ21lbnRQYXRocyk7XG4gICAgICAgIGFwcGxpZWRQYXRjaCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhcHBsaWVkUGF0Y2g7XG59XG5jb25zdCBuYXZpZ2F0ZVJlZHVjZXIgPSBwcm9jZXNzLmVudi5fX05FWFRfUFBSID8gbmF2aWdhdGVSZWR1Y2VyX1BQUiA6IG5hdmlnYXRlUmVkdWNlcl9ub1BQUjtcbi8vIFRoaXMgaXMgdGhlIGltcGxlbWVudGF0aW9uIHdoZW4gUFBSIGlzIGRpc2FibGVkLiBXZSBjYW4gYXNzdW1lIGl0cyBiZWhhdmlvclxuLy8gaXMgcmVsYXRpdmVseSBzdGFibGUgYmVjYXVzZSBpdCdzIGJlZW4gcnVubmluZyBpbiBwcm9kdWN0aW9uIGZvciBhIHdoaWxlLlxuZnVuY3Rpb24gbmF2aWdhdGVSZWR1Y2VyX25vUFBSKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IHVybCwgaXNFeHRlcm5hbFVybCwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBtdXRhYmxlID0ge307XG4gICAgY29uc3QgeyBoYXNoIH0gPSB1cmw7XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHVybCk7XG4gICAgY29uc3QgcGVuZGluZ1B1c2ggPSBuYXZpZ2F0ZVR5cGUgPT09IFwicHVzaFwiO1xuICAgIC8vIHdlIHdhbnQgdG8gcHJ1bmUgdGhlIHByZWZldGNoIGNhY2hlIG9uIGV2ZXJ5IG5hdmlnYXRpb24gdG8gYXZvaWQgaXQgZ3Jvd2luZyB0b28gbGFyZ2VcbiAgICAoMCwgX3ByZWZldGNoY2FjaGV1dGlscy5wcnVuZVByZWZldGNoQ2FjaGUpKHN0YXRlLnByZWZldGNoQ2FjaGUpO1xuICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICBpZiAoaXNFeHRlcm5hbFVybCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIHVybC50b1N0cmluZygpLCBwZW5kaW5nUHVzaCk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZldGNoVmFsdWVzID0gKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMuZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkpKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICB0cmVlOiBzdGF0ZS50cmVlLFxuICAgICAgICBidWlsZElkOiBzdGF0ZS5idWlsZElkLFxuICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlXG4gICAgfSk7XG4gICAgY29uc3QgeyB0cmVlQXRUaW1lT2ZQcmVmZXRjaCwgZGF0YSB9ID0gcHJlZmV0Y2hWYWx1ZXM7XG4gICAgX3ByZWZldGNocmVkdWNlci5wcmVmZXRjaFF1ZXVlLmJ1bXAoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEudGhlbigocGFyYW0pPT57XG4gICAgICAgIGxldCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcGFyYW07XG4gICAgICAgIGxldCBpc0ZpcnN0UmVhZCA9IGZhbHNlO1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gbWFyayB0aGlzIG9uY2VcbiAgICAgICAgaWYgKCFwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogd2Ugc2hvdWxkIG9ubHkgbWFyayB0aGUgY2FjaGUgbm9kZSBhcyBkaXJ0eSBhZnRlciB3ZSB1bnN1c3BlbmQgZnJvbSB0aGUgY2FsbCBhYm92ZVxuICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlzRmlyc3RSZWFkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHBlbmRpbmdQdXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgYDxtZXRhIGh0dHAtZXF1aXY9XCJyZWZyZXNoXCI+YCB0YWcgaXMgcHJlc2VudCxcbiAgICAgICAgLy8gd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJfX25leHQtcGFnZS1yZWRpcmVjdFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZVNlZ21lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgIC8vIFRoZSBvbmUgYmVmb3JlIGxhc3QgaXRlbSBpcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgcGF0Y2hcbiAgICAgICAgICAgIGNvbnN0IHRyZWVQYXRjaCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0zKVswXTtcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSA9IFtcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgICAgICBsZXQgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LCBjdXJyZW50VHJlZSwgdHJlZVBhdGNoLCBocmVmKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0cmVlIHBhdGNoIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgdHJlZSB0aGVuIHdlIHVzZSB0aGUgdHJlZSBhdCB0aW1lIG9mIHByZWZldGNoXG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogVGhpcyBzaG91bGQgaW5zdGVhZCBmaWxsIGluIHRoZSBtaXNzaW5nIHBpZWNlcyBpbiBgY3VycmVudFRyZWVgIHdpdGggdGhlIGRhdGEgZnJvbSBgdHJlZUF0VGltZU9mUHJlZmV0Y2hgLCB0aGVuIGFwcGx5IHRoZSBwYXRjaC5cbiAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSwgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIHRyZWVQYXRjaCwgaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dC5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGUgPSAoMCwgX2FwcHJvdXRlci5jcmVhdGVFbXB0eUNhY2hlTm9kZSkoKTtcbiAgICAgICAgICAgICAgICBsZXQgYXBwbGllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaFZhbHVlcy5zdGF0dXMgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlICYmICFpc0ZpcnN0UmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgYSBzdGFsZSBwcmVmZXRjaCBlbnRyeSwgd2Ugb25seSB3YW50IHRvIHJlLXVzZSB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgcm91dGUgd2UncmUgbmF2aWdhdGluZyB0bywgdG8gc3VwcG9ydCBpbnN0YW50IGxvYWRpbmcgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoIGZvciB0aGUgYWN0dWFsIHBhZ2UgZGF0YSBieSBudWxsaW5nIHRoZSBgcnNjYCBhbmQgYHByZWZldGNoUnNjYCB2YWx1ZXMgZm9yIHBhZ2UgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpbGUgY29weWluZyBvdmVyIHRoZSBgbG9hZGluZ2AgZm9yIHRoZSBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIHBhZ2UgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIG9uIHN1YnNlcXVlbnQgcmVhZHMsIGFzIG90aGVyd2lzZSB0aGVyZSdkIGJlIG5vIGxvYWRpbmcgZGF0YSB0byByZS11c2UuXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWQgPSB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKGNhY2hlLCBjdXJyZW50Q2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSByZS11c2VkIHRoZSBzdGFsZSBjYWNoZSdzIGxvYWRpbmcgc3RhdGUgJiByZWZyZXNoZWQgdGhlIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYGxhc3RVc2VkVGltZWAgc28gdGhhdCBpdCBjYW4gY29udGludWUgdG8gYmUgcmUtdXNlZCBmb3IgdGhlIG5leHQgMzBzXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZCA9ICgwLCBfYXBwbHlmbGlnaHRkYXRhLmFwcGx5RmxpZ2h0RGF0YSkoY3VycmVudENhY2hlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgsIHByZWZldGNoVmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gKDAsIF9zaG91bGRoYXJkbmF2aWdhdGUuc2hvdWxkSGFyZE5hdmlnYXRlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LCBjdXJyZW50VHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhcmROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnJzYyA9IGN1cnJlbnRDYWNoZS5yc2M7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2ludmFsaWRhdGVjYWNoZWJlbG93ZmxpZ2h0c2VnbWVudHBhdGguaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCkoY2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGV4aXN0aW5nIGNhY2hlIHZhbHVlIGlzIHVzZWQgd2hlbiB0aGUgY2FjaGUgd2FzIG5vdCBpbnZhbGlkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZCkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFwcGxpZWQgdGhlIGNhY2hlLCB3ZSB1cGRhdGUgdGhlIFwiY3VycmVudCBjYWNoZVwiIHZhbHVlIHNvIGFueSBvdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBpbiB0aGUgRmxpZ2h0RGF0YVBhdGggd2lsbCBiZSBhYmxlIHRvIHJlZmVyZW5jZSB0aGUgdXBkYXRlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdWJTZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIF9fREVGQVVMVF9fIHBhdGhzIGFzIHRoZXkgc2hvdWxkbid0IGJlIHNjcm9sbGVkIHRvIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVTZWdtZW50UGF0aFtzY3JvbGxhYmxlU2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gIT09IF9zZWdtZW50LkRFRkFVTFRfU0VHTUVOVF9LRVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50cy5wdXNoKHNjcm9sbGFibGVTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IGN1cnJlbnRUcmVlO1xuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogaHJlZjtcbiAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHNjcm9sbGFibGVTZWdtZW50cztcbiAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSBoYXNoO1xuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbDtcbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKCk9PnN0YXRlKTtcbn1cbi8vIFRoaXMgaXMgdGhlIGV4cGVyaW1lbnRhbCBQUFIgaW1wbGVtZW50YXRpb24uIEl0J3MgY2xvc2VyIHRvIHRoZSBiZWhhdmlvciB3ZVxuLy8gd2FudCwgYnV0IGlzIGxpa2VsaWVyIHRvIGluY2x1ZGUgYWNjaWRlbnRhbCByZWdyZXNzaW9ucyBiZWNhdXNlIGl0IHJld3JpdGVzXG4vLyBleGlzdGluZyBmdW5jdGlvbmFsaXR5LlxuZnVuY3Rpb24gbmF2aWdhdGVSZWR1Y2VyX1BQUihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyB1cmwsIGlzRXh0ZXJuYWxVcmwsIG5hdmlnYXRlVHlwZSwgc2hvdWxkU2Nyb2xsIH0gPSBhY3Rpb247XG4gICAgY29uc3QgbXV0YWJsZSA9IHt9O1xuICAgIGNvbnN0IHsgaGFzaCB9ID0gdXJsO1xuICAgIGNvbnN0IGhyZWYgPSAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKSh1cmwpO1xuICAgIGNvbnN0IHBlbmRpbmdQdXNoID0gbmF2aWdhdGVUeXBlID09PSBcInB1c2hcIjtcbiAgICAvLyB3ZSB3YW50IHRvIHBydW5lIHRoZSBwcmVmZXRjaCBjYWNoZSBvbiBldmVyeSBuYXZpZ2F0aW9uIHRvIGF2b2lkIGl0IGdyb3dpbmcgdG9vIGxhcmdlXG4gICAgKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMucHJ1bmVQcmVmZXRjaENhY2hlKShzdGF0ZS5wcmVmZXRjaENhY2hlKTtcbiAgICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgaWYgKGlzRXh0ZXJuYWxVcmwpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwudG9TdHJpbmcoKSwgcGVuZGluZ1B1c2gpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmZXRjaFZhbHVlcyA9ICgwLCBfcHJlZmV0Y2hjYWNoZXV0aWxzLmdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICAgICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICAgICAgYnVpbGRJZDogc3RhdGUuYnVpbGRJZCxcbiAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZVxuICAgIH0pO1xuICAgIGNvbnN0IHsgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIGRhdGEgfSA9IHByZWZldGNoVmFsdWVzO1xuICAgIF9wcmVmZXRjaHJlZHVjZXIucHJlZmV0Y2hRdWV1ZS5idW1wKGRhdGEpO1xuICAgIHJldHVybiBkYXRhLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICBsZXQgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlLCBfcG9zdHBvbmVkXSA9IHBhcmFtO1xuICAgICAgICBsZXQgaXNGaXJzdFJlYWQgPSBmYWxzZTtcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIG1hcmsgdGhpcyBvbmNlXG4gICAgICAgIGlmICghcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lKSB7XG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IHdlIHNob3VsZCBvbmx5IG1hcmsgdGhlIGNhY2hlIG5vZGUgYXMgZGlydHkgYWZ0ZXIgd2UgdW5zdXNwZW5kIGZyb20gdGhlIGNhbGwgYWJvdmVcbiAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpc0ZpcnN0UmVhZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIGA8bWV0YSBodHRwLWVxdWl2PVwicmVmcmVzaFwiPmAgdGFnIGlzIHByZXNlbnQsXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX19uZXh0LXBhZ2UtcmVkaXJlY3RcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgICAgIGxldCBjdXJyZW50Q2FjaGUgPSBzdGF0ZS5jYWNoZTtcbiAgICAgICAgbGV0IHNjcm9sbGFibGVTZWdtZW50cyA9IFtdO1xuICAgICAgICAvLyBUT0RPOiBJbiBwcmFjdGljZSwgdGhpcyBpcyBhbHdheXMgYSBzaW5nbGUgaXRlbSBhcnJheS4gV2UgcHJvYmFibHlcbiAgICAgICAgLy8gYXJlbid0IGdvaW5nIHRvIGV2ZXJ5IHNlbmQgbXVsdGlwbGUgc2VnbWVudHMsIGF0IGxlYXN0IG5vdCBpbiB0aGlzXG4gICAgICAgIC8vIGZvcm1hdC4gU28gd2UgY291bGQgcmVtb3ZlIHRoZSBleHRyYSB3cmFwcGVyIGZvciBub3cgdW50aWxcbiAgICAgICAgLy8gdGhhdCBzZXR0bGVzLlxuICAgICAgICBmb3IgKGNvbnN0IGZsaWdodERhdGFQYXRoIG9mIGZsaWdodERhdGEpe1xuICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICBjb25zdCB0cmVlUGF0Y2ggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgtMylbMF07XG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkgPSBbXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICAgICAgbGV0IG5ld1RyZWUgPSAoMCwgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSwgY3VycmVudFRyZWUsIHRyZWVQYXRjaCwgaHJlZik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJlZSBwYXRjaCBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHRyZWUgdGhlbiB3ZSB1c2UgdGhlIHRyZWUgYXQgdGltZSBvZiBwcmVmZXRjaFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IFRoaXMgc2hvdWxkIGluc3RlYWQgZmlsbCBpbiB0aGUgbWlzc2luZyBwaWVjZXMgaW4gYGN1cnJlbnRUcmVlYCB3aXRoIHRoZSBkYXRhIGZyb20gYHRyZWVBdFRpbWVPZlByZWZldGNoYCwgdGhlbiBhcHBseSB0aGUgcGF0Y2guXG4gICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld1RyZWUgPSAoMCwgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksIHRyZWVBdFRpbWVPZlByZWZldGNoLCB0cmVlUGF0Y2gsIGhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KShjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIGlzIGp1c3QgYSBwYXJhbm9pZCBjaGVjay4gV2hlbiBQUFIgaXMgZW5hYmxlZCwgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYWx3YXlzIHNlbmQgYmFjayBhIHN0YXRpYyByZXNwb25zZSB0aGF0J3MgcmVuZGVyZWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHRoZSByb290LiBJZiBmb3Igc29tZSByZWFzb24gaXQgZG9lc24ndCwgd2UgZmFsbCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5vbi1QUFIgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlIGVsc2UgYnJhbmNoIGFuZCBkbyBhbGwgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB2aWEgdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uLiBUaGUgY3VycmVudCBzdHJ1Y3R1cmUgaXMganVzdFxuICAgICAgICAgICAgICAgIC8vIGFuIGluY3JlbWVudGFsIHN0ZXAuXG4gICAgICAgICAgICAgICAgZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZldGNoZWRUcmVlID0gZmxpZ2h0RGF0YVBhdGhbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZWREYXRhID0gZmxpZ2h0RGF0YVBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBmbGlnaHREYXRhUGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9ICgwLCBfcHBybmF2aWdhdGlvbnMudXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKShjdXJyZW50Q2FjaGUsIGN1cnJlbnRUcmVlLCBwcmVmZXRjaGVkVHJlZSwgc2VlZERhdGEsIGhlYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFzayAhPT0gbnVsbCAmJiB0YXNrLm5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGNyZWF0ZWQgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIHRoYXQgY29udGFpbnMgYSBwcmVmZXRjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9uIG9mIHRoZSBuZXh0IHBhZ2UuIFRoaXMgY2FuIGJlIHJlbmRlcmVkIGluc3RhbnRseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgdHJlZSBjb21wdXRlZCBieSB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24gaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIG9uZSBjb21wdXRlZCBieSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgcmVtb3ZlIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgUFBSIHBhdGggZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkUm91dGVyU3RhdGUgPSB0YXNrLnJvdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJlZSA9IHBhdGNoZWRSb3V0ZXJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gdGFzay5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZWZldGNoZWQgdHJlZSBoYXMgZHluYW1pYyBob2xlcyBpbiBpdC4gV2UgaW5pdGlhdGUgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyByZXF1ZXN0IHRvIGZpbGwgdGhlbSBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYmxvY2sgb24gdGhlIHJlc3VsdC4gV2UnbGwgaW1tZWRpYXRlbHkgcmVuZGVyIHRoZSBDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSB0cmVlIGFuZCBzdXNwZW5kIG9uIHRoZSBkeW5hbWljIHBhcnRzLiBXaGVuIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21lcyBpbiwgd2UnbGwgZmlsbCBpbiBtaXNzaW5nIGRhdGEgYW5kIHBpbmcgUmVhY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLXJlbmRlci4gVW5saWtlIHRoZSBsYXp5IGZldGNoaW5nIG1vZGVsIGluIHRoZSBub24tUFBSXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgdGhpcyBpcyBtb2RlbGVkIGFzIGEgc2luZ2xlIFJlYWN0IHVwZGF0ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJlYW1pbmcsIHJhdGhlciB0aGFuIG11bHRpcGxlIHRvcC1sZXZlbCB1cGRhdGVzLiAoSG93ZXZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gdGhlIG5ldyBtb2RlbCwgd2UnbGwgc3RpbGwgbmVlZCB0byBzb21ldGltZXMgdXBkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm9vdCBtdWx0aXBsZSB0aW1lcyBwZXIgbmF2aWdhdGlvbiwgbGlrZSBpZiB0aGUgc2VydmVyIHNlbmRzIHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGRpZmZlcmVudCByZXNwb25zZSB0aGFuIHdlIGV4cGVjdGVkLiBGb3Igbm93LCB3ZSByZXZlcnQgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIGxhenkgZmV0Y2hpbmcgbWVjaGFuaXNtIGluIHRoYXQgY2FzZS4pXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3Bwcm5hdmlnYXRpb25zLmxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KSh0YXNrLCAoMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkodXJsLCBjdXJyZW50VHJlZSwgc3RhdGUubmV4dFVybCwgc3RhdGUuYnVpbGRJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IG5ld0NhY2hlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBzbyByZXVzZSB0aGUgb2xkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB0aGUgaGVhZCBjaGFuZ2VkIGJ1dCBub3QgYW55IG9mIHRoZSBzZWdtZW50IGRhdGE/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGF0IHBvc3NpYmxlPyBJZiBzbywgd2Ugc2hvdWxkIGNsb25lIHRoZSB3aG9sZSB0cmVlIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJlZSA9IHByZWZldGNoZWRUcmVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHN0YXRpYyByZXNwb25zZSBkb2VzIG5vdCBpbmNsdWRlIGFueSBkeW5hbWljIGhvbGVzLCBzb1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gZG8gYSBzZWNvbmQgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQXMgYW4gaW5jcmVtZW50YWwgc3RlcCB0aGlzIGp1c3QgcmV2ZXJ0cyBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBub24tUFBSIGltcGxlbWVudGF0aW9uLiBXZSBjYW4gc2ltcGxpZnkgdGhpcyBicmFuY2ggZnVydGhlcixcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZW4gdGhhdCBQUFIgcHJlZmV0Y2hlcyBhcmUgYWx3YXlzIHN0YXRpYyBhbmQgcmV0dXJuIHRoZSB3aG9sZVxuICAgICAgICAgICAgICAgICAgICAvLyB0cmVlLiBPciBpbiB0aGUgbWVhbnRpbWUgd2UgY291bGQgZmFjdG9yIGl0IG91dCBpbnRvIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gKDAsIF9hcHByb3V0ZXIuY3JlYXRlRW1wdHlDYWNoZU5vZGUpKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcHBsaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaFZhbHVlcy5zdGF0dXMgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlICYmICFpc0ZpcnN0UmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIGEgc3RhbGUgcHJlZmV0Y2ggZW50cnksIHdlIG9ubHkgd2FudCB0byByZS11c2UgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhlIHJvdXRlIHdlJ3JlIG5hdmlnYXRpbmcgdG8sIHRvIHN1cHBvcnQgaW5zdGFudCBsb2FkaW5nIG5hdmlnYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZm9yIHRoZSBhY3R1YWwgcGFnZSBkYXRhIGJ5IG51bGxpbmcgdGhlIGByc2NgIGFuZCBgcHJlZmV0Y2hSc2NgIHZhbHVlcyBmb3IgcGFnZSBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpbGUgY29weWluZyBvdmVyIHRoZSBgbG9hZGluZ2AgZm9yIHRoZSBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIHBhZ2UgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiBzdWJzZXF1ZW50IHJlYWRzLCBhcyBvdGhlcndpc2UgdGhlcmUnZCBiZSBubyBsb2FkaW5nIGRhdGEgdG8gcmUtdXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZCA9IHRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMoY2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSByZS11c2VkIHRoZSBzdGFsZSBjYWNoZSdzIGxvYWRpbmcgc3RhdGUgJiByZWZyZXNoZWQgdGhlIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGBsYXN0VXNlZFRpbWVgIHNvIHRoYXQgaXQgY2FuIGNvbnRpbnVlIHRvIGJlIHJlLXVzZWQgZm9yIHRoZSBuZXh0IDMwc1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQgPSAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKGN1cnJlbnRDYWNoZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoLCBwcmVmZXRjaFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gKDAsIF9zaG91bGRoYXJkbmF2aWdhdGUuc2hvdWxkSGFyZE5hdmlnYXRlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSwgY3VycmVudFRyZWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFyZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBjdXJyZW50Q2FjaGUucHJlZmV0Y2hSc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2ludmFsaWRhdGVjYWNoZWJlbG93ZmxpZ2h0c2VnbWVudHBhdGguaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCkoY2FjaGUsIGN1cnJlbnRDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBleGlzdGluZyBjYWNoZSB2YWx1ZSBpcyB1c2VkIHdoZW4gdGhlIGNhY2hlIHdhcyBub3QgaW52YWxpZGF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXBwbGllZCB0aGUgY2FjaGUsIHdlIHVwZGF0ZSB0aGUgXCJjdXJyZW50IGNhY2hlXCIgdmFsdWUgc28gYW55IG90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBpbiB0aGUgRmxpZ2h0RGF0YVBhdGggd2lsbCBiZSBhYmxlIHRvIHJlZmVyZW5jZSB0aGUgdXBkYXRlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdWJTZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIF9fREVGQVVMVF9fIHBhdGhzIGFzIHRoZXkgc2hvdWxkbid0IGJlIHNjcm9sbGVkIHRvIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVTZWdtZW50UGF0aFtzY3JvbGxhYmxlU2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gIT09IF9zZWdtZW50LkRFRkFVTFRfU0VHTUVOVF9LRVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50cy5wdXNoKHNjcm9sbGFibGVTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IGN1cnJlbnRUcmVlO1xuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogaHJlZjtcbiAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHNjcm9sbGFibGVTZWdtZW50cztcbiAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSBoYXNoO1xuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbDtcbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKCk9PnN0YXRlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGUtcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsIm5hdmlnYXRlUmVkdWNlciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwicmVxdWlyZSIsIl9jcmVhdGVocmVmZnJvbXVybCIsIl9pbnZhbGlkYXRlY2FjaGViZWxvd2ZsaWdodHNlZ21lbnRwYXRoIiwiX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSIsIl9zaG91bGRoYXJkbmF2aWdhdGUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX3JvdXRlcnJlZHVjZXJ0eXBlcyIsIl9oYW5kbGVtdXRhYmxlIiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsIl9wcmVmZXRjaHJlZHVjZXIiLCJfYXBwcm91dGVyIiwiX3NlZ21lbnQiLCJfcHBybmF2aWdhdGlvbnMiLCJfcHJlZmV0Y2hjYWNoZXV0aWxzIiwiX2NsZWFyY2FjaGVub2RlZGF0YWZvcnNlZ21lbnRwYXRoIiwic3RhdGUiLCJtdXRhYmxlIiwidXJsIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiY2Fub25pY2FsVXJsIiwic2Nyb2xsYWJsZVNlZ21lbnRzIiwidW5kZWZpbmVkIiwiaGFuZGxlTXV0YWJsZSIsImdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2giLCJmbGlnaHRSb3V0ZXJQYXRjaCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJwYXJhbGxlbFJvdXRlIiwiZW50cmllcyIsImNoaWxkU2VnbWVudCIsInB1c2giLCJ0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzIiwibmV3Q2FjaGUiLCJjdXJyZW50Q2FjaGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsImFwcGxpZWRQYXRjaCIsInJzYyIsInByZWZldGNoUnNjIiwibG9hZGluZyIsIk1hcCIsInNlZ21lbnRQYXRoc1RvRmlsbCIsIm1hcCIsInNlZ21lbnRQYXRocyIsImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9QUFIiLCJuYXZpZ2F0ZVJlZHVjZXJfUFBSIiwibmF2aWdhdGVSZWR1Y2VyX25vUFBSIiwiYWN0aW9uIiwiaXNFeHRlcm5hbFVybCIsIm5hdmlnYXRlVHlwZSIsInNob3VsZFNjcm9sbCIsImhhc2giLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJ0b1N0cmluZyIsInByZWZldGNoVmFsdWVzIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwidHJlZSIsImJ1aWxkSWQiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsImRhdGEiLCJwcmVmZXRjaFF1ZXVlIiwiYnVtcCIsInRoZW4iLCJwYXJhbSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImlzRmlyc3RSZWFkIiwibGFzdFVzZWRUaW1lIiwiRGF0ZSIsIm5vdyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjdXJyZW50VHJlZSIsImNhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJzbGljZSIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImFwcGxpZWQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJzdGFsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhcmROYXZpZ2F0ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJzdWJTZWdtZW50Iiwic2Nyb2xsYWJsZVNlZ21lbnRQYXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInBhdGNoZWRUcmVlIiwiaGFzaEZyYWdtZW50IiwiX3Bvc3Rwb25lZCIsInByZWZldGNoZWRUcmVlIiwic2VlZERhdGEiLCJoZWFkIiwidGFzayIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsIm5vZGUiLCJwYXRjaGVkUm91dGVyU3RhdGUiLCJyb3V0ZSIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7447\n");

/***/ }),

/***/ 7990:
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ 7700);\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ 2126);\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ 4614);\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nfunction prefetchReducer(state, action) {\n    // let's prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    url.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        buildId: state.buildId\n    });\n    return state;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk5MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sb0JBQW9CQyxtQkFBT0EsQ0FBQyxvQ0FBMEI7QUFDNUQsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQywrQkFBcUI7QUFDbkQsTUFBTUUsc0JBQXNCRixtQkFBT0EsQ0FBQyxtQ0FBeUI7QUFDN0QsTUFBTVQsZ0JBQWdCLElBQUlVLGNBQWNFLFlBQVksQ0FBQztBQUNyRCxTQUFTWCxnQkFBZ0JZLEtBQUssRUFBRUMsTUFBTTtJQUNsQyw0REFBNEQ7SUFDM0QsSUFBR0gsb0JBQW9CSSxrQkFBa0IsRUFBRUYsTUFBTUcsYUFBYTtJQUMvRCxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHSDtJQUNoQkcsSUFBSUMsWUFBWSxDQUFDQyxNQUFNLENBQUNYLGtCQUFrQlksb0JBQW9CO0lBQzdELElBQUdULG9CQUFvQlUsNkJBQTZCLEVBQUU7UUFDbkRKO1FBQ0FLLFNBQVNULE1BQU1TLE9BQU87UUFDdEJOLGVBQWVILE1BQU1HLGFBQWE7UUFDbENPLE1BQU1ULE9BQU9TLElBQUk7UUFDakJDLE1BQU1YLE1BQU1XLElBQUk7UUFDaEJDLFNBQVNaLE1BQU1ZLE9BQU87SUFDMUI7SUFDQSxPQUFPWjtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9oQixRQUFRNkIsT0FBTyxLQUFLLGNBQWUsT0FBTzdCLFFBQVE2QixPQUFPLEtBQUssWUFBWTdCLFFBQVE2QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU83QixRQUFRNkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTZCLE9BQU8sRUFBRSxjQUFjO1FBQUU1QixPQUFPO0lBQUs7SUFDbkVILE9BQU9pQyxNQUFNLENBQUMvQixRQUFRNkIsT0FBTyxFQUFFN0I7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUTZCLE9BQU87QUFDbEMsRUFFQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLmpzPzNiM2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwcmVmZXRjaFF1ZXVlOiBudWxsLFxuICAgIHByZWZldGNoUmVkdWNlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBwcmVmZXRjaFF1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByZWZldGNoUXVldWU7XG4gICAgfSxcbiAgICBwcmVmZXRjaFJlZHVjZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJlZmV0Y2hSZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX2FwcHJvdXRlcmhlYWRlcnMgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlci1oZWFkZXJzXCIpO1xuY29uc3QgX3Byb21pc2VxdWV1ZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm9taXNlLXF1ZXVlXCIpO1xuY29uc3QgX3ByZWZldGNoY2FjaGV1dGlscyA9IHJlcXVpcmUoXCIuLi9wcmVmZXRjaC1jYWNoZS11dGlsc1wiKTtcbmNvbnN0IHByZWZldGNoUXVldWUgPSBuZXcgX3Byb21pc2VxdWV1ZS5Qcm9taXNlUXVldWUoNSk7XG5mdW5jdGlvbiBwcmVmZXRjaFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIC8vIGxldCdzIHBydW5lIHRoZSBwcmVmZXRjaCBjYWNoZSBiZWZvcmUgd2UgZG8gYW55dGhpbmcgZWxzZVxuICAgICgwLCBfcHJlZmV0Y2hjYWNoZXV0aWxzLnBydW5lUHJlZmV0Y2hDYWNoZSkoc3RhdGUucHJlZmV0Y2hDYWNoZSk7XG4gICAgY29uc3QgeyB1cmwgfSA9IGFjdGlvbjtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShfYXBwcm91dGVyaGVhZGVycy5ORVhUX1JTQ19VTklPTl9RVUVSWSk7XG4gICAgKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMuZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkpKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICBraW5kOiBhY3Rpb24ua2luZCxcbiAgICAgICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICAgICAgYnVpbGRJZDogc3RhdGUuYnVpbGRJZFxuICAgIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZmV0Y2gtcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJwcmVmZXRjaFF1ZXVlIiwicHJlZmV0Y2hSZWR1Y2VyIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FwcHJvdXRlcmhlYWRlcnMiLCJyZXF1aXJlIiwiX3Byb21pc2VxdWV1ZSIsIl9wcmVmZXRjaGNhY2hldXRpbHMiLCJQcm9taXNlUXVldWUiLCJzdGF0ZSIsImFjdGlvbiIsInBydW5lUHJlZmV0Y2hDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwibmV4dFVybCIsImtpbmQiLCJ0cmVlIiwiYnVpbGRJZCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7990\n");

/***/ }),

/***/ 6425:
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"refreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ 882);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 5471);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 2074);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 1619);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 7447);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 7138);\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ 9839);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 3642);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 1514);\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ 6708);\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ 6363);\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        currentTree[0],\n        currentTree[1],\n        currentTree[2],\n        \"refetch\"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then(async (param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log(\"REFRESH FAILED\");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                \"\"\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[2];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                mutable.prefetchCache = new Map();\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RFLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1FLE9BQU8sRUFBRSxjQUFjO1FBQUVsRSxPQUFPO0lBQUs7SUFDbkVILE9BQU91RSxNQUFNLENBQUNyRSxRQUFRbUUsT0FBTyxFQUFFbkU7SUFDL0JzRSxPQUFPdEUsT0FBTyxHQUFHQSxRQUFRbUUsT0FBTztBQUNsQyxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci5qcz8yOTNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVmcmVzaFJlZHVjZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlZnJlc2hSZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX2NyZWF0ZWhyZWZmcm9tdXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xuY29uc3QgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSA9IHJlcXVpcmUoXCIuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZVwiKTtcbmNvbnN0IF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQgPSByZXF1aXJlKFwiLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXRcIik7XG5jb25zdCBfbmF2aWdhdGVyZWR1Y2VyID0gcmVxdWlyZShcIi4vbmF2aWdhdGUtcmVkdWNlclwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkID0gcmVxdWlyZShcIi4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuY29uc3QgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaFwiKTtcbmNvbnN0IF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUgPSByZXF1aXJlKFwiLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZVwiKTtcbmNvbnN0IF9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHNcIik7XG5mdW5jdGlvbiByZWZyZXNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvbjtcbiAgICBjb25zdCBtdXRhYmxlID0ge307XG4gICAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybDtcbiAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlO1xuICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICAgIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gKDAsIF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUuaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKShzdGF0ZS50cmVlKTtcbiAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gICAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgIGNhY2hlLmxhenlEYXRhID0gKDAsIF9mZXRjaHNlcnZlcnJlc3BvbnNlLmZldGNoU2VydmVyUmVzcG9uc2UpKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwgW1xuICAgICAgICBjdXJyZW50VHJlZVswXSxcbiAgICAgICAgY3VycmVudFRyZWVbMV0sXG4gICAgICAgIGN1cnJlbnRUcmVlWzJdLFxuICAgICAgICBcInJlZmV0Y2hcIlxuICAgIF0sIGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsIHN0YXRlLmJ1aWxkSWQpO1xuICAgIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKGFzeW5jIChwYXJhbSk9PntcbiAgICAgICAgbGV0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSBwYXJhbTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVyZWR1Y2VyLmhhbmRsZUV4dGVybmFsVXJsKShzdGF0ZSwgbXV0YWJsZSwgZmxpZ2h0RGF0YSwgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKXtcbiAgICAgICAgICAgIC8vIEZsaWdodERhdGFQYXRoIHdpdGggbW9yZSB0aGFuIHR3byBpdGVtcyBtZWFucyB1bmV4cGVjdGVkIEZsaWdodCBkYXRhIHdhcyByZXR1cm5lZFxuICAgICAgICAgICAgaWYgKGZsaWdodERhdGFQYXRoLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVGUkVTSCBGQUlMRURcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2l2ZW4gdGhlIHBhdGggY2FuIG9ubHkgaGF2ZSB0d28gaXRlbXMgdGhlIGl0ZW1zIGFyZSBvbmx5IHRoZSByb3V0ZXIgc3RhdGUgYW5kIHJzYyBmb3IgdGhlIHJvb3QuXG4gICAgICAgICAgICBjb25zdCBbdHJlZVBhdGNoXSA9IGZsaWdodERhdGFQYXRoO1xuICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgIF0sIGN1cnJlbnRUcmVlLCB0cmVlUGF0Y2gsIHN0YXRlLmNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaC5oYW5kbGVTZWdtZW50TWlzbWF0Y2gpKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KShjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICBjb25zdCBbY2FjaGVOb2RlU2VlZERhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTIpO1xuICAgICAgICAgICAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIHByZWZldGNoIG9ubHkgcmV0dXJucyB0aGUgcm91dGVyIHRyZWUgcGF0Y2ggd2l0aG91dCByZW5kZXJlZCBjb21wb25lbnRzLlxuICAgICAgICAgICAgaWYgKGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMl07XG4gICAgICAgICAgICAgICAgY2FjaGUucnNjID0gcnNjO1xuICAgICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICAoMCwgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKShjYWNoZSwgLy8gRXhpc3RpbmcgY2FjaGUgaXMgbm90IHBhc3NlZCBpbiBhcyBgcm91dGVyLnJlZnJlc2goKWAgaGFzIHRvIGludmFsaWRhdGUgdGhlIGVudGlyZSBjYWNoZS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHRyZWVQYXRjaCwgY2FjaGVOb2RlU2VlZERhdGEsIGhlYWQpO1xuICAgICAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCBfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cy5yZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzKSh7XG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdXBkYXRlZFRyZWU6IG5ld1RyZWUsXG4gICAgICAgICAgICAgICAgdXBkYXRlZENhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlTmV4dFVybCxcbiAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsIHx8IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gaHJlZjtcbiAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIF9oYW5kbGVtdXRhYmxlLmhhbmRsZU11dGFibGUpKHN0YXRlLCBtdXRhYmxlKTtcbiAgICB9LCAoKT0+c3RhdGUpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZyZXNoLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInJlZnJlc2hSZWR1Y2VyIiwiX2ZldGNoc2VydmVycmVzcG9uc2UiLCJyZXF1aXJlIiwiX2NyZWF0ZWhyZWZmcm9tdXJsIiwiX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSIsIl9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQiLCJfbmF2aWdhdGVyZWR1Y2VyIiwiX2hhbmRsZW11dGFibGUiLCJfZmlsbGxhenlpdGVtc3RpbGxsZWFmd2l0aGhlYWQiLCJfYXBwcm91dGVyIiwiX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCIsIl9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUiLCJfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyIsInN0YXRlIiwiYWN0aW9uIiwib3JpZ2luIiwibXV0YWJsZSIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJjdXJyZW50VHJlZSIsInRyZWUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsInBhcmFtIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJmbGlnaHREYXRhUGF0aCIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJ0cmVlUGF0Y2giLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJzbGljZSIsInJzYyIsInByZWZldGNoUnNjIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6425\n");

/***/ }),

/***/ 7145:
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"restoreReducer\", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 5471);\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ 9314);\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ 3176);\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        buildId: state.buildId,\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMscUJBQXFCQyxtQkFBT0EsQ0FBQyxtQ0FBeUI7QUFDNUQsTUFBTUMsc0JBQXNCRCxtQkFBT0EsQ0FBQyxtQ0FBeUI7QUFDN0QsTUFBTUUsa0JBQWtCRixtQkFBT0EsQ0FBQyw4QkFBb0I7QUFDcEQsU0FBU0YsZUFBZUssS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUUsR0FBR0Y7SUFDdEIsTUFBTUcsT0FBTyxDQUFDLEdBQUdSLG1CQUFtQlMsaUJBQWlCLEVBQUVIO0lBQ3ZELDBFQUEwRTtJQUMxRSw0RkFBNEY7SUFDNUYsZ0dBQWdHO0lBQ2hHLDZGQUE2RjtJQUM3Riw4REFBOEQ7SUFDOUQseUdBQXlHO0lBQ3pHLE1BQU1JLGdCQUFnQkgsUUFBUUgsTUFBTUcsSUFBSTtJQUN4QyxNQUFNSSxXQUFXUCxNQUFNUSxLQUFLO0lBQzVCLE1BQU1DLFdBQVdDLE1BQXNCLEdBR3ZDLDJEQUYyRDtJQUMzRCwyQkFBMkI7SUFDMUIsQ0FBaUZKLEdBQUdDO0lBQ3JGLElBQUlPO0lBQ0osT0FBTztRQUNIQyxTQUFTZixNQUFNZSxPQUFPO1FBQ3RCLG9CQUFvQjtRQUNwQkMsY0FBY1o7UUFDZGEsU0FBUztZQUNMQyxhQUFhO1lBQ2JDLGVBQWU7WUFDZiw2RkFBNkY7WUFDN0ZDLDRCQUE0QjtRQUNoQztRQUNBQyxtQkFBbUJyQixNQUFNcUIsaUJBQWlCO1FBQzFDYixPQUFPQztRQUNQYSxlQUFldEIsTUFBTXNCLGFBQWE7UUFDbEMsd0JBQXdCO1FBQ3hCbkIsTUFBTUc7UUFDTmlCLFNBQVMsQ0FBQ1Qsb0NBQW9DLENBQUMsR0FBR2hCLG9CQUFvQjBCLGdDQUFnQyxFQUFFbEIsY0FBYSxLQUFNLE9BQU9RLG9DQUFvQ1osSUFBSXVCLFFBQVE7SUFDdEw7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPbEMsUUFBUW1DLE9BQU8sS0FBSyxjQUFlLE9BQU9uQyxRQUFRbUMsT0FBTyxLQUFLLFlBQVluQyxRQUFRbUMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkMsUUFBUW1DLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFtQyxPQUFPLEVBQUUsY0FBYztRQUFFbEMsT0FBTztJQUFLO0lBQ25FSCxPQUFPdUMsTUFBTSxDQUFDckMsUUFBUW1DLE9BQU8sRUFBRW5DO0lBQy9Cc0MsT0FBT3RDLE9BQU8sR0FBR0EsUUFBUW1DLE9BQU87QUFDbEMsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXIuanM/NzkzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc3RvcmVSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXN0b3JlUmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVocmVmZnJvbXVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9jb21wdXRlY2hhbmdlZHBhdGggPSByZXF1aXJlKFwiLi4vY29tcHV0ZS1jaGFuZ2VkLXBhdGhcIik7XG5jb25zdCBfcHBybmF2aWdhdGlvbnMgPSByZXF1aXJlKFwiLi4vcHByLW5hdmlnYXRpb25zXCIpO1xuZnVuY3Rpb24gcmVzdG9yZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHsgdXJsLCB0cmVlIH0gPSBhY3Rpb247XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHVybCk7XG4gICAgLy8gVGhpcyBhY3Rpb24gaXMgdXNlZCB0byByZXN0b3JlIHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICAvLyBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIHRoZSBgRmxpZ2h0Um91dGVyU3RhdGVgLlxuICAgIC8vIFdlIHdpbGwgY29weSBvdmVyIHRoZSBpbnRlcm5hbCBzdGF0ZSBvbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGV2ZW50cywgYnV0IGlmIGEgaGlzdG9yeSBlbnRyeVxuICAgIC8vIG9jY3VycmVkIGJlZm9yZSBoeWRyYXRpb24sIG9yIGlmIHRoZSB1c2VyIG5hdmlnYXRlZCB0byBhIGhhc2ggdXNpbmcgYSByZWd1bGFyIGFuY2hvciBsaW5rLFxuICAgIC8vIHRoZSBoaXN0b3J5IHN0YXRlIHdpbGwgbm90IGNvbnRhaW4gdGhlIGBGbGlnaHRSb3V0ZXJTdGF0ZWAuXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSdsbCBjb250aW51ZSB0byB1c2UgdGhlIGV4aXN0aW5nIHRyZWUgc28gdGhlIHJvdXRlciBkb2Vzbid0IGdldCBpbnRvIGFuIGludmFsaWQgc3RhdGUuXG4gICAgY29uc3QgdHJlZVRvUmVzdG9yZSA9IHRyZWUgfHwgc3RhdGUudHJlZTtcbiAgICBjb25zdCBvbGRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgIGNvbnN0IG5ld0NhY2hlID0gcHJvY2Vzcy5lbnYuX19ORVhUX1BQUiA/IC8vIGRhdGEgZm9yIGFueSBzZWdtZW50IHdob3NlIGR5bmFtaWMgZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFuIHVubmVjZXNzYXJ5IGZsYXNoIGJhY2sgdG8gUFBSIHN0YXRlIGR1cmluZyBhXG4gICAgLy8gYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gICAgKDAsIF9wcHJuYXZpZ2F0aW9ucy51cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24pKG9sZENhY2hlLCB0cmVlVG9SZXN0b3JlKSA6IG9sZENhY2hlO1xuICAgIHZhciBfZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVpbGRJZDogc3RhdGUuYnVpbGRJZCxcbiAgICAgICAgLy8gU2V0IGNhbm9uaWNhbCB1cmxcbiAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgY3VzdG9tIGhpc3Rvcnkgc3RhdGUgdGhhdCB3YXMgc2V0IGlzIHByZXNlcnZlZCB3aGVuIGFwcGx5aW5nIHRoaXMgdXBkYXRlLlxuICAgICAgICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICBjYWNoZTogbmV3Q2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgICAgICB0cmVlOiB0cmVlVG9SZXN0b3JlLFxuICAgICAgICBuZXh0VXJsOiAoX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlID0gKDAsIF9jb21wdXRlY2hhbmdlZHBhdGguZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUpKHRyZWVUb1Jlc3RvcmUpKSAhPSBudWxsID8gX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIDogdXJsLnBhdGhuYW1lXG4gICAgfTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdG9yZS1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXN0b3JlUmVkdWNlciIsIl9jcmVhdGVocmVmZnJvbXVybCIsInJlcXVpcmUiLCJfY29tcHV0ZWNoYW5nZWRwYXRoIiwiX3Bwcm5hdmlnYXRpb25zIiwic3RhdGUiLCJhY3Rpb24iLCJ1cmwiLCJ0cmVlIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidHJlZVRvUmVzdG9yZSIsIm9sZENhY2hlIiwiY2FjaGUiLCJuZXdDYWNoZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUFBSIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiYnVpbGRJZCIsImNhbm9uaWNhbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwicHJlZmV0Y2hDYWNoZSIsIm5leHRVcmwiLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsInBhdGhuYW1lIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7145\n");

/***/ }),

/***/ 1131:
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverActionReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ 689);\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ 7700);\nconst _addbasepath = __webpack_require__(/*! ../../../add-base-path */ 9392);\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 5471);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 7447);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 2074);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 1619);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 7138);\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ 9839);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 3642);\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ 6708);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 1514);\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ 6363);\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, encodeReply } =  true ? __webpack_require__(/*! react-server-dom-webpack/client.edge */ 5032) : 0;\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const body = await encodeReply(actionArgs);\n    const res = await fetch(\"\", {\n        method: \"POST\",\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const location = res.headers.get(\"x-action-redirect\");\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get(\"x-action-revalidated\") || \"[[],0,0]\");\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? new URL((0, _addbasepath.addBasePath)(location), new URL(state.canonicalUrl, window.location.href)) : undefined;\n    let isFlightResponse = res.headers.get(\"content-type\") === _approuterheaders.RSC_CONTENT_TYPE_HEADER;\n    if (isFlightResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            const [, actionFlightData] = response != null ? response : [];\n            return {\n                actionFlightData: actionFlightData,\n                redirectLocation,\n                revalidatedParts\n            };\n        }\n        // otherwise it's a tuple of [actionResult, actionFlightData]\n        const [actionResult, [, actionFlightData]] = response != null ? response : [];\n        return {\n            actionResult,\n            actionFlightData,\n            redirectLocation,\n            revalidatedParts\n        };\n    }\n    return {\n        redirectLocation,\n        revalidatedParts\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action);\n    return mutable.inFlightServerAction.then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation } = param;\n        // Make sure the redirection is a push instead of a replace.\n        // Issue: https://github.com/vercel/next.js/issues/53911\n        if (redirectLocation) {\n            state.pushRef.pendingPush = true;\n            mutable.pendingPush = true;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === \"string\") {\n            // Handle case when navigating to page in `pages` from `app`\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.data as it has been resolved at this point.\n        mutable.inFlightServerAction = null;\n        if (redirectLocation) {\n            const newHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = newHref;\n        }\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log(\"SERVER ACTION APPLY FAILED\");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                \"\"\n            ], currentTree, treePatch, redirectLocation ? (0, _createhreffromurl.createHrefFromUrl)(redirectLocation) : state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null;\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (rsc !== null) {\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                    state,\n                    updatedTree: newTree,\n                    updatedCache: cache,\n                    includeNextUrl: Boolean(nextUrl),\n                    canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                });\n                mutable.cache = cache;\n                mutable.prefetchCache = new Map();\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        resolve(actionResult);\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TzRDO0lBQ3BELEdBQUcsQ0FBQ2pCO1FBQ0EsbUhBQW1IO1FBQ25IZ0IsT0FBT2hCO1FBQ1AsT0FBTzNCO0lBQ1g7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPekIsUUFBUTJHLE9BQU8sS0FBSyxjQUFlLE9BQU8zRyxRQUFRMkcsT0FBTyxLQUFLLFlBQVkzRyxRQUFRMkcsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPM0csUUFBUTJHLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks5RyxPQUFPQyxjQUFjLENBQUNDLFFBQVEyRyxPQUFPLEVBQUUsY0FBYztRQUFFMUcsT0FBTztJQUFLO0lBQ25FSCxPQUFPK0csTUFBTSxDQUFDN0csUUFBUTJHLE9BQU8sRUFBRTNHO0lBQy9COEcsT0FBTzlHLE9BQU8sR0FBR0EsUUFBUTJHLE9BQU87QUFDbEMsRUFFQSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItYWN0aW9uLXJlZHVjZXIuanM/MDYxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcnZlckFjdGlvblJlZHVjZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlckFjdGlvblJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfYXBwY2FsbHNlcnZlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9hcHAtY2FsbC1zZXJ2ZXJcIik7XG5jb25zdCBfYXBwcm91dGVyaGVhZGVycyA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyLWhlYWRlcnNcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vYWRkLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9jcmVhdGVocmVmZnJvbXVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9uYXZpZ2F0ZXJlZHVjZXIgPSByZXF1aXJlKFwiLi9uYXZpZ2F0ZS1yZWR1Y2VyXCIpO1xuY29uc3QgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSA9IHJlcXVpcmUoXCIuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZVwiKTtcbmNvbnN0IF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQgPSByZXF1aXJlKFwiLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXRcIik7XG5jb25zdCBfaGFuZGxlbXV0YWJsZSA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtbXV0YWJsZVwiKTtcbmNvbnN0IF9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZCA9IHJlcXVpcmUoXCIuLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbmNvbnN0IF9hcHByb3V0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlclwiKTtcbmNvbnN0IF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUgPSByZXF1aXJlKFwiLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZVwiKTtcbmNvbnN0IF9oYW5kbGVzZWdtZW50bWlzbWF0Y2ggPSByZXF1aXJlKFwiLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2hcIik7XG5jb25zdCBfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyA9IHJlcXVpcmUoXCIuLi9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzXCIpO1xuLy8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IHsgY3JlYXRlRnJvbUZldGNoIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbi8vIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbi8vIGltcG9ydCB7IGVuY29kZVJlcGx5IH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbmNvbnN0IHsgY3JlYXRlRnJvbUZldGNoLCBlbmNvZGVSZXBseSB9ID0gISFwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPyByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5lZGdlXCIpIDogcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnRcIik7XG5hc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZlckFjdGlvbihzdGF0ZSwgbmV4dFVybCwgcGFyYW0pIHtcbiAgICBsZXQgeyBhY3Rpb25JZCwgYWN0aW9uQXJncyB9ID0gcGFyYW07XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IGVuY29kZVJlcGx5KGFjdGlvbkFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFwiXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQWNjZXB0OiBfYXBwcm91dGVyaGVhZGVycy5SU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgICAgICAgICAgIFtfYXBwcm91dGVyaGVhZGVycy5BQ1RJT05dOiBhY3Rpb25JZCxcbiAgICAgICAgICAgIFtfYXBwcm91dGVyaGVhZGVycy5ORVhUX1JPVVRFUl9TVEFURV9UUkVFXTogZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpKSxcbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRCA/IHtcbiAgICAgICAgICAgICAgICBcIngtZGVwbG95bWVudC1pZFwiOiBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgIC4uLm5leHRVcmwgPyB7XG4gICAgICAgICAgICAgICAgW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfVVJMXTogbmV4dFVybFxuICAgICAgICAgICAgfSA6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGJvZHlcbiAgICB9KTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmdldChcIngtYWN0aW9uLXJlZGlyZWN0XCIpO1xuICAgIGxldCByZXZhbGlkYXRlZFBhcnRzO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldmFsaWRhdGVkSGVhZGVyID0gSlNPTi5wYXJzZShyZXMuaGVhZGVycy5nZXQoXCJ4LWFjdGlvbi1yZXZhbGlkYXRlZFwiKSB8fCBcIltbXSwwLDBdXCIpO1xuICAgICAgICByZXZhbGlkYXRlZFBhcnRzID0ge1xuICAgICAgICAgICAgcGF0aHM6IHJldmFsaWRhdGVkSGVhZGVyWzBdIHx8IFtdLFxuICAgICAgICAgICAgdGFnOiAhIXJldmFsaWRhdGVkSGVhZGVyWzFdLFxuICAgICAgICAgICAgY29va2llOiByZXZhbGlkYXRlZEhlYWRlclsyXVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyA9IHtcbiAgICAgICAgICAgIHBhdGhzOiBbXSxcbiAgICAgICAgICAgIHRhZzogZmFsc2UsXG4gICAgICAgICAgICBjb29raWU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0TG9jYXRpb24gPSBsb2NhdGlvbiA/IG5ldyBVUkwoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkobG9jYXRpb24pLCAvLyBFbnN1cmUgcmVsYXRpdmUgcmVkaXJlY3RzIGluIFNlcnZlciBBY3Rpb25zIHdvcmssIGUuZy4gcmVkaXJlY3QoJy4vc29tZXdoZXJlLWVsc2UnKVxuICAgIG5ldyBVUkwoc3RhdGUuY2Fub25pY2FsVXJsLCB3aW5kb3cubG9jYXRpb24uaHJlZikpIDogdW5kZWZpbmVkO1xuICAgIGxldCBpc0ZsaWdodFJlc3BvbnNlID0gcmVzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpID09PSBfYXBwcm91dGVyaGVhZGVycy5SU0NfQ09OVEVOVF9UWVBFX0hFQURFUjtcbiAgICBpZiAoaXNGbGlnaHRSZXNwb25zZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZUZyb21GZXRjaChQcm9taXNlLnJlc29sdmUocmVzKSwge1xuICAgICAgICAgICAgY2FsbFNlcnZlcjogX2FwcGNhbGxzZXJ2ZXIuY2FsbFNlcnZlclxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCB3YXMgYSByZWRpcmVjdGlvbiwgdGhlbiByZXN1bHQgaXMganVzdCBhIHJlZ3VsYXIgUlNDIHBheWxvYWRcbiAgICAgICAgICAgIGNvbnN0IFssIGFjdGlvbkZsaWdodERhdGFdID0gcmVzcG9uc2UgIT0gbnVsbCA/IHJlc3BvbnNlIDogW107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGlvbkZsaWdodERhdGE6IGFjdGlvbkZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlZFBhcnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGEgdHVwbGUgb2YgW2FjdGlvblJlc3VsdCwgYWN0aW9uRmxpZ2h0RGF0YV1cbiAgICAgICAgY29uc3QgW2FjdGlvblJlc3VsdCwgWywgYWN0aW9uRmxpZ2h0RGF0YV1dID0gcmVzcG9uc2UgIT0gbnVsbCA/IHJlc3BvbnNlIDogW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICAgICAgICBhY3Rpb25GbGlnaHREYXRhLFxuICAgICAgICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICAgIHJldmFsaWRhdGVkUGFydHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0c1xuICAgIH07XG59XG5mdW5jdGlvbiBzZXJ2ZXJBY3Rpb25SZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IG11dGFibGUgPSB7fTtcbiAgICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsO1xuICAgIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlO1xuICAgIC8vIG9ubHkgcGFzcyBhbG9uZyB0aGUgYG5leHRVcmxgIHBhcmFtICh1c2VkIGZvciBpbnRlcmNlcHRpb24gcm91dGVzKSBpZiB0aGUgY3VycmVudCByb3V0ZSB3YXMgaW50ZXJjZXB0ZWQuXG4gICAgLy8gSWYgdGhlIHJvdXRlIGhhcyBiZWVuIGludGVyY2VwdGVkLCB0aGUgYWN0aW9uIHNob3VsZCBiZSBhcyB3ZWxsLlxuICAgIC8vIE90aGVyd2lzZSB0aGUgc2VydmVyIGFjdGlvbiBtaWdodCBiZSBpbnRlcmNlcHRlZCB3aXRoIHRoZSB3cm9uZyBhY3Rpb24gaWRcbiAgICAvLyAoaWUsIG9uZSB0aGF0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGludGVyY2VwdGVkIHJvdXRlKVxuICAgIGNvbnN0IG5leHRVcmwgPSBzdGF0ZS5uZXh0VXJsICYmICgwLCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlLmhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSkoc3RhdGUudHJlZSkgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbDtcbiAgICBtdXRhYmxlLmluRmxpZ2h0U2VydmVyQWN0aW9uID0gZmV0Y2hTZXJ2ZXJBY3Rpb24oc3RhdGUsIG5leHRVcmwsIGFjdGlvbik7XG4gICAgcmV0dXJuIG11dGFibGUuaW5GbGlnaHRTZXJ2ZXJBY3Rpb24udGhlbihhc3luYyAocGFyYW0pPT57XG4gICAgICAgIGxldCB7IGFjdGlvblJlc3VsdCwgYWN0aW9uRmxpZ2h0RGF0YTogZmxpZ2h0RGF0YSwgcmVkaXJlY3RMb2NhdGlvbiB9ID0gcGFyYW07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcmVkaXJlY3Rpb24gaXMgYSBwdXNoIGluc3RlYWQgb2YgYSByZXBsYWNlLlxuICAgICAgICAvLyBJc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy81MzkxMVxuICAgICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCA9IHRydWU7XG4gICAgICAgICAgICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsaWdodERhdGEpIHtcbiAgICAgICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgYnV0IG5vIGZsaWdodCBkYXRhIHdlIG5lZWQgdG8gZG8gYSBtcGFOYXZpZ2F0aW9uLlxuICAgICAgICAgICAgaWYgKHJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCByZWRpcmVjdExvY2F0aW9uLmhyZWYsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgY2FjaGUuZGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICBtdXRhYmxlLmluRmxpZ2h0U2VydmVyQWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hyZWYgPSAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKShyZWRpcmVjdExvY2F0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IG5ld0hyZWY7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKXtcbiAgICAgICAgICAgIC8vIEZsaWdodERhdGFQYXRoIHdpdGggbW9yZSB0aGFuIHR3byBpdGVtcyBtZWFucyB1bmV4cGVjdGVkIEZsaWdodCBkYXRhIHdhcyByZXR1cm5lZFxuICAgICAgICAgICAgaWYgKGZsaWdodERhdGFQYXRoLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0VSVkVSIEFDVElPTiBBUFBMWSBGQUlMRURcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2l2ZW4gdGhlIHBhdGggY2FuIG9ubHkgaGF2ZSB0d28gaXRlbXMgdGhlIGl0ZW1zIGFyZSBvbmx5IHRoZSByb3V0ZXIgc3RhdGUgYW5kIHJzYyBmb3IgdGhlIHJvb3QuXG4gICAgICAgICAgICBjb25zdCBbdHJlZVBhdGNoXSA9IGZsaWdodERhdGFQYXRoO1xuICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgIF0sIGN1cnJlbnRUcmVlLCB0cmVlUGF0Y2gsIHJlZGlyZWN0TG9jYXRpb24gPyAoMCwgX2NyZWF0ZWhyZWZmcm9tdXJsLmNyZWF0ZUhyZWZGcm9tVXJsKShyZWRpcmVjdExvY2F0aW9uKSA6IHN0YXRlLmNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaC5oYW5kbGVTZWdtZW50TWlzbWF0Y2gpKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KShjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBvbmUgYmVmb3JlIGxhc3QgaXRlbSBpcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgcGF0Y2hcbiAgICAgICAgICAgIGNvbnN0IFtjYWNoZU5vZGVTZWVkRGF0YSwgaGVhZF0gPSBmbGlnaHREYXRhUGF0aC5zbGljZSgtMik7XG4gICAgICAgICAgICBjb25zdCByc2MgPSBjYWNoZU5vZGVTZWVkRGF0YSAhPT0gbnVsbCA/IGNhY2hlTm9kZVNlZWREYXRhWzJdIDogbnVsbDtcbiAgICAgICAgICAgIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgICAgICAgICAgIGlmIChyc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgICAgICAgICAgICAgIGNhY2hlLnJzYyA9IHJzYztcbiAgICAgICAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgKDAsIF9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZC5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCkoY2FjaGUsIC8vIEV4aXN0aW5nIGNhY2hlIGlzIG5vdCBwYXNzZWQgaW4gYXMgYHJvdXRlci5yZWZyZXNoKClgIGhhcyB0byBpbnZhbGlkYXRlIHRoZSBlbnRpcmUgY2FjaGUuXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB0cmVlUGF0Y2gsIGNhY2hlTm9kZVNlZWREYXRhLCBoZWFkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAoMCwgX3JlZmV0Y2hpbmFjdGl2ZXBhcmFsbGVsc2VnbWVudHMucmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cykoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFRyZWU6IG5ld1RyZWUsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVOZXh0VXJsOiBCb29sZWFuKG5leHRVcmwpLFxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsIHx8IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLnByZWZldGNoQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdCk7XG4gICAgICAgIHJldHVybiAoMCwgX2hhbmRsZW11dGFibGUuaGFuZGxlTXV0YWJsZSkoc3RhdGUsIG11dGFibGUpO1xuICAgIH0sIChlKT0+e1xuICAgICAgICAvLyBXaGVuIHRoZSBzZXJ2ZXIgYWN0aW9uIGlzIHJlamVjdGVkIHdlIGRvbid0IHVwZGF0ZSB0aGUgc3RhdGUgYW5kIGluc3RlYWQgY2FsbCB0aGUgcmVqZWN0IGhhbmRsZXIgb2YgdGhlIHByb21pc2UuXG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItYWN0aW9uLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInNlcnZlckFjdGlvblJlZHVjZXIiLCJfYXBwY2FsbHNlcnZlciIsInJlcXVpcmUiLCJfYXBwcm91dGVyaGVhZGVycyIsIl9hZGRiYXNlcGF0aCIsIl9jcmVhdGVocmVmZnJvbXVybCIsIl9uYXZpZ2F0ZXJlZHVjZXIiLCJfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlIiwiX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCIsIl9oYW5kbGVtdXRhYmxlIiwiX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkIiwiX2FwcHJvdXRlciIsIl9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUiLCJfaGFuZGxlc2VnbWVudG1pc21hdGNoIiwiX3JlZmV0Y2hpbmFjdGl2ZXBhcmFsbGVsc2VnbWVudHMiLCJjcmVhdGVGcm9tRmV0Y2giLCJlbmNvZGVSZXBseSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJmZXRjaFNlcnZlckFjdGlvbiIsInN0YXRlIiwibmV4dFVybCIsInBhcmFtIiwiYWN0aW9uSWQiLCJhY3Rpb25BcmdzIiwiYm9keSIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiQUNUSU9OIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmVlIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiTkVYVF9VUkwiLCJsb2NhdGlvbiIsInJldmFsaWRhdGVkUGFydHMiLCJyZXZhbGlkYXRlZEhlYWRlciIsInBhcnNlIiwicGF0aHMiLCJ0YWciLCJjb29raWUiLCJlIiwicmVkaXJlY3RMb2NhdGlvbiIsIlVSTCIsImFkZEJhc2VQYXRoIiwiY2Fub25pY2FsVXJsIiwid2luZG93IiwiaHJlZiIsInVuZGVmaW5lZCIsImlzRmxpZ2h0UmVzcG9uc2UiLCJyZXNwb25zZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2FsbFNlcnZlciIsImFjdGlvbkZsaWdodERhdGEiLCJhY3Rpb25SZXN1bHQiLCJhY3Rpb24iLCJyZWplY3QiLCJtdXRhYmxlIiwiY3VycmVudFRyZWUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImluRmxpZ2h0U2VydmVyQWN0aW9uIiwidGhlbiIsImZsaWdodERhdGEiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJoYW5kbGVFeHRlcm5hbFVybCIsIm5ld0hyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImZsaWdodERhdGFQYXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJzbGljZSIsInJzYyIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJwcmVmZXRjaFJzYyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwiaW5jbHVkZU5leHRVcmwiLCJCb29sZWFuIiwicHJlZmV0Y2hDYWNoZSIsIk1hcCIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1131\n");

/***/ }),

/***/ 6455:
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverPatchReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ 5471);\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ 2074);\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ 1619);\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ 7447);\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ 543);\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ 7138);\nconst _approuter = __webpack_require__(/*! ../../app-router */ 3642);\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ 1514);\nfunction serverPatchReducer(state, action) {\n    const { serverResponse } = action;\n    const [flightData, overrideCanonicalUrl] = serverResponse;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const flightDataPath of flightData){\n        // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n        const flightSegmentPath = flightDataPath.slice(0, -4);\n        const [treePatch] = flightDataPath.slice(-3, -2);\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            \"\",\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        if (newTree === null) {\n            return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = overrideCanonicalUrl ? (0, _createhreffromurl.createHrefFromUrl)(overrideCanonicalUrl) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVE0QyxPQUFPLEVBQUUsY0FBYztRQUFFM0MsT0FBTztJQUFLO0lBQ25FSCxPQUFPZ0QsTUFBTSxDQUFDOUMsUUFBUTRDLE9BQU8sRUFBRTVDO0lBQy9CK0MsT0FBTy9DLE9BQU8sR0FBR0EsUUFBUTRDLE9BQU87QUFDbEMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlci5qcz9kYWYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VydmVyUGF0Y2hSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJQYXRjaFJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG5jb25zdCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlID0gcmVxdWlyZShcIi4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlXCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbmNvbnN0IF9uYXZpZ2F0ZXJlZHVjZXIgPSByZXF1aXJlKFwiLi9uYXZpZ2F0ZS1yZWR1Y2VyXCIpO1xuY29uc3QgX2FwcGx5ZmxpZ2h0ZGF0YSA9IHJlcXVpcmUoXCIuLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuY29uc3QgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaFwiKTtcbmZ1bmN0aW9uIHNlcnZlclBhdGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBzZXJ2ZXJSZXNwb25zZSB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IFtmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybF0gPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICBjb25zdCBtdXRhYmxlID0ge307XG4gICAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlO1xuICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGU7XG4gICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKXtcbiAgICAgICAgLy8gU2xpY2VzIG9mZiB0aGUgbGFzdCBzZWdtZW50ICh3aGljaCBpcyBhdCAtNCkgYXMgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSB5ZXRcbiAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMsIC0yKTtcbiAgICAgICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBbXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgXSwgY3VycmVudFRyZWUsIHRyZWVQYXRjaCwgc3RhdGUuY2Fub25pY2FsVXJsKTtcbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaC5oYW5kbGVTZWdtZW50TWlzbWF0Y2gpKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0LmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBzdGF0ZS5jYW5vbmljYWxVcmwsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IG92ZXJyaWRlQ2Fub25pY2FsVXJsID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkob3ZlcnJpZGVDYW5vbmljYWxVcmwpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmKSB7XG4gICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgICAgICAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKGN1cnJlbnRDYWNoZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGU7XG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1wYXRjaC1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJfY3JlYXRlaHJlZmZyb211cmwiLCJyZXF1aXJlIiwiX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSIsIl9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQiLCJfbmF2aWdhdGVyZWR1Y2VyIiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsIl9oYW5kbGVtdXRhYmxlIiwiX2FwcHJvdXRlciIsIl9oYW5kbGVzZWdtZW50bWlzbWF0Y2giLCJzdGF0ZSIsImFjdGlvbiIsInNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwibXV0YWJsZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsImZsaWdodERhdGFQYXRoIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJzbGljZSIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJjYW5vbmljYWxVcmwiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6455\n");

/***/ }),

/***/ 6363:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ 543);\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ 882);\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ 6674);\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === \"refresh\" && // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        [\n            rootTree[0],\n            rootTree[1],\n            rootTree[2],\n            \"refetch\"\n        ], includeNextUrl ? state.nextUrl : null, state.buildId).then((fetchResponse)=>{\n            const flightData = fetchResponse[0];\n            if (typeof flightData !== \"string\") {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n                    // just been created & has been written to, but hasn't been \"committed\" yet.\n                    (0, _applyflightdata.applyFlightData)(updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== \"refresh\") {\n        tree[2] = path;\n        tree[3] = \"refresh\";\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFXO1FBQzVFb0IsSUFBSSxDQUFDLEVBQUUsR0FBR0M7UUFDVkQsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNkO0lBQ0EsSUFBSSxNQUFNSCxPQUFPbkIsZUFBZTtRQUM1QnZCLHlDQUF5Q3VCLGNBQWMsQ0FBQ21CLElBQUksRUFBRUk7SUFDbEU7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPakQsUUFBUXFELE9BQU8sS0FBSyxjQUFlLE9BQU9yRCxRQUFRcUQsT0FBTyxLQUFLLFlBQVlyRCxRQUFRcUQsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPckQsUUFBUXFELE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt4RCxPQUFPQyxjQUFjLENBQUNDLFFBQVFxRCxPQUFPLEVBQUUsY0FBYztRQUFFcEQsT0FBTztJQUFLO0lBQ25FSCxPQUFPeUQsTUFBTSxDQUFDdkQsUUFBUXFELE9BQU8sRUFBRXJEO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFxRCxPQUFPO0FBQ2xDLEVBRUEsOERBQThEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy5qcz81ZDI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50czogbnVsbCxcbiAgICByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cztcbiAgICB9LFxuICAgIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cztcbiAgICB9XG59KTtcbmNvbnN0IF9hcHBseWZsaWdodGRhdGEgPSByZXF1aXJlKFwiLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX3NlZ21lbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50XCIpO1xuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyhvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hlZFNlZ21lbnRzID0gbmV3IFNldCgpO1xuICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcm9vdFRyZWU6IG9wdGlvbnMudXBkYXRlZFRyZWUsXG4gICAgICAgIGZldGNoZWRTZWdtZW50c1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwocGFyYW0pIHtcbiAgICBsZXQgeyBzdGF0ZSwgdXBkYXRlZFRyZWUsIHVwZGF0ZWRDYWNoZSwgaW5jbHVkZU5leHRVcmwsIGZldGNoZWRTZWdtZW50cywgcm9vdFRyZWUgPSB1cGRhdGVkVHJlZSwgY2Fub25pY2FsVXJsIH0gPSBwYXJhbTtcbiAgICBjb25zdCBbLCBwYXJhbGxlbFJvdXRlcywgcmVmZXRjaFBhdGgsIHJlZmV0Y2hNYXJrZXJdID0gdXBkYXRlZFRyZWU7XG4gICAgY29uc3QgZmV0Y2hQcm9taXNlcyA9IFtdO1xuICAgIGlmIChyZWZldGNoUGF0aCAmJiByZWZldGNoUGF0aCAhPT0gY2Fub25pY2FsVXJsICYmIHJlZmV0Y2hNYXJrZXIgPT09IFwicmVmcmVzaFwiICYmIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSB0cmVlIHRvIGNvbnRhaW4gbXVsdGlwbGUgc2VnbWVudHMgdGhhdCBjb250YWluIGRhdGEgYXQgdGhlIHNhbWUgVVJMXG4gICAgLy8gd2Uga2VlcCB0cmFjayBvZiB0aGVtIHNvIHdlIGNhbiBkZWR1cGUgdGhlIHJlcXVlc3RzXG4gICAgIWZldGNoZWRTZWdtZW50cy5oYXMocmVmZXRjaFBhdGgpKSB7XG4gICAgICAgIGZldGNoZWRTZWdtZW50cy5hZGQocmVmZXRjaFBhdGgpIC8vIE1hcmsgdGhpcyBVUkwgYXMgZmV0Y2hlZFxuICAgICAgICA7XG4gICAgICAgIC8vIEVhZ2VybHkga2ljayBvZmYgdGhlIGZldGNoIGZvciB0aGUgcmVmZXRjaCBwYXRoICYgdGhlIHBhcmFsbGVsIHJvdXRlcy4gVGhpcyBzaG91bGQgYmUgZmluZSB0byBkbyBhcyB0aGV5IGVhY2ggb3BlcmF0ZVxuICAgICAgICAvLyBpbmRlcGVuZGVudGx5IG9uIHRoZWlyIG93biBjYWNoZSBub2RlcywgYW5kIGBhcHBseUZsaWdodERhdGFgIHdpbGwgY29weSBhbnl0aGluZyBpdCBkb2Vzbid0IGNhcmUgYWJvdXQgZnJvbSB0aGUgZXhpc3RpbmcgY2FjaGUuXG4gICAgICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9ICgwLCBfZmV0Y2hzZXJ2ZXJyZXNwb25zZS5mZXRjaFNlcnZlclJlc3BvbnNlKShuZXcgVVJMKHJlZmV0Y2hQYXRoLCBsb2NhdGlvbi5vcmlnaW4pLCAvLyByZWZldGNoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHVwZGF0ZWQgdHJlZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgc2NvcGVkIHRvIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgICAgLy8gYW5kIG1pZ2h0IG5vdCBjb250YWluIHRoZSBkYXRhIHdlIG5lZWQgdG8gcGF0Y2ggaW4gaW50ZXJjZXB0aW9uIHJvdXRlIGRhdGEgKHN1Y2ggYXMgZHluYW1pYyBwYXJhbXMgZnJvbSBhIHByZXZpb3VzIHNlZ21lbnQpXG4gICAgICAgIFtcbiAgICAgICAgICAgIHJvb3RUcmVlWzBdLFxuICAgICAgICAgICAgcm9vdFRyZWVbMV0sXG4gICAgICAgICAgICByb290VHJlZVsyXSxcbiAgICAgICAgICAgIFwicmVmZXRjaFwiXG4gICAgICAgIF0sIGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsIHN0YXRlLmJ1aWxkSWQpLnRoZW4oKGZldGNoUmVzcG9uc2UpPT57XG4gICAgICAgICAgICBjb25zdCBmbGlnaHREYXRhID0gZmV0Y2hSZXNwb25zZVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG9ubHkgcGFzcyB0aGUgbmV3IGNhY2hlIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGNsZWFyaW5nIHRoZSByb3V0ZXIgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGZpbGxpbmcgaW4gdGhlIG5ldyBwYWdlIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBNZWFuaW5nIHRoZSBleGlzdGluZyBjYWNoZSBpcyBhY3R1YWxseSB0aGUgY2FjaGUgdGhhdCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYmVlbiBjcmVhdGVkICYgaGFzIGJlZW4gd3JpdHRlbiB0bywgYnV0IGhhc24ndCBiZWVuIFwiY29tbWl0dGVkXCIgeWV0LlxuICAgICAgICAgICAgICAgICAgICAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKHVwZGF0ZWRDYWNoZSwgdXBkYXRlZENhY2hlLCBmbGlnaHREYXRhUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZmxpZ2h0RGF0YSBpcyBhIHN0cmluZywgaXQgc3VnZ2VzdHMgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIHNob3VsZCBoYXZlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvblxuICAgICAgICAgICAgLy8gSSdtIG5vdCAxMDAlIHN1cmUgb2YgdGhpcyBkZWNpc2lvbiwgYnV0IGl0IHNlZW1zIHVubGlrZWx5IHRoYXQgd2UnZCB3YW50IHRvIGludHJvZHVjZSBhIHJlZGlyZWN0IHNpZGUgZWZmZWN0XG4gICAgICAgICAgICAvLyB3aGVuIHJlZnJlc2hpbmcgb24tc2NyZWVuIGRhdGEsIHNvIGhhbmRsaW5nIHRoaXMgaGFzIGJlZW4gb21taXR0ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmZXRjaFByb21pc2VzLnB1c2goZmV0Y2hQcm9taXNlKTtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsRmV0Y2hQcm9taXNlID0gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB1cGRhdGVkVHJlZTogcGFyYWxsZWxSb3V0ZXNba2V5XSxcbiAgICAgICAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgICAgICAgIGluY2x1ZGVOZXh0VXJsLFxuICAgICAgICAgICAgZmV0Y2hlZFNlZ21lbnRzLFxuICAgICAgICAgICAgcm9vdFRyZWUsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGZldGNoUHJvbWlzZXMucHVzaChwYXJhbGxlbEZldGNoUHJvbWlzZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGZldGNoUHJvbWlzZXMpO1xufVxuZnVuY3Rpb24gYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyh0cmVlLCBwYXRoKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsIHJlZmV0Y2hNYXJrZXJdID0gdHJlZTtcbiAgICAvLyBhIHBhZ2Ugc2VnbWVudCBtaWdodCBhbHNvIGNvbnRhaW4gY29uY2F0ZW5hdGVkIHNlYXJjaCBwYXJhbXMsIHNvIHdlIGRvIGEgcGFydGlhbCBtYXRjaCBvbiB0aGUga2V5XG4gICAgaWYgKHNlZ21lbnQuaW5jbHVkZXMoX3NlZ21lbnQuUEFHRV9TRUdNRU5UX0tFWSkgJiYgcmVmZXRjaE1hcmtlciAhPT0gXCJyZWZyZXNoXCIpIHtcbiAgICAgICAgdHJlZVsyXSA9IHBhdGg7XG4gICAgICAgIHRyZWVbM10gPSBcInJlZnJlc2hcIjtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMocGFyYWxsZWxSb3V0ZXNba2V5XSwgcGF0aCk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsInJlcXVpcmUiLCJfZmV0Y2hzZXJ2ZXJyZXNwb25zZSIsIl9zZWdtZW50Iiwib3B0aW9ucyIsImZldGNoZWRTZWdtZW50cyIsIlNldCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsIiwicm9vdFRyZWUiLCJ1cGRhdGVkVHJlZSIsInBhcmFtIiwic3RhdGUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsImNhbm9uaWNhbFVybCIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFBhdGgiLCJyZWZldGNoTWFya2VyIiwiZmV0Y2hQcm9taXNlcyIsImhhcyIsImFkZCIsImZldGNoUHJvbWlzZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsImZldGNoUmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJhcHBseUZsaWdodERhdGEiLCJwdXNoIiwia2V5IiwicGFyYWxsZWxGZXRjaFByb21pc2UiLCJQcm9taXNlIiwidHJlZSIsInBhdGgiLCJzZWdtZW50IiwiaW5jbHVkZXMiLCJQQUdFX1NFR01FTlRfS0VZIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6363\n");

/***/ }),

/***/ 744:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_FAST_REFRESH: function() {\n        return ACTION_FAST_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    },\n    isThenable: function() {\n        return isThenable;\n    }\n});\nconst ACTION_REFRESH = \"refresh\";\nconst ACTION_NAVIGATE = \"navigate\";\nconst ACTION_RESTORE = \"restore\";\nconst ACTION_SERVER_PATCH = \"server-patch\";\nconst ACTION_PREFETCH = \"prefetch\";\nconst ACTION_FAST_REFRESH = \"fast-refresh\";\nconst ACTION_SERVER_ACTION = \"server-action\";\nvar PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n})(PrefetchKind || (PrefetchKind = {}));\nvar PrefetchCacheEntryStatus;\n(function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\n})(PrefetchCacheEntryStatus || (PrefetchCacheEntryStatus = {}));\nfunction isThenable(value) {\n    // TODO: We don't gain anything from this abstraction. It's unsound, and only\n    // makes sense in the specific places where we use it. So it's better to keep\n    // the type coercion inline, instead of leaking this to other places in\n    // the codebase.\n    return value && (typeof value === \"object\" || typeof value === \"function\") && typeof value.then === \"function\";\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBV047QUFDQSxTQUFTVyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJakIsT0FBT0MsY0FBYyxDQUFDZSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFiLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxzQkFBc0I7UUFDbEIsT0FBT0E7SUFDWDtJQUNBQyxxQkFBcUI7UUFDakIsT0FBT0E7SUFDWDtJQUNBQywwQkFBMEI7UUFDdEIsT0FBT0E7SUFDWDtJQUNBQyxjQUFjO1FBQ1YsT0FBT0E7SUFDWDtJQUNBQyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU4saUJBQWlCO0FBQ3ZCLE1BQU1GLGtCQUFrQjtBQUN4QixNQUFNRyxpQkFBaUI7QUFDdkIsTUFBTUUsc0JBQXNCO0FBQzVCLE1BQU1KLGtCQUFrQjtBQUN4QixNQUFNRixzQkFBc0I7QUFDNUIsTUFBTUssdUJBQXVCO0FBQzdCLElBQUlHO0FBQ0gsVUFBU0EsWUFBWTtJQUNsQkEsWUFBWSxDQUFDLE9BQU8sR0FBRztJQUN2QkEsWUFBWSxDQUFDLE9BQU8sR0FBRztJQUN2QkEsWUFBWSxDQUFDLFlBQVksR0FBRztBQUNoQyxHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUNwQyxJQUFJRDtBQUNILFVBQVNBLHdCQUF3QjtJQUM5QkEsd0JBQXdCLENBQUMsUUFBUSxHQUFHO0lBQ3BDQSx3QkFBd0IsQ0FBQyxXQUFXLEdBQUc7SUFDdkNBLHdCQUF3QixDQUFDLFVBQVUsR0FBRztJQUN0Q0Esd0JBQXdCLENBQUMsUUFBUSxHQUFHO0FBQ3hDLEdBQUdBLDRCQUE2QkEsQ0FBQUEsMkJBQTJCLENBQUM7QUFDNUQsU0FBU0UsV0FBV1gsS0FBSztJQUNyQiw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLHVFQUF1RTtJQUN2RSxnQkFBZ0I7SUFDaEIsT0FBT0EsU0FBVSxRQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFTLEtBQU0sT0FBT0EsTUFBTWtCLElBQUksS0FBSztBQUN4RztBQUVBLElBQUksQ0FBQyxPQUFPbkIsUUFBUW9CLE9BQU8sS0FBSyxjQUFlLE9BQU9wQixRQUFRb0IsT0FBTyxLQUFLLFlBQVlwQixRQUFRb0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPcEIsUUFBUW9CLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt2QixPQUFPQyxjQUFjLENBQUNDLFFBQVFvQixPQUFPLEVBQUUsY0FBYztRQUFFbkIsT0FBTztJQUFLO0lBQ25FSCxPQUFPd0IsTUFBTSxDQUFDdEIsUUFBUW9CLE9BQU8sRUFBRXBCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFvQixPQUFPO0FBQ2xDLEVBRUEsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMuanM/NjU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIEFDVElPTl9GQVNUX1JFRlJFU0g6IG51bGwsXG4gICAgQUNUSU9OX05BVklHQVRFOiBudWxsLFxuICAgIEFDVElPTl9QUkVGRVRDSDogbnVsbCxcbiAgICBBQ1RJT05fUkVGUkVTSDogbnVsbCxcbiAgICBBQ1RJT05fUkVTVE9SRTogbnVsbCxcbiAgICBBQ1RJT05fU0VSVkVSX0FDVElPTjogbnVsbCxcbiAgICBBQ1RJT05fU0VSVkVSX1BBVENIOiBudWxsLFxuICAgIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1czogbnVsbCxcbiAgICBQcmVmZXRjaEtpbmQ6IG51bGwsXG4gICAgaXNUaGVuYWJsZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBBQ1RJT05fRkFTVF9SRUZSRVNIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9GQVNUX1JFRlJFU0g7XG4gICAgfSxcbiAgICBBQ1RJT05fTkFWSUdBVEU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX05BVklHQVRFO1xuICAgIH0sXG4gICAgQUNUSU9OX1BSRUZFVENIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9QUkVGRVRDSDtcbiAgICB9LFxuICAgIEFDVElPTl9SRUZSRVNIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9SRUZSRVNIO1xuICAgIH0sXG4gICAgQUNUSU9OX1JFU1RPUkU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1JFU1RPUkU7XG4gICAgfSxcbiAgICBBQ1RJT05fU0VSVkVSX0FDVElPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fU0VSVkVSX0FDVElPTjtcbiAgICB9LFxuICAgIEFDVElPTl9TRVJWRVJfUEFUQ0g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1NFUlZFUl9QQVRDSDtcbiAgICB9LFxuICAgIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXM7XG4gICAgfSxcbiAgICBQcmVmZXRjaEtpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJlZmV0Y2hLaW5kO1xuICAgIH0sXG4gICAgaXNUaGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1RoZW5hYmxlO1xuICAgIH1cbn0pO1xuY29uc3QgQUNUSU9OX1JFRlJFU0ggPSBcInJlZnJlc2hcIjtcbmNvbnN0IEFDVElPTl9OQVZJR0FURSA9IFwibmF2aWdhdGVcIjtcbmNvbnN0IEFDVElPTl9SRVNUT1JFID0gXCJyZXN0b3JlXCI7XG5jb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gXCJzZXJ2ZXItcGF0Y2hcIjtcbmNvbnN0IEFDVElPTl9QUkVGRVRDSCA9IFwicHJlZmV0Y2hcIjtcbmNvbnN0IEFDVElPTl9GQVNUX1JFRlJFU0ggPSBcImZhc3QtcmVmcmVzaFwiO1xuY29uc3QgQUNUSU9OX1NFUlZFUl9BQ1RJT04gPSBcInNlcnZlci1hY3Rpb25cIjtcbnZhciBQcmVmZXRjaEtpbmQ7XG4oZnVuY3Rpb24oUHJlZmV0Y2hLaW5kKSB7XG4gICAgUHJlZmV0Y2hLaW5kW1wiQVVUT1wiXSA9IFwiYXV0b1wiO1xuICAgIFByZWZldGNoS2luZFtcIkZVTExcIl0gPSBcImZ1bGxcIjtcbiAgICBQcmVmZXRjaEtpbmRbXCJURU1QT1JBUllcIl0gPSBcInRlbXBvcmFyeVwiO1xufSkoUHJlZmV0Y2hLaW5kIHx8IChQcmVmZXRjaEtpbmQgPSB7fSkpO1xudmFyIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cztcbihmdW5jdGlvbihQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMpIHtcbiAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXNbXCJmcmVzaFwiXSA9IFwiZnJlc2hcIjtcbiAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXNbXCJyZXVzYWJsZVwiXSA9IFwicmV1c2FibGVcIjtcbiAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXNbXCJleHBpcmVkXCJdID0gXCJleHBpcmVkXCI7XG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzW1wic3RhbGVcIl0gPSBcInN0YWxlXCI7XG59KShQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMgfHwgKFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyA9IHt9KSk7XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3QgZ2FpbiBhbnl0aGluZyBmcm9tIHRoaXMgYWJzdHJhY3Rpb24uIEl0J3MgdW5zb3VuZCwgYW5kIG9ubHlcbiAgICAvLyBtYWtlcyBzZW5zZSBpbiB0aGUgc3BlY2lmaWMgcGxhY2VzIHdoZXJlIHdlIHVzZSBpdC4gU28gaXQncyBiZXR0ZXIgdG8ga2VlcFxuICAgIC8vIHRoZSB0eXBlIGNvZXJjaW9uIGlubGluZSwgaW5zdGVhZCBvZiBsZWFraW5nIHRoaXMgdG8gb3RoZXIgcGxhY2VzIGluXG4gICAgLy8gdGhlIGNvZGViYXNlLlxuICAgIHJldHVybiB2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItcmVkdWNlci10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJBQ1RJT05fRkFTVF9SRUZSRVNIIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fUkVTVE9SRSIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyIsIlByZWZldGNoS2luZCIsImlzVGhlbmFibGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJ0aGVuIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///744\n");

/***/ }),

/***/ 6682:
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"reducer\", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ 744);\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ 7447);\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ 6455);\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ 7145);\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ 6425);\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ 7990);\nconst _fastrefreshreducer = __webpack_require__(/*! ./reducers/fast-refresh-reducer */ 1768);\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ 1131);\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_FAST_REFRESH:\n            {\n                return (0, _fastrefreshreducer.fastRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  true ? serverReducer : 0;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY4Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyxpQ0FBd0I7QUFDNUQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx1Q0FBNkI7QUFDOUQsTUFBTUUsc0JBQXNCRixtQkFBT0EsQ0FBQywyQ0FBaUM7QUFDckUsTUFBTUcsa0JBQWtCSCxtQkFBT0EsQ0FBQyxzQ0FBNEI7QUFDNUQsTUFBTUksa0JBQWtCSixtQkFBT0EsQ0FBQyxzQ0FBNEI7QUFDNUQsTUFBTUssbUJBQW1CTCxtQkFBT0EsQ0FBQyx1Q0FBNkI7QUFDOUQsTUFBTU0sc0JBQXNCTixtQkFBT0EsQ0FBQywyQ0FBaUM7QUFDckUsTUFBTU8sdUJBQXVCUCxtQkFBT0EsQ0FBQyw0Q0FBa0M7QUFDdkU7O0NBRUMsR0FBRyxTQUFTUSxjQUFjQyxLQUFLLEVBQUVDLE1BQU07SUFDcEMsT0FBT0EsT0FBT0MsSUFBSTtRQUNkLEtBQUtaLG9CQUFvQmEsZUFBZTtZQUNwQztnQkFDSSxPQUFPLENBQUMsR0FBR1gsaUJBQWlCWSxlQUFlLEVBQUVKLE9BQU9DO1lBQ3hEO1FBQ0osS0FBS1gsb0JBQW9CZSxtQkFBbUI7WUFDeEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdaLG9CQUFvQmEsa0JBQWtCLEVBQUVOLE9BQU9DO1lBQzlEO1FBQ0osS0FBS1gsb0JBQW9CaUIsY0FBYztZQUNuQztnQkFDSSxPQUFPLENBQUMsR0FBR2IsZ0JBQWdCYyxjQUFjLEVBQUVSLE9BQU9DO1lBQ3REO1FBQ0osS0FBS1gsb0JBQW9CbUIsY0FBYztZQUNuQztnQkFDSSxPQUFPLENBQUMsR0FBR2QsZ0JBQWdCZSxjQUFjLEVBQUVWLE9BQU9DO1lBQ3REO1FBQ0osS0FBS1gsb0JBQW9CcUIsbUJBQW1CO1lBQ3hDO2dCQUNJLE9BQU8sQ0FBQyxHQUFHZCxvQkFBb0JlLGtCQUFrQixFQUFFWixPQUFPQztZQUM5RDtRQUNKLEtBQUtYLG9CQUFvQnVCLGVBQWU7WUFDcEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdqQixpQkFBaUJrQixlQUFlLEVBQUVkLE9BQU9DO1lBQ3hEO1FBQ0osS0FBS1gsb0JBQW9CeUIsb0JBQW9CO1lBQ3pDO2dCQUNJLE9BQU8sQ0FBQyxHQUFHakIscUJBQXFCa0IsbUJBQW1CLEVBQUVoQixPQUFPQztZQUNoRTtRQUNKLCtEQUErRDtRQUMvRDtZQUNJLE1BQU0sSUFBSWdCLE1BQU07SUFDeEI7QUFDSjtBQUNBLFNBQVNDLGNBQWNsQixLQUFLLEVBQUVtQixPQUFPO0lBQ2pDLE9BQU9uQjtBQUNYO0FBQ0EsTUFBTVgsVUFBVSxLQUE2QixHQUFHNkIsZ0JBQWdCbkIsQ0FBYUE7QUFFN0UsSUFBSSxDQUFDLE9BQU9kLFFBQVFtQyxPQUFPLEtBQUssY0FBZSxPQUFPbkMsUUFBUW1DLE9BQU8sS0FBSyxZQUFZbkMsUUFBUW1DLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25DLFFBQVFtQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRbUMsT0FBTyxFQUFFLGNBQWM7UUFBRWxDLE9BQU87SUFBSztJQUNuRUgsT0FBT3VDLE1BQU0sQ0FBQ3JDLFFBQVFtQyxPQUFPLEVBQUVuQztJQUMvQnNDLE9BQU90QyxPQUFPLEdBQUdBLFFBQVFtQyxPQUFPO0FBQ2xDLEVBRUEsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXIuanM/MWRkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZHVjZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBfbmF2aWdhdGVyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlclwiKTtcbmNvbnN0IF9zZXJ2ZXJwYXRjaHJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlclwiKTtcbmNvbnN0IF9yZXN0b3JlcmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlclwiKTtcbmNvbnN0IF9yZWZyZXNocmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlclwiKTtcbmNvbnN0IF9wcmVmZXRjaHJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyXCIpO1xuY29uc3QgX2Zhc3RyZWZyZXNocmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL2Zhc3QtcmVmcmVzaC1yZWR1Y2VyXCIpO1xuY29uc3QgX3NlcnZlcmFjdGlvbnJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9zZXJ2ZXItYWN0aW9uLXJlZHVjZXJcIik7XG4vKipcbiAqIFJlZHVjZXIgdGhhdCBoYW5kbGVzIHRoZSBhcHAtcm91dGVyIHN0YXRlIHVwZGF0ZXMuXG4gKi8gZnVuY3Rpb24gY2xpZW50UmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoKGFjdGlvbi50eXBlKXtcbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9OQVZJR0FURTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIubmF2aWdhdGVSZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9TRVJWRVJfUEFUQ0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfc2VydmVycGF0Y2hyZWR1Y2VyLnNlcnZlclBhdGNoUmVkdWNlcikoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlcnJlZHVjZXJ0eXBlcy5BQ1RJT05fUkVTVE9SRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9yZXN0b3JlcmVkdWNlci5yZXN0b3JlUmVkdWNlcikoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlcnJlZHVjZXJ0eXBlcy5BQ1RJT05fUkVGUkVTSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9yZWZyZXNocmVkdWNlci5yZWZyZXNoUmVkdWNlcikoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlcnJlZHVjZXJ0eXBlcy5BQ1RJT05fRkFTVF9SRUZSRVNIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2Zhc3RyZWZyZXNocmVkdWNlci5mYXN0UmVmcmVzaFJlZHVjZXIpKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJyZWR1Y2VydHlwZXMuQUNUSU9OX1BSRUZFVENIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3ByZWZldGNocmVkdWNlci5wcmVmZXRjaFJlZHVjZXIpKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJyZWR1Y2VydHlwZXMuQUNUSU9OX1NFUlZFUl9BQ1RJT046XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfc2VydmVyYWN0aW9ucmVkdWNlci5zZXJ2ZXJBY3Rpb25SZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBiZSBoaXQgYXMgZGlzcGF0Y2ggaXMgc3Ryb25nbHkgdHlwZWQuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFjdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJ2ZXJSZWR1Y2VyKHN0YXRlLCBfYWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgcmVkdWNlciA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBzZXJ2ZXJSZWR1Y2VyIDogY2xpZW50UmVkdWNlcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInJlZHVjZXIiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwicmVxdWlyZSIsIl9uYXZpZ2F0ZXJlZHVjZXIiLCJfc2VydmVycGF0Y2hyZWR1Y2VyIiwiX3Jlc3RvcmVyZWR1Y2VyIiwiX3JlZnJlc2hyZWR1Y2VyIiwiX3ByZWZldGNocmVkdWNlciIsIl9mYXN0cmVmcmVzaHJlZHVjZXIiLCJfc2VydmVyYWN0aW9ucmVkdWNlciIsImNsaWVudFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJBQ1RJT05fTkFWSUdBVEUiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwic2VydmVyUGF0Y2hSZWR1Y2VyIiwiQUNUSU9OX1JFU1RPUkUiLCJyZXN0b3JlUmVkdWNlciIsIkFDVElPTl9SRUZSRVNIIiwicmVmcmVzaFJlZHVjZXIiLCJBQ1RJT05fRkFTVF9SRUZSRVNIIiwiZmFzdFJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwicHJlZmV0Y2hSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiRXJyb3IiLCJzZXJ2ZXJSZWR1Y2VyIiwiX2FjdGlvbiIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6682\n");

/***/ }),

/***/ 1510:
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"shouldHardNavigate\", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ 9551);\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUxMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsaUJBQWlCQyxtQkFBT0EsQ0FBQyw2QkFBbUI7QUFDbEQsU0FBU0YsbUJBQW1CRyxpQkFBaUIsRUFBRUMsaUJBQWlCO0lBQzVELE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNsQywyQ0FBMkM7SUFDM0MsTUFBTSxDQUFDRyxnQkFBZ0JDLGlCQUFpQixHQUFHTDtJQUMzQyx5REFBeUQ7SUFDekQsSUFBSSxDQUFDLENBQUMsR0FBR0YsZUFBZVEsWUFBWSxFQUFFRixnQkFBZ0JGLFVBQVU7UUFDNUQsa0dBQWtHO1FBQ2xHLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osaUJBQWlCO1lBQy9CLE9BQU87UUFDWDtRQUNBLHNFQUFzRTtRQUN0RSxPQUFPO0lBQ1g7SUFDQSxNQUFNSyxjQUFjVCxrQkFBa0JVLE1BQU0sSUFBSTtJQUNoRCxJQUFJRCxhQUFhO1FBQ2IsT0FBTztJQUNYO0lBQ0EsT0FBT1osbUJBQW1CRyxrQkFBa0JXLEtBQUssQ0FBQyxJQUFJUixjQUFjLENBQUNFLGlCQUFpQjtBQUMxRjtBQUVBLElBQUksQ0FBQyxPQUFPWixRQUFRbUIsT0FBTyxLQUFLLGNBQWUsT0FBT25CLFFBQVFtQixPQUFPLEtBQUssWUFBWW5CLFFBQVFtQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9uQixRQUFRbUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1CLE9BQU8sRUFBRSxjQUFjO1FBQUVsQixPQUFPO0lBQUs7SUFDbkVILE9BQU91QixNQUFNLENBQUNyQixRQUFRbUIsT0FBTyxFQUFFbkI7SUFDL0JzQixPQUFPdEIsT0FBTyxHQUFHQSxRQUFRbUIsT0FBTztBQUNsQyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Nob3VsZC1oYXJkLW5hdmlnYXRlLmpzPzY2MzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaG91bGRIYXJkTmF2aWdhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZEhhcmROYXZpZ2F0ZTtcbiAgICB9XG59KTtcbmNvbnN0IF9tYXRjaHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL21hdGNoLXNlZ21lbnRzXCIpO1xuZnVuY3Rpb24gc2hvdWxkSGFyZE5hdmlnYXRlKGZsaWdodFNlZ21lbnRQYXRoLCBmbGlnaHRSb3V0ZXJTdGF0ZSkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBUT0RPLUFQUDogQ2hlY2sgaWYgYGFzYCBjYW4gYmUgcmVwbGFjZWQuXG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgc2VnbWVudCBtYXRjaGVzIHRoZSBleGlzdGluZyBzZWdtZW50LlxuICAgIGlmICghKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkoY3VycmVudFNlZ21lbnQsIHNlZ21lbnQpKSB7XG4gICAgICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGV4aXN0aW5nIHNlZ21lbnQgZGlkIG5vdCBtYXRjaCBzb2Z0IG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoIDw9IDI7XG4gICAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaG91bGQtaGFyZC1uYXZpZ2F0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiX21hdGNoc2VnbWVudHMiLCJyZXF1aXJlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsImN1cnJlbnRTZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsIm1hdGNoU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImxhc3RTZWdtZW50IiwibGVuZ3RoIiwic2xpY2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1510\n");

/***/ }),

/***/ 4250:
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/search-params.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createDynamicallyTrackedSearchParams: function() {\n        return createDynamicallyTrackedSearchParams;\n    },\n    createUntrackedSearchParams: function() {\n        return createUntrackedSearchParams;\n    }\n});\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ 5869);\nconst _dynamicrendering = __webpack_require__(/*! ../../server/app-render/dynamic-rendering */ 8050);\nconst _reflect = __webpack_require__(/*! ../../server/web/spec-extension/adapters/reflect */ 1216);\nfunction createUntrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (store && store.forceStatic) {\n        return {};\n    } else {\n        return searchParams;\n    }\n}\nfunction createDynamicallyTrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (!store) {\n        // we assume we are in a route handler or page render. just return the searchParams\n        return searchParams;\n    } else if (store.forceStatic) {\n        // If we forced static we omit searchParams entirely. This is true both during SSR\n        // and browser render because we need there to be parity between these environments\n        return {};\n    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {\n        // during dynamic renders we don't actually have to track anything so we just return\n        // the searchParams directly. However if dynamic data access should error then we\n        // still want to track access. This covers the case in Dev where all renders are dynamic\n        // but we still want to error if you use a dynamic data source because it will fail the build\n        // or revalidate if you do.\n        return searchParams;\n    } else {\n        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because\n        // these can all be used to exfiltrate information about searchParams.\n        return new Proxy({}, {\n            get (target, prop, receiver) {\n                if (typeof prop === \"string\") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams.\" + prop);\n                }\n                return _reflect.ReflectAdapter.get(target, prop, receiver);\n            },\n            has (target, prop) {\n                if (typeof prop === \"string\") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams.\" + prop);\n                }\n                return Reflect.has(target, prop);\n            },\n            ownKeys (target) {\n                (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams\");\n                return Reflect.ownKeys(target);\n            }\n        });\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=search-params.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dC9jbGllbnQvY29tcG9uZW50cy9zZWFyY2gtcGFyYW1zLmpzPzM2M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXM6IG51bGwsXG4gICAgY3JlYXRlVW50cmFja2VkU2VhcmNoUGFyYW1zOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGNyZWF0ZUR5bmFtaWNhbGx5VHJhY2tlZFNlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXM7XG4gICAgfSxcbiAgICBjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVW50cmFja2VkU2VhcmNoUGFyYW1zO1xuICAgIH1cbn0pO1xuY29uc3QgX3N0YXRpY2dlbmVyYXRpb25hc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuL3N0YXRpYy1nZW5lcmF0aW9uLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfZHluYW1pY3JlbmRlcmluZyA9IHJlcXVpcmUoXCIuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZ1wiKTtcbmNvbnN0IF9yZWZsZWN0ID0gcmVxdWlyZShcIi4uLy4uL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVVudHJhY2tlZFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBzdG9yZSA9IF9zdGF0aWNnZW5lcmF0aW9uYXN5bmNzdG9yYWdlZXh0ZXJuYWwuc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChzdG9yZSAmJiBzdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3Qgc3RvcmUgPSBfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZWV4dGVybmFsLnN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgIC8vIHdlIGFzc3VtZSB3ZSBhcmUgaW4gYSByb3V0ZSBoYW5kbGVyIG9yIHBhZ2UgcmVuZGVyLiBqdXN0IHJldHVybiB0aGUgc2VhcmNoUGFyYW1zXG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG4gICAgfSBlbHNlIGlmIChzdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgICAvLyBJZiB3ZSBmb3JjZWQgc3RhdGljIHdlIG9taXQgc2VhcmNoUGFyYW1zIGVudGlyZWx5LiBUaGlzIGlzIHRydWUgYm90aCBkdXJpbmcgU1NSXG4gICAgICAgIC8vIGFuZCBicm93c2VyIHJlbmRlciBiZWNhdXNlIHdlIG5lZWQgdGhlcmUgdG8gYmUgcGFyaXR5IGJldHdlZW4gdGhlc2UgZW52aXJvbm1lbnRzXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKCFzdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24gJiYgIXN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAvLyBkdXJpbmcgZHluYW1pYyByZW5kZXJzIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gdHJhY2sgYW55dGhpbmcgc28gd2UganVzdCByZXR1cm5cbiAgICAgICAgLy8gdGhlIHNlYXJjaFBhcmFtcyBkaXJlY3RseS4gSG93ZXZlciBpZiBkeW5hbWljIGRhdGEgYWNjZXNzIHNob3VsZCBlcnJvciB0aGVuIHdlXG4gICAgICAgIC8vIHN0aWxsIHdhbnQgdG8gdHJhY2sgYWNjZXNzLiBUaGlzIGNvdmVycyB0aGUgY2FzZSBpbiBEZXYgd2hlcmUgYWxsIHJlbmRlcnMgYXJlIGR5bmFtaWNcbiAgICAgICAgLy8gYnV0IHdlIHN0aWxsIHdhbnQgdG8gZXJyb3IgaWYgeW91IHVzZSBhIGR5bmFtaWMgZGF0YSBzb3VyY2UgYmVjYXVzZSBpdCB3aWxsIGZhaWwgdGhlIGJ1aWxkXG4gICAgICAgIC8vIG9yIHJldmFsaWRhdGUgaWYgeW91IGRvLlxuICAgICAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhY2sgZHluYW1pYyBhY2Nlc3Mgd2l0aCBhIFByb3h5LiBXZSBpbXBsZW1lbnQgZ2V0LCBoYXMsIGFuZCBvd25LZXlzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlc2UgY2FuIGFsbCBiZSB1c2VkIHRvIGV4ZmlsdHJhdGUgaW5mb3JtYXRpb24gYWJvdXQgc2VhcmNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZCkoc3RvcmUsIFwic2VhcmNoUGFyYW1zLlwiICsgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZCkoc3RvcmUsIFwic2VhcmNoUGFyYW1zLlwiICsgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy50cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQpKHN0b3JlLCBcInNlYXJjaFBhcmFtc1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXBhcmFtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXMiLCJjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXMiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZWV4dGVybmFsIiwicmVxdWlyZSIsIl9keW5hbWljcmVuZGVyaW5nIiwiX3JlZmxlY3QiLCJzZWFyY2hQYXJhbXMiLCJzdG9yZSIsInN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsImZvcmNlU3RhdGljIiwiaXNTdGF0aWNHZW5lcmF0aW9uIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiUHJveHkiLCJwcm9wIiwicmVjZWl2ZXIiLCJ0cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQiLCJSZWZsZWN0QWRhcHRlciIsImhhcyIsIlJlZmxlY3QiLCJvd25LZXlzIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4250\n");

/***/ }),

/***/ 7042:
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = \"NEXT_STATIC_GEN_BAILOUT\";\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args);\n        this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== \"object\" || error === null || !(\"code\" in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsdUJBQXVCO1FBQ25CLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDBCQUEwQjtBQUNoQyxNQUFNUiw4QkFBOEJTO0lBQ2hDQyxZQUFZLEdBQUdDLElBQUksQ0FBQztRQUNoQixLQUFLLElBQUlBO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUdKO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTUCx3QkFBd0JZLEtBQUs7SUFDbEMsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFFLFdBQVVBLEtBQUksR0FBSTtRQUNuRSxPQUFPO0lBQ1g7SUFDQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtKO0FBQzFCO0FBRUEsSUFBSSxDQUFDLE9BQU9YLFFBQVFpQixPQUFPLEtBQUssY0FBZSxPQUFPakIsUUFBUWlCLE9BQU8sS0FBSyxZQUFZakIsUUFBUWlCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2pCLFFBQVFpQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRaUIsT0FBTyxFQUFFLGNBQWM7UUFBRWhCLE9BQU87SUFBSztJQUNuRUgsT0FBT3FCLE1BQU0sQ0FBQ25CLFFBQVFpQixPQUFPLEVBQUVqQjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRaUIsT0FBTztBQUNsQyxFQUVBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQuanM/MDQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFN0YXRpY0dlbkJhaWxvdXRFcnJvcjogbnVsbCxcbiAgICBpc1N0YXRpY0dlbkJhaWxvdXRFcnJvcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBTdGF0aWNHZW5CYWlsb3V0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU3RhdGljR2VuQmFpbG91dEVycm9yO1xuICAgIH0sXG4gICAgaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3I7XG4gICAgfVxufSk7XG5jb25zdCBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCA9IFwiTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcIjtcbmNsYXNzIFN0YXRpY0dlbkJhaWxvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuY29kZSA9IE5FWFRfU1RBVElDX0dFTl9CQUlMT1VUO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGljR2VuQmFpbG91dEVycm9yKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gXCJvYmplY3RcIiB8fCBlcnJvciA9PT0gbnVsbCB8fCAhKFwiY29kZVwiIGluIGVycm9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBlcnJvci5jb2RlID09PSBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGljLWdlbmVyYXRpb24tYmFpbG91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJpc1N0YXRpY0dlbkJhaWxvdXRFcnJvciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIk5FWFRfU1RBVElDX0dFTl9CQUlMT1VUIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJjb2RlIiwiZXJyb3IiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7042\n");

/***/ }),

/***/ 1618:
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/unresolved-thenable.js ***!
  \*************************************************************************/
/***/ ((module, exports) => {

eval("/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"unresolvedThenable\", ({\n    enumerable: true,\n    get: function() {\n        return unresolvedThenable;\n    }\n}));\nconst unresolvedThenable = {\n    then: ()=>{}\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unresolved-thenable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUFnQjtBQUNqQkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHNEQUFxRDtJQUNqREksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1BLHFCQUFxQjtJQUN2QkMsTUFBTSxLQUFLO0FBQ2Y7QUFFQSxJQUFJLENBQUMsT0FBT0wsUUFBUU0sT0FBTyxLQUFLLGNBQWUsT0FBT04sUUFBUU0sT0FBTyxLQUFLLFlBQVlOLFFBQVFNLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT04sUUFBUU0sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1QsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTSxPQUFPLEVBQUUsY0FBYztRQUFFTCxPQUFPO0lBQUs7SUFDbkVILE9BQU9VLE1BQU0sQ0FBQ1IsUUFBUU0sT0FBTyxFQUFFTjtJQUMvQlMsT0FBT1QsT0FBTyxHQUFHQSxRQUFRTSxPQUFPO0FBQ2xDLEVBRUEsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdW5yZXNvbHZlZC10aGVuYWJsZS5qcz9lNzhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlIGEgXCJUaGVuYWJsZVwiIHRoYXQgZG9lcyBub3QgcmVzb2x2ZS4gVGhpcyBpcyB1c2VkIHRvIHN1c3BlbmQgaW5kZWZpbml0ZWx5IHdoZW4gZGF0YSBpcyBub3QgYXZhaWxhYmxlIHlldC5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVucmVzb2x2ZWRUaGVuYWJsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdW5yZXNvbHZlZFRoZW5hYmxlO1xuICAgIH1cbn0pO1xuY29uc3QgdW5yZXNvbHZlZFRoZW5hYmxlID0ge1xuICAgIHRoZW46ICgpPT57fVxufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5yZXNvbHZlZC10aGVuYWJsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidW5yZXNvbHZlZFRoZW5hYmxlIiwidGhlbiIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1618\n");

/***/ }),

/***/ 8859:
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    useReducerWithReduxDevtools: function() {\n        return useReducerWithReduxDevtools;\n    },\n    useUnwrapState: function() {\n        return useUnwrapState;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ 6870);\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ 8964));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ 744);\nconst _actionqueue = __webpack_require__(/*! ../../shared/lib/router/action-queue */ 298);\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        const obj = {};\n        for (const [key, value] of val.entries()){\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value._bundlerConfig) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (typeof val === \"object\" && val !== null) {\n        const obj = {};\n        for(const key in val){\n            const value = val[key];\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value.hasOwnProperty(\"_bundlerConfig\")) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction useUnwrapState(state) {\n    // reducer actions can be async, so sometimes we need to suspend until the state is resolved\n    if ((0, _routerreducertypes.isThenable)(state)) {\n        const result = (0, _react.use)(state);\n        return result;\n    }\n    return state;\n}\nfunction useReducerWithReduxDevtoolsNoop(initialState) {\n    return [\n        initialState,\n        ()=>{},\n        ()=>{}\n    ];\n}\nfunction useReducerWithReduxDevtoolsImpl(initialState) {\n    const [state, setState] = _react.default.useState(initialState);\n    const actionQueue = (0, _react.useContext)(_actionqueue.ActionQueueContext);\n    if (!actionQueue) {\n        throw new Error(\"Invariant: Missing ActionQueueContext\");\n    }\n    const devtoolsConnectionRef = (0, _react.useRef)();\n    const enabledRef = (0, _react.useRef)();\n    (0, _react.useEffect)(()=>{\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === \"undefined\") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 8000,\n            name: \"next-router\"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n            if (actionQueue) {\n                actionQueue.devToolsInstance = devtoolsConnectionRef.current;\n            }\n        }\n        return ()=>{\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState,\n        actionQueue\n    ]);\n    const dispatch = (0, _react.useCallback)((action)=>{\n        if (!actionQueue.state) {\n            // we lazy initialize the mutable action queue state since the data needed\n            // to generate the state is not available when the actionQueue context is created\n            actionQueue.state = initialState;\n        }\n        actionQueue.dispatch(action, setState);\n    }, [\n        actionQueue,\n        initialState\n    ]);\n    // Sync is called after a state update in the HistoryUpdater,\n    // for debugging purposes. Since the reducer state may be a Promise,\n    // we let the app router use() it and sync on the resolved value if\n    // something changed.\n    // Using the `state` here would be referentially unstable and cause\n    // undesirable re-renders and history updates.\n    const sync = (0, _react.useCallback)((resolvedState)=>{\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: \"RENDER_SYNC\"\n            }, normalizeRouterState(resolvedState));\n        }\n    }, []);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\nconst useReducerWithReduxDevtools =  false ? 0 : useReducerWithReduxDevtoolsNoop;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtJQUNqQyxHQUFHO1FBQ0NHO1FBQ0FMO0tBQ0g7SUFDRCw2REFBNkQ7SUFDN0Qsb0VBQW9FO0lBQ3BFLG1FQUFtRTtJQUNuRSxxQkFBcUI7SUFDckIsbUVBQW1FO0lBQ25FLDhDQUE4QztJQUM5QyxNQUFNd0IsT0FBTyxDQUFDLEdBQUc5QyxPQUFPNEMsV0FBVyxFQUFFLENBQUNHO1FBQ2xDLElBQUloQixzQkFBc0JJLE9BQU8sRUFBRTtZQUMvQkosc0JBQXNCSSxPQUFPLENBQUNhLElBQUksQ0FBQztnQkFDL0JDLE1BQU07WUFDVixHQUFHN0MscUJBQXFCMkM7UUFDNUI7SUFDSixHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQ0g5QjtRQUNBMEI7UUFDQUc7S0FDSDtBQUNMO0FBQ0EsTUFBTXhELDhCQUE4QixNQUE2QixHQUFHaUMsQ0FBK0JBLEdBQUdGO0FBRXRHLElBQUksQ0FBQyxPQUFPbEMsUUFBUXNDLE9BQU8sS0FBSyxjQUFlLE9BQU90QyxRQUFRc0MsT0FBTyxLQUFLLFlBQVl0QyxRQUFRc0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPdEMsUUFBUXNDLE9BQU8sQ0FBQ3lCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRc0MsT0FBTyxFQUFFLGNBQWM7UUFBRXJDLE9BQU87SUFBSztJQUNuRUgsT0FBT2tFLE1BQU0sQ0FBQ2hFLFFBQVFzQyxPQUFPLEVBQUV0QztJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRc0MsT0FBTztBQUNsQyxFQUVBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanM/NDUwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sczogbnVsbCxcbiAgICB1c2VVbndyYXBTdGF0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzO1xuICAgIH0sXG4gICAgdXNlVW53cmFwU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlVW53cmFwU3RhdGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuY29uc3QgX2FjdGlvbnF1ZXVlID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvcm91dGVyL2FjdGlvbi1xdWV1ZVwiKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlclN0YXRlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHZhbC5lbnRyaWVzKCkpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBcImZuKClcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS4kJHR5cGVvZi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLl9idW5kbGVyQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gXCJGbGlnaHREYXRhXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtrZXldID0gbm9ybWFsaXplUm91dGVyU3RhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWwpe1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gXCJmbigpXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcIl9idW5kbGVyQ29uZmlnXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gXCJGbGlnaHREYXRhXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtrZXldID0gbm9ybWFsaXplUm91dGVyU3RhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5tYXAobm9ybWFsaXplUm91dGVyU3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gdXNlVW53cmFwU3RhdGUoc3RhdGUpIHtcbiAgICAvLyByZWR1Y2VyIGFjdGlvbnMgY2FuIGJlIGFzeW5jLCBzbyBzb21ldGltZXMgd2UgbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBzdGF0ZSBpcyByZXNvbHZlZFxuICAgIGlmICgoMCwgX3JvdXRlcnJlZHVjZXJ0eXBlcy5pc1RoZW5hYmxlKShzdGF0ZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZWFjdC51c2UpKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcChpbml0aWFsU3RhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBpbml0aWFsU3RhdGUsXG4gICAgICAgICgpPT57fSxcbiAgICAgICAgKCk9Pnt9XG4gICAgXTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwoaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBfcmVhY3QuZGVmYXVsdC51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IGFjdGlvblF1ZXVlID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYWN0aW9ucXVldWUuQWN0aW9uUXVldWVDb250ZXh0KTtcbiAgICBpZiAoIWFjdGlvblF1ZXVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFyaWFudDogTWlzc2luZyBBY3Rpb25RdWV1ZUNvbnRleHRcIik7XG4gICAgfVxuICAgIGNvbnN0IGRldnRvb2xzQ29ubmVjdGlvblJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKSgpO1xuICAgIGNvbnN0IGVuYWJsZWRSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikoKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50IHx8IGVuYWJsZWRSZWYuY3VycmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlZFJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBlbmFibGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCA9IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fLmNvbm5lY3Qoe1xuICAgICAgICAgICAgaW5zdGFuY2VJZDogODAwMCxcbiAgICAgICAgICAgIG5hbWU6IFwibmV4dC1yb3V0ZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudC5pbml0KG5vcm1hbGl6ZVJvdXRlclN0YXRlKGluaXRpYWxTdGF0ZSkpO1xuICAgICAgICAgICAgaWYgKGFjdGlvblF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uUXVldWUuZGV2VG9vbHNJbnN0YW5jZSA9IGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpbml0aWFsU3RhdGUsXG4gICAgICAgIGFjdGlvblF1ZXVlXG4gICAgXSk7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoYWN0aW9uKT0+e1xuICAgICAgICBpZiAoIWFjdGlvblF1ZXVlLnN0YXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSBsYXp5IGluaXRpYWxpemUgdGhlIG11dGFibGUgYWN0aW9uIHF1ZXVlIHN0YXRlIHNpbmNlIHRoZSBkYXRhIG5lZWRlZFxuICAgICAgICAgICAgLy8gdG8gZ2VuZXJhdGUgdGhlIHN0YXRlIGlzIG5vdCBhdmFpbGFibGUgd2hlbiB0aGUgYWN0aW9uUXVldWUgY29udGV4dCBpcyBjcmVhdGVkXG4gICAgICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25RdWV1ZS5kaXNwYXRjaChhY3Rpb24sIHNldFN0YXRlKTtcbiAgICB9LCBbXG4gICAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgICBpbml0aWFsU3RhdGVcbiAgICBdKTtcbiAgICAvLyBTeW5jIGlzIGNhbGxlZCBhZnRlciBhIHN0YXRlIHVwZGF0ZSBpbiB0aGUgSGlzdG9yeVVwZGF0ZXIsXG4gICAgLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gU2luY2UgdGhlIHJlZHVjZXIgc3RhdGUgbWF5IGJlIGEgUHJvbWlzZSxcbiAgICAvLyB3ZSBsZXQgdGhlIGFwcCByb3V0ZXIgdXNlKCkgaXQgYW5kIHN5bmMgb24gdGhlIHJlc29sdmVkIHZhbHVlIGlmXG4gICAgLy8gc29tZXRoaW5nIGNoYW5nZWQuXG4gICAgLy8gVXNpbmcgdGhlIGBzdGF0ZWAgaGVyZSB3b3VsZCBiZSByZWZlcmVudGlhbGx5IHVuc3RhYmxlIGFuZCBjYXVzZVxuICAgIC8vIHVuZGVzaXJhYmxlIHJlLXJlbmRlcnMgYW5kIGhpc3RvcnkgdXBkYXRlcy5cbiAgICBjb25zdCBzeW5jID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKHJlc29sdmVkU3RhdGUpPT57XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJSRU5ERVJfU1lOQ1wiXG4gICAgICAgICAgICB9LCBub3JtYWxpemVSb3V0ZXJTdGF0ZShyZXNvbHZlZFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBzeW5jXG4gICAgXTtcbn1cbmNvbnN0IHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsIDogdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXJlZHVjZXItd2l0aC1kZXZ0b29scy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMiLCJ1c2VVbndyYXBTdGF0ZSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJfYWN0aW9ucXVldWUiLCJub3JtYWxpemVSb3V0ZXJTdGF0ZSIsInZhbCIsIk1hcCIsIm9iaiIsImtleSIsImVudHJpZXMiLCIkJHR5cGVvZiIsInRvU3RyaW5nIiwiX2J1bmRsZXJDb25maWciLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInN0YXRlIiwiaXNUaGVuYWJsZSIsInJlc3VsdCIsInVzZSIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc05vb3AiLCJpbml0aWFsU3RhdGUiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsIiwic2V0U3RhdGUiLCJkZWZhdWx0IiwidXNlU3RhdGUiLCJhY3Rpb25RdWV1ZSIsInVzZUNvbnRleHQiLCJBY3Rpb25RdWV1ZUNvbnRleHQiLCJFcnJvciIsImRldnRvb2xzQ29ubmVjdGlvblJlZiIsInVzZVJlZiIsImVuYWJsZWRSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwidW5kZWZpbmVkIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwiaW5pdCIsImRldlRvb2xzSW5zdGFuY2UiLCJkaXNwYXRjaCIsInVzZUNhbGxiYWNrIiwiYWN0aW9uIiwic3luYyIsInJlc29sdmVkU3RhdGUiLCJzZW5kIiwidHlwZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8859\n");

/***/ }),

/***/ 8871:
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/noop-turbopack-hmr.js ***!
  \*****************************************************************/
/***/ ((module, exports) => {

eval("// The Turbopack HMR client can't be properly omitted at the moment (WEB-1589),\n// so instead we remap its import to this file in webpack builds.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"connect\", ({\n    enumerable: true,\n    get: function() {\n        return connect;\n    }\n}));\nfunction connect() {}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=noop-turbopack-hmr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg3MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrRUFBK0U7QUFDL0UsaUVBQWlFO0FBQ3BEO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixTQUFTQSxXQUFXO0FBRXBCLElBQUksQ0FBQyxPQUFPSixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLUixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU87SUFBSztJQUNuRUgsT0FBT1MsTUFBTSxDQUFDUCxRQUFRSyxPQUFPLEVBQUVMO0lBQy9CUSxPQUFPUixPQUFPLEdBQUdBLFFBQVFLLE9BQU87QUFDbEMsRUFFQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L25vb3AtdHVyYm9wYWNrLWhtci5qcz80MTRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZSBUdXJib3BhY2sgSE1SIGNsaWVudCBjYW4ndCBiZSBwcm9wZXJseSBvbWl0dGVkIGF0IHRoZSBtb21lbnQgKFdFQi0xNTg5KSxcbi8vIHNvIGluc3RlYWQgd2UgcmVtYXAgaXRzIGltcG9ydCB0byB0aGlzIGZpbGUgaW4gd2VicGFjayBidWlsZHMuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbm5lY3RcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Q7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBjb25uZWN0KCkge31cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC10dXJib3BhY2staG1yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJjb25uZWN0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8871\n");

/***/ }),

/***/ 8556:
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ 7928);\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMEJBQTBCQyxtQkFBT0EsQ0FBQyxzQ0FBNEI7QUFDcEUsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixnQkFBZ0JPLElBQUksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLGFBQWE7SUFDekQsSUFBSU4sS0FBK0IsRUFBRSxFQVdwQyxNQUFNO1FBQ0gsT0FBTztJQUNYO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT1IsUUFBUTJCLE9BQU8sS0FBSyxjQUFlLE9BQU8zQixRQUFRMkIsT0FBTyxLQUFLLFlBQVkzQixRQUFRMkIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPM0IsUUFBUTJCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks5QixPQUFPQyxjQUFjLENBQUNDLFFBQVEyQixPQUFPLEVBQUUsY0FBYztRQUFFMUIsT0FBTztJQUFLO0lBQ25FSCxPQUFPK0IsTUFBTSxDQUFDN0IsUUFBUTJCLE9BQU8sRUFBRTNCO0lBQy9COEIsT0FBTzlCLE9BQU8sR0FBR0EsUUFBUTJCLE9BQU87QUFDbEMsRUFFQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvbWFpbkxvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0RG9tYWluTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgXCJcIjtcbmZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShwYXRoLCBsb2NhbGUsIGxvY2FsZXMsIGRvbWFpbkxvY2FsZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVMb2NhbGVQYXRoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpLm5vcm1hbGl6ZUxvY2FsZVBhdGg7XG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoXCIuL2RldGVjdC1kb21haW4tbG9jYWxlXCIpLmRldGVjdERvbWFpbkxvY2FsZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIHRhcmdldCk7XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gXCJodHRwXCIgKyAoZG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIjtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTG9jYWxlID0gdGFyZ2V0ID09PSBkb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIHRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgcHJvdG8gKyBkb21haW4uZG9tYWluICsgKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShcIlwiICsgYmFzZVBhdGggKyBmaW5hbExvY2FsZSArIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0RG9tYWluTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8556\n");

/***/ }),

/***/ 3461:
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/has-base-path.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasBasePath\", ({\n    enumerable: true,\n    get: function() {\n        return hasBasePath;\n    }\n}));\nconst _pathhasprefix = __webpack_require__(/*! ../shared/lib/router/utils/path-has-prefix */ 7322);\nconst basePath =  false || \"\";\nfunction hasBasePath(path) {\n    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-base-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ2MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsaUJBQWlCQyxtQkFBT0EsQ0FBQyxzREFBNEM7QUFDM0UsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixZQUFZTyxJQUFJO0lBQ3JCLE9BQU8sQ0FBQyxHQUFHTixlQUFlTyxhQUFhLEVBQUVELE1BQU1KO0FBQ25EO0FBRUEsSUFBSSxDQUFDLE9BQU9QLFFBQVFhLE9BQU8sS0FBSyxjQUFlLE9BQU9iLFFBQVFhLE9BQU8sS0FBSyxZQUFZYixRQUFRYSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9iLFFBQVFhLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktoQixPQUFPQyxjQUFjLENBQUNDLFFBQVFhLE9BQU8sRUFBRSxjQUFjO1FBQUVaLE9BQU87SUFBSztJQUNuRUgsT0FBT2lCLE1BQU0sQ0FBQ2YsUUFBUWEsT0FBTyxFQUFFYjtJQUMvQmdCLE9BQU9oQixPQUFPLEdBQUdBLFFBQVFhLE9BQU87QUFDbEMsRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGFzLWJhc2UtcGF0aC5qcz81YTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzQmFzZVBhdGhcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhc0Jhc2VQYXRoO1xuICAgIH1cbn0pO1xuY29uc3QgX3BhdGhoYXNwcmVmaXggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1oYXMtcHJlZml4XCIpO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8IFwiXCI7XG5mdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuICgwLCBfcGF0aGhhc3ByZWZpeC5wYXRoSGFzUHJlZml4KShwYXRoLCBiYXNlUGF0aCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1iYXNlLXBhdGguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImhhc0Jhc2VQYXRoIiwiX3BhdGhoYXNwcmVmaXgiLCJyZXF1aXJlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJwYXRoSGFzUHJlZml4IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3461\n");

/***/ }),

/***/ 4842:
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nconst { createProxy } = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ 5347);\nmodule.exports = createProxy(\"/home/project/node_modules/next/dist/client/components/render-from-template-context.js\");\n //# sourceMappingURL=render-from-template-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg0Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Q0E2QkEsd0RBQXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcz84ZWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5mdW5jdGlvbiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuVGVtcGxhdGVDb250ZXh0KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfanN4cnVudGltZS5GcmFnbWVudCwge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4842\n");

/***/ }),

/***/ 3003:
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/search-params.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createDynamicallyTrackedSearchParams: function() {\n        return createDynamicallyTrackedSearchParams;\n    },\n    createUntrackedSearchParams: function() {\n        return createUntrackedSearchParams;\n    }\n});\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ 5869);\nconst _dynamicrendering = __webpack_require__(/*! ../../server/app-render/dynamic-rendering */ 4869);\nconst _reflect = __webpack_require__(/*! ../../server/web/spec-extension/adapters/reflect */ 4203);\nfunction createUntrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (store && store.forceStatic) {\n        return {};\n    } else {\n        return searchParams;\n    }\n}\nfunction createDynamicallyTrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (!store) {\n        // we assume we are in a route handler or page render. just return the searchParams\n        return searchParams;\n    } else if (store.forceStatic) {\n        // If we forced static we omit searchParams entirely. This is true both during SSR\n        // and browser render because we need there to be parity between these environments\n        return {};\n    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {\n        // during dynamic renders we don't actually have to track anything so we just return\n        // the searchParams directly. However if dynamic data access should error then we\n        // still want to track access. This covers the case in Dev where all renders are dynamic\n        // but we still want to error if you use a dynamic data source because it will fail the build\n        // or revalidate if you do.\n        return searchParams;\n    } else {\n        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because\n        // these can all be used to exfiltrate information about searchParams.\n        return new Proxy({}, {\n            get (target, prop, receiver) {\n                if (typeof prop === \"string\") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams.\" + prop);\n                }\n                return _reflect.ReflectAdapter.get(target, prop, receiver);\n            },\n            has (target, prop) {\n                if (typeof prop === \"string\") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams.\" + prop);\n                }\n                return Reflect.has(target, prop);\n            },\n            ownKeys (target) {\n                (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams\");\n                return Reflect.ownKeys(target);\n            }\n        });\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=search-params.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dC9jbGllbnQvY29tcG9uZW50cy9zZWFyY2gtcGFyYW1zLmpzPzM2M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXM6IG51bGwsXG4gICAgY3JlYXRlVW50cmFja2VkU2VhcmNoUGFyYW1zOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGNyZWF0ZUR5bmFtaWNhbGx5VHJhY2tlZFNlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXM7XG4gICAgfSxcbiAgICBjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVW50cmFja2VkU2VhcmNoUGFyYW1zO1xuICAgIH1cbn0pO1xuY29uc3QgX3N0YXRpY2dlbmVyYXRpb25hc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuL3N0YXRpYy1nZW5lcmF0aW9uLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfZHluYW1pY3JlbmRlcmluZyA9IHJlcXVpcmUoXCIuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZ1wiKTtcbmNvbnN0IF9yZWZsZWN0ID0gcmVxdWlyZShcIi4uLy4uL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVVudHJhY2tlZFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBzdG9yZSA9IF9zdGF0aWNnZW5lcmF0aW9uYXN5bmNzdG9yYWdlZXh0ZXJuYWwuc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChzdG9yZSAmJiBzdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3Qgc3RvcmUgPSBfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZWV4dGVybmFsLnN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgIC8vIHdlIGFzc3VtZSB3ZSBhcmUgaW4gYSByb3V0ZSBoYW5kbGVyIG9yIHBhZ2UgcmVuZGVyLiBqdXN0IHJldHVybiB0aGUgc2VhcmNoUGFyYW1zXG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG4gICAgfSBlbHNlIGlmIChzdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgICAvLyBJZiB3ZSBmb3JjZWQgc3RhdGljIHdlIG9taXQgc2VhcmNoUGFyYW1zIGVudGlyZWx5LiBUaGlzIGlzIHRydWUgYm90aCBkdXJpbmcgU1NSXG4gICAgICAgIC8vIGFuZCBicm93c2VyIHJlbmRlciBiZWNhdXNlIHdlIG5lZWQgdGhlcmUgdG8gYmUgcGFyaXR5IGJldHdlZW4gdGhlc2UgZW52aXJvbm1lbnRzXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKCFzdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24gJiYgIXN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAvLyBkdXJpbmcgZHluYW1pYyByZW5kZXJzIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gdHJhY2sgYW55dGhpbmcgc28gd2UganVzdCByZXR1cm5cbiAgICAgICAgLy8gdGhlIHNlYXJjaFBhcmFtcyBkaXJlY3RseS4gSG93ZXZlciBpZiBkeW5hbWljIGRhdGEgYWNjZXNzIHNob3VsZCBlcnJvciB0aGVuIHdlXG4gICAgICAgIC8vIHN0aWxsIHdhbnQgdG8gdHJhY2sgYWNjZXNzLiBUaGlzIGNvdmVycyB0aGUgY2FzZSBpbiBEZXYgd2hlcmUgYWxsIHJlbmRlcnMgYXJlIGR5bmFtaWNcbiAgICAgICAgLy8gYnV0IHdlIHN0aWxsIHdhbnQgdG8gZXJyb3IgaWYgeW91IHVzZSBhIGR5bmFtaWMgZGF0YSBzb3VyY2UgYmVjYXVzZSBpdCB3aWxsIGZhaWwgdGhlIGJ1aWxkXG4gICAgICAgIC8vIG9yIHJldmFsaWRhdGUgaWYgeW91IGRvLlxuICAgICAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhY2sgZHluYW1pYyBhY2Nlc3Mgd2l0aCBhIFByb3h5LiBXZSBpbXBsZW1lbnQgZ2V0LCBoYXMsIGFuZCBvd25LZXlzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlc2UgY2FuIGFsbCBiZSB1c2VkIHRvIGV4ZmlsdHJhdGUgaW5mb3JtYXRpb24gYWJvdXQgc2VhcmNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZCkoc3RvcmUsIFwic2VhcmNoUGFyYW1zLlwiICsgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZCkoc3RvcmUsIFwic2VhcmNoUGFyYW1zLlwiICsgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy50cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQpKHN0b3JlLCBcInNlYXJjaFBhcmFtc1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXBhcmFtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXMiLCJjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXMiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZWV4dGVybmFsIiwicmVxdWlyZSIsIl9keW5hbWljcmVuZGVyaW5nIiwiX3JlZmxlY3QiLCJzZWFyY2hQYXJhbXMiLCJzdG9yZSIsInN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsImZvcmNlU3RhdGljIiwiaXNTdGF0aWNHZW5lcmF0aW9uIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiUHJveHkiLCJwcm9wIiwicmVjZWl2ZXIiLCJ0cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQiLCJSZWZsZWN0QWRhcHRlciIsImhhcyIsIlJlZmxlY3QiLCJvd25LZXlzIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3003\n");

/***/ }),

/***/ 4012:
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = \"NEXT_STATIC_GEN_BAILOUT\";\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args);\n        this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== \"object\" || error === null || !(\"code\" in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAxMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsdUJBQXVCO1FBQ25CLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDBCQUEwQjtBQUNoQyxNQUFNUiw4QkFBOEJTO0lBQ2hDQyxZQUFZLEdBQUdDLElBQUksQ0FBQztRQUNoQixLQUFLLElBQUlBO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUdKO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTUCx3QkFBd0JZLEtBQUs7SUFDbEMsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFFLFdBQVVBLEtBQUksR0FBSTtRQUNuRSxPQUFPO0lBQ1g7SUFDQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtKO0FBQzFCO0FBRUEsSUFBSSxDQUFDLE9BQU9YLFFBQVFpQixPQUFPLEtBQUssY0FBZSxPQUFPakIsUUFBUWlCLE9BQU8sS0FBSyxZQUFZakIsUUFBUWlCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2pCLFFBQVFpQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRaUIsT0FBTyxFQUFFLGNBQWM7UUFBRWhCLE9BQU87SUFBSztJQUNuRUgsT0FBT3FCLE1BQU0sQ0FBQ25CLFFBQVFpQixPQUFPLEVBQUVqQjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRaUIsT0FBTztBQUNsQyxFQUVBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQuanM/MDQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFN0YXRpY0dlbkJhaWxvdXRFcnJvcjogbnVsbCxcbiAgICBpc1N0YXRpY0dlbkJhaWxvdXRFcnJvcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBTdGF0aWNHZW5CYWlsb3V0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU3RhdGljR2VuQmFpbG91dEVycm9yO1xuICAgIH0sXG4gICAgaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3I7XG4gICAgfVxufSk7XG5jb25zdCBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCA9IFwiTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcIjtcbmNsYXNzIFN0YXRpY0dlbkJhaWxvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuY29kZSA9IE5FWFRfU1RBVElDX0dFTl9CQUlMT1VUO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGljR2VuQmFpbG91dEVycm9yKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gXCJvYmplY3RcIiB8fCBlcnJvciA9PT0gbnVsbCB8fCAhKFwiY29kZVwiIGluIGVycm9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBlcnJvci5jb2RlID09PSBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGljLWdlbmVyYXRpb24tYmFpbG91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJpc1N0YXRpY0dlbkJhaWxvdXRFcnJvciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIk5FWFRfU1RBVElDX0dFTl9CQUlMT1VUIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJjb2RlIiwiZXJyb3IiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4012\n");

/***/ })

};
;